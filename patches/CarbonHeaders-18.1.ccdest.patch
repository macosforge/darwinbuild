diff -Nru ../CarbonHeaders-18.1.orig/Aliases.h ./Aliases.h
--- ../CarbonHeaders-18.1.orig/Aliases.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Aliases.h	2009-09-29 13:59:38.000000000 -0700
@@ -0,0 +1,1233 @@
+/*
+ * Copyright (c) 2007-2009 by Apple Inc.. All rights reserved.
+ *
+ * @APPLE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this
+ * file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_LICENSE_HEADER_END@
+ */
+/*
+     File:       CarbonCore/Aliases.h
+ 
+     Contains:   Alias Manager Interfaces.
+ 
+     Version:    CarbonCore-859.2~1
+ 
+     Copyright:  © 1989-2008 by Apple Computer, Inc., all rights reserved
+ 
+     Bugs?:      For bug reports, consult the following page on
+                 the World Wide Web:
+ 
+                     http://developer.apple.com/bugreporter/
+ 
+*/
+#ifndef __ALIASES__
+#define __ALIASES__
+
+#ifndef __MACTYPES__
+#include <CarbonCore/MacTypes.h>
+#endif
+
+#ifndef __FILES__
+#include <CarbonCore/Files.h>
+#endif
+
+
+
+#include <AvailabilityMacros.h>
+
+#if PRAGMA_ONCE
+#pragma once
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#pragma pack(push, 2)
+
+typedef UInt32                          FSAliasInfoBitmap;
+enum {
+  kFSAliasInfoNone              = 0x00000000, /* no valid info*/
+  kFSAliasInfoVolumeCreateDate  = 0x00000001, /* volume creation date is valid*/
+  kFSAliasInfoTargetCreateDate  = 0x00000002, /* target creation date is valid*/
+  kFSAliasInfoFinderInfo        = 0x00000004, /* file type and creator are valid*/
+  kFSAliasInfoIsDirectory       = 0x00000008, /* isDirectory boolean is valid*/
+  kFSAliasInfoIDs               = 0x00000010, /* parentDirID and nodeID are valid*/
+  kFSAliasInfoFSInfo            = 0x00000020, /* filesystemID and signature are valid*/
+  kFSAliasInfoVolumeFlags       = 0x00000040 /* volumeIsBootVolume, volumeIsAutomounted, volumeIsEjectable and volumeHasPersistentFileIDs are valid*/
+};
+
+enum {
+  rAliasType                    = 'alis' /* Aliases are stored as resources of this type */
+};
+
+enum {
+                                        /* define alias resolution action rules mask */
+  kARMMountVol                  = 0x00000001, /* mount the volume automatically */
+  kARMNoUI                      = 0x00000002, /* no user interface allowed during resolution */
+  kARMMultVols                  = 0x00000008, /* search on multiple volumes */
+  kARMSearch                    = 0x00000100, /* search quickly */
+  kARMSearchMore                = 0x00000200, /* search further */
+  kARMSearchRelFirst            = 0x00000400, /* search target on a relative path first */
+  kARMTryFileIDFirst            = 0x00000800 /* search by file id before path */
+};
+
+enum {
+                                        /* define alias record information types */
+  asiZoneName                   = -3,   /* get zone name */
+  asiServerName                 = -2,   /* get server name */
+  asiVolumeName                 = -1,   /* get volume name */
+  asiAliasName                  = 0,    /* get aliased file/folder/volume name */
+  asiParentName                 = 1     /* get parent folder name */
+};
+
+/* ResolveAliasFileWithMountFlags options */
+enum {
+  kResolveAliasFileNoUI         = 0x00000001, /* no user interaction during resolution */
+  kResolveAliasTryFileIDFirst   = 0x00000002 /* search by file id before path */
+};
+
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_4
+#define __AL_USE_OPAQUE_RECORD__ 1
+#else
+#define __AL_USE_OPAQUE_RECORD__ 0
+#endif
+/* define the alias record that will be the blackbox for the caller */
+#if __AL_USE_OPAQUE_RECORD__
+struct AliasRecord {
+  UInt8               hidden[6];
+};
+typedef struct AliasRecord              AliasRecord;
+#else
+struct AliasRecord {
+  OSType              userType;               /* appl stored type like creator type */
+  unsigned short      aliasSize;              /* alias record size in bytes, for appl usage */
+};
+typedef struct AliasRecord              AliasRecord;
+#endif  /* __AL_USE_OPAQUE_RECORD__ */
+
+typedef AliasRecord *                   AliasPtr;
+typedef AliasPtr *                      AliasHandle;
+/* info block to pass to FSCopyAliasInfo */
+struct FSAliasInfo {
+  UTCDateTime         volumeCreateDate;
+  UTCDateTime         targetCreateDate;
+  OSType              fileType;
+  OSType              fileCreator;
+  UInt32              parentDirID;
+  UInt32              nodeID;
+  UInt16              filesystemID;
+  UInt16              signature;
+  Boolean             volumeIsBootVolume;
+  Boolean             volumeIsAutomounted;
+  Boolean             volumeIsEjectable;
+  Boolean             volumeHasPersistentFileIDs;
+  Boolean             isDirectory;
+};
+typedef struct FSAliasInfo              FSAliasInfo;
+typedef FSAliasInfo *                   FSAliasInfoPtr;
+/* alias record information type */
+typedef short                           AliasInfoType;
+#if !__LP64__
+typedef CALLBACK_API( Boolean , AliasFilterProcPtr )(CInfoPBPtr cpbPtr, Boolean *quitFlag, Ptr myDataPtr);
+typedef STACK_UPP_TYPE(AliasFilterProcPtr)                      AliasFilterUPP;
+/*
+ *  NewAliasFilterUPP()
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   available as macro/inline
+ */
+extern AliasFilterUPP
+NewAliasFilterUPP(AliasFilterProcPtr userRoutine)             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+/*
+ *  DisposeAliasFilterUPP()
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   available as macro/inline
+ */
+extern void
+DisposeAliasFilterUPP(AliasFilterUPP userUPP)                 AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+/*
+ *  InvokeAliasFilterUPP()
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   available as macro/inline
+ */
+extern Boolean
+InvokeAliasFilterUPP(
+  CInfoPBPtr      cpbPtr,
+  Boolean *       quitFlag,
+  Ptr             myDataPtr,
+  AliasFilterUPP  userUPP)                                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+#if __MACH__
+  #ifdef __cplusplus
+    inline AliasFilterUPP                                       NewAliasFilterUPP(AliasFilterProcPtr userRoutine) { return userRoutine; }
+    inline void                                                 DisposeAliasFilterUPP(AliasFilterUPP) { }
+    inline Boolean                                              InvokeAliasFilterUPP(CInfoPBPtr cpbPtr, Boolean * quitFlag, Ptr myDataPtr, AliasFilterUPP userUPP) { return (*userUPP)(cpbPtr, quitFlag, myDataPtr); }
+  #else
+    #define NewAliasFilterUPP(userRoutine)                      ((AliasFilterUPP)userRoutine)
+    #define DisposeAliasFilterUPP(userUPP)
+    #define InvokeAliasFilterUPP(cpbPtr, quitFlag, myDataPtr, userUPP) (*userUPP)(cpbPtr, quitFlag, myDataPtr)
+  #endif
+#endif
+
+#endif  /* !__LP64__ */
+
+typedef CALLBACK_API_C( Boolean , FSAliasFilterProcPtr )(const FSRef *ref, Boolean *quitFlag, Ptr myDataPtr);
+/*
+ *  FSNewAlias()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.1 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.1 and later
+ */
+extern OSErr 
+FSNewAlias(
+  const FSRef *  fromFile,       /* can be NULL */
+  const FSRef *  target,
+  AliasHandle *  inAlias)                                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  FSNewAliasMinimal()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.1 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.1 and later
+ */
+extern OSErr 
+FSNewAliasMinimal(
+  const FSRef *  target,
+  AliasHandle *  inAlias)                                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  FSIsAliasFile()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.1 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.1 and later
+ */
+extern OSErr 
+FSIsAliasFile(
+  const FSRef *  fileRef,
+  Boolean *      aliasFileFlag,
+  Boolean *      folderFlag)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+
+/*
+ *  FSResolveAliasWithMountFlags()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.1 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.1 and later
+ */
+extern OSErr 
+FSResolveAliasWithMountFlags(
+  const FSRef *   fromFile,         /* can be NULL */
+  AliasHandle     inAlias,
+  FSRef *         target,
+  Boolean *       wasChanged,
+  unsigned long   mountFlags)                                 AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+
+/*
+ *  FSResolveAlias()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.1 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.1 and later
+ */
+extern OSErr 
+FSResolveAlias(
+  const FSRef *  fromFile,         /* can be NULL */
+  AliasHandle    alias,
+  FSRef *        target,
+  Boolean *      wasChanged)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+
+/*
+ *  FSResolveAliasFileWithMountFlags()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.1 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.1 and later
+ */
+extern OSErr 
+FSResolveAliasFileWithMountFlags(
+  FSRef *         theRef,
+  Boolean         resolveAliasChains,
+  Boolean *       targetIsFolder,
+  Boolean *       wasAliased,
+  unsigned long   mountFlags)                                 AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+
+/*
+ *  FSResolveAliasFile()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.1 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.1 and later
+ */
+extern OSErr 
+FSResolveAliasFile(
+  FSRef *    theRef,
+  Boolean    resolveAliasChains,
+  Boolean *  targetIsFolder,
+  Boolean *  wasAliased)                                      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+
+/*
+ *  FSFollowFinderAlias()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.1 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.1 and later
+ */
+extern OSErr 
+FSFollowFinderAlias(
+  FSRef *       fromFile,         /* can be NULL */
+  AliasHandle   alias,
+  Boolean       logon,
+  FSRef *       target,
+  Boolean *     wasChanged)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  FSUpdateAlias()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.1 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.1 and later
+ */
+extern OSErr 
+FSUpdateAlias(
+  const FSRef *  fromFile,         /* can be NULL */
+  const FSRef *  target,
+  AliasHandle    alias,
+  Boolean *      wasChanged)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+
+/*
+ *  FSNewAliasUnicode()
+ *  
+ *  Summary:
+ *    Creates an alias given a ref to the target's parent directory and
+ *    the target's unicode name.  If the target does not exist fnfErr
+ *    will be returned but the alias will still be created.  This
+ *    allows the creation of aliases to targets that do not exist.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Parameters:
+ *    
+ *    fromFile:
+ *      The starting point for a relative search.
+ *    
+ *    targetParentRef:
+ *      An FSRef to the parent directory of the target.
+ *    
+ *    targetNameLength:
+ *      Number of Unicode characters in the target's name.
+ *    
+ *    targetName:
+ *      A pointer to the Unicode name.
+ *    
+ *    inAlias:
+ *      A Handle to the newly created alias record.
+ *    
+ *    isDirectory:
+ *      On input, if target does not exist, a flag to indicate whether
+ *      or not the target is a directory.  On output, if the target did
+ *      exist, a flag indicating if the target is a directory.  Pass
+ *      NULL in the non-existant case if unsure.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.2 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.2 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern OSErr 
+FSNewAliasUnicode(
+  const FSRef *    fromFile,               /* can be NULL */
+  const FSRef *    targetParentRef,
+  UniCharCount     targetNameLength,
+  const UniChar *  targetName,
+  AliasHandle *    inAlias,
+  Boolean *        isDirectory)            /* can be NULL */  AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;
+
+
+/*
+ *  FSNewAliasMinimalUnicode()
+ *  
+ *  Summary:
+ *    Creates a minimal alias given a ref to the target's parent
+ *    directory and the target's unicode name.  If the target does not
+ *    exist fnfErr will be returned but the alias will still be created.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Parameters:
+ *    
+ *    targetParentRef:
+ *      An FSRef to the parent directory of the target.
+ *    
+ *    targetNameLength:
+ *      Number of Unicode characters in the target's name.
+ *    
+ *    targetName:
+ *      A pointer to the Unicode name.
+ *    
+ *    inAlias:
+ *      A Handle to the newly created alias record.
+ *    
+ *    isDirectory:
+ *      On input, if target does not exist, a flag to indicate whether
+ *      or not the target is a directory.  On output, if the target did
+ *      exist, a flag indicating if the target is a directory.  Pass
+ *      NULL in the non-existant case if unsure.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.2 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.2 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern OSErr 
+FSNewAliasMinimalUnicode(
+  const FSRef *    targetParentRef,
+  UniCharCount     targetNameLength,
+  const UniChar *  targetName,
+  AliasHandle *    inAlias,
+  Boolean *        isDirectory)            /* can be NULL */  AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;
+
+
+/*
+ *  FSNewAliasFromPath()
+ *  
+ *  Summary:
+ *    Creates an alias given a POSIX style utf-8 path to the target. 
+ *    If the target file does not exist but the path up to the leaf
+ *    does then fnfErr will be returned but the alias will still be
+ *    created.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.5
+ *  
+ *  Parameters:
+ *    
+ *    fromFilePath:
+ *      The starting point for a relative search.
+ *    
+ *    targetPath:
+ *      POSIX style UTF-8 path to target.
+ *    
+ *    flags:
+ *      Options for future use.  Pass in 0.
+ *    
+ *    inAlias:
+ *      A Handle to the newly created alias record.
+ *    
+ *    isDirectory:
+ *      On input, if target does not exist, a flag to indicate whether
+ *      or not the target is a directory.  On output, if the target did
+ *      exist, a flag indicating if the target is a directory.  Pass
+ *      NULL in the non-existant case if unsure.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.5 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.5 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus 
+FSNewAliasFromPath(
+  const char *   fromFilePath,       /* can be NULL */
+  const char *   targetPath,
+  OptionBits     flags,
+  AliasHandle *  inAlias,
+  Boolean *      isDirectory)        /* can be NULL */        AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
+
+
+/*
+ *  FSMatchAliasBulk()
+ *  
+ *  Summary:
+ *    Given an alias handle and fromFile, match the alias and return
+ *    FSRefs to the aliased file(s) and needsUpdate flag
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.5
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.5 and later in CoreServices.framework
+ *    CarbonLib:        not available
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus 
+FSMatchAliasBulk(
+  const FSRef *          fromFile,          /* can be NULL */
+  unsigned long          rulesMask,
+  AliasHandle            inAlias,
+  short *                aliasCount,
+  FSRef *                aliasList,
+  Boolean *              needsUpdate,
+  FSAliasFilterProcPtr   aliasFilter,       /* can be NULL */
+  void *                 yourDataPtr)       /* can be NULL */ AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
+
+
+
+/*
+ *  FSCopyAliasInfo()
+ *  
+ *  Discussion:
+ *    This routine will return the requested information from the
+ *    passed in aliasHandle.  The information is gathered only from the
+ *    alias record so it may not match what is on disk (no disk i/o is
+ *    performed).  The whichInfo paramter is an output parameter that
+ *    signifies which fields in the info record contain valid data.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.2
+ *  
+ *  Parameters:
+ *    
+ *    inAlias:
+ *      A handle to the alias record to get the information from.
+ *    
+ *    targetName:
+ *      The name of the target item.
+ *    
+ *    volumeName:
+ *      The name of the volume the target resides on.
+ *    
+ *    pathString:
+ *      POSIX path to target.
+ *    
+ *    whichInfo:
+ *      An indication of which fields in the info block contain valid
+ *      data.
+ *    
+ *    info:
+ *      Returned information about the alias.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.2 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.2 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus 
+FSCopyAliasInfo(
+  AliasHandle          inAlias,
+  HFSUniStr255 *       targetName,       /* can be NULL */
+  HFSUniStr255 *       volumeName,       /* can be NULL */
+  CFStringRef *        pathString,       /* can be NULL */
+  FSAliasInfoBitmap *  whichInfo,        /* can be NULL */
+  FSAliasInfo *        info)             /* can be NULL */    AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;
+
+
+/*
+ *  GetAliasSize()
+ *  
+ *  Discussion:
+ *    This routine will return the size of the alias record referenced
+ *    by the AliasHandle alias.  This will be smaller than the size
+ *    returned by GetHandleSize if any custom data has been added (IM
+ *    Files 4-13).
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Parameters:
+ *    
+ *    alias:
+ *      A handle to the alias record to get the information from.
+ *  
+ *  Result:
+ *    The size of the private section of the alias record.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.4 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern Size 
+GetAliasSize(AliasHandle alias)                               AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/*
+ *  GetAliasUserType()
+ *  
+ *  Discussion:
+ *    This routine will return the usertype associated with the alias
+ *    record referenced by the AliasHandle alias.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Parameters:
+ *    
+ *    alias:
+ *      A handle to the alias record to get the userType from.
+ *  
+ *  Result:
+ *    The userType associated with the alias as an OSType
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.4 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern OSType 
+GetAliasUserType(AliasHandle alias)                           AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/*
+ *  SetAliasUserType()
+ *  
+ *  Discussion:
+ *    This routine will set the userType associated with an alias
+ *    record.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Parameters:
+ *    
+ *    alias:
+ *      A handle to the alias record to set the userType for.
+ *    
+ *    userType:
+ *      The OSType to set the userType to.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.4 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern void 
+SetAliasUserType(
+  AliasHandle   alias,
+  OSType        userType)                                     AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/*
+ *  GetAliasSizeFromPtr()
+ *  
+ *  Discussion:
+ *    This routine will return the size of the alias record referenced
+ *    by a pointer to the AliasRecord.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Parameters:
+ *    
+ *    alias:
+ *      A pointer to the alias record to get the information from.
+ *  
+ *  Result:
+ *    The size of the private section of the alias record.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available
+ *    Non-Carbon CFM:   not available
+ */
+extern Size 
+GetAliasSizeFromPtr(const AliasRecord * alias)                AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/*
+ *  GetAliasUserTypeFromPtr()
+ *  
+ *  Discussion:
+ *    This routine will return the usertype associated withthe alias
+ *    record pointed to by alias.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Parameters:
+ *    
+ *    alias:
+ *      A pointer to the alias record to get the userType from.
+ *  
+ *  Result:
+ *    The userType associated with the alias as an OSType
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available
+ *    Non-Carbon CFM:   not available
+ */
+extern OSType 
+GetAliasUserTypeFromPtr(const AliasRecord * alias)            AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/*
+ *  SetAliasUserTypeWithPtr()
+ *  
+ *  Discussion:
+ *    This routine will set the userType associated with an alias
+ *    record.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Parameters:
+ *    
+ *    alias:
+ *      A pointer to the alias record to set the userType for.
+ *    
+ *    userType:
+ *      The OSType to set the userType to.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available
+ *    Non-Carbon CFM:   not available
+ */
+extern void 
+SetAliasUserTypeWithPtr(
+  AliasPtr   alias,
+  OSType     userType)                                        AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/* Functions beyond this point are deprecated*/
+
+#if !__LP64__
+/*
+ *  FSMatchAlias()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    Use FSMatchAliasBulk instead
+ *  
+ *  Summary:
+ *    Given an alias handle and fromFile, match the alias and return
+ *    FSRefs to the aliased file(s) and needsUpdate flag
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.2 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.2 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern OSErr 
+FSMatchAlias(
+  const FSRef *    fromFile,          /* can be NULL */
+  unsigned long    rulesMask,
+  AliasHandle      inAlias,
+  short *          aliasCount,
+  FSRef *          aliasList,
+  Boolean *        needsUpdate,
+  AliasFilterUPP   aliasFilter,
+  void *           yourDataPtr)                               AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/*
+ *  FSMatchAliasNoUI()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    Use FSMatchAliasBulk with the kARMNoUI flag instead
+ *  
+ *  Summary:
+ *    variation on FSMatchAlias that does not prompt user with a dialog
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.2 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.2 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern OSErr 
+FSMatchAliasNoUI(
+  const FSRef *    fromFile,          /* can be NULL */
+  unsigned long    rulesMask,
+  AliasHandle      inAlias,
+  short *          aliasCount,
+  FSRef *          aliasList,
+  Boolean *        needsUpdate,
+  AliasFilterUPP   aliasFilter,
+  void *           yourDataPtr)                               AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/*
+ *  NewAlias()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    Use FSNewAlias
+ *  
+ *  Summary:
+ *    create a new alias between fromFile and target, returns alias
+ *    record handle
+ *  
+ *  Discussion:
+ *    Create an alias betwen fromFile and target, and return it in an
+ *    AliasHandle. This function is deprecated in Mac OS X 10.4;
+ *    instead, you should use FSNewAliasUnicode() because NewAlias()
+ *    has problems creating aliases to certain files, including those
+ *    which are impossible to represent in an FSSpec.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+NewAlias(
+  const FSSpec *  fromFile,       /* can be NULL */
+  const FSSpec *  target,
+  AliasHandle *   alias)                                      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  NewAliasMinimal()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    Use FSNewAliasMinimalUnicode
+ *  
+ *  Summary:
+ *    create a minimal new alias for a target and return alias record
+ *    handle
+ *  
+ *  Discussion:
+ *    Create a minimal alias for a target, and return it in an
+ *    AliasHandle. This function is deprecated in Mac OS X 10.4;
+ *    instead, you should use FSNewAliasMinimalUnicode() because
+ *    NewAliasMinimalAlias() has problems creating aliases to certain
+ *    files, including those which are impossible to represent in an
+ *    FSSpec.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+NewAliasMinimal(
+  const FSSpec *  target,
+  AliasHandle *   alias)                                      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  NewAliasMinimalFromFullPath()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    Use FSNewAliasMinimalUnicode
+ *  
+ *  Summary:
+ *    create a minimal new alias from a target fullpath (optional zone
+ *    and server name) and return alias record handle
+ *  
+ *  Discussion:
+ *    Create a minimal alias for a target fullpath, and return it in an
+ *    AliasHandle. This function is deprecated in Mac OS X 10.4;
+ *    instead, you should use FSNewAliasMinimalUnicode() because
+ *    NewAliasMinimalFromFullPath() has problems creating aliases to
+ *    certain files, including those which are impossible to represent
+ *    in an FSSpec.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+NewAliasMinimalFromFullPath(
+  short             fullPathLength,
+  const void *      fullPath,
+  ConstStr32Param   zoneName,
+  ConstStr31Param   serverName,
+  AliasHandle *     alias)                                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  ResolveAlias()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    Use FSResolveAlias() or FSResolveAliasWithMountFlags() instead.
+ *  
+ *  Summary:
+ *    given an alias handle and fromFile, resolve the alias, update the
+ *    alias record and return aliased filename and wasChanged flag.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+ResolveAlias(
+  const FSSpec *  fromFile,         /* can be NULL */
+  AliasHandle     alias,
+  FSSpec *        target,
+  Boolean *       wasChanged)                                 AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  GetAliasInfo()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    Use FSCopyAliasInfo instead.
+ *  
+ *  Summary:
+ *    This call does not work on all aliases. Given an alias handle and
+ *    an index specifying requested alias information type, return the
+ *    information from alias record as a string. An empty string is
+ *    returned when the index is greater than the number of levels
+ *    between the target and root.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.3
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+GetAliasInfo(
+  AliasHandle     alias,
+  AliasInfoType   itemIndex,
+  Str63           theString)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3;
+
+
+
+/*
+ *  IsAliasFile()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    Use FSIsAliasFile() instead.
+ *  
+ *  Summary:
+ *    Return true if the file pointed to by fileFSSpec is an alias file.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
+ */
+extern OSErr 
+IsAliasFile(
+  const FSSpec *  fileFSSpec,
+  Boolean *       aliasFileFlag,
+  Boolean *       folderFlag)                                 AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  ResolveAliasWithMountFlags()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    Use FSResolveAliasWithMountFlags() instead.
+ *  
+ *  Summary:
+ *    Given an AliasHandle, return target file spec. It resolves the
+ *    entire alias chain or one step of the chain.  It returns info
+ *    about whether the target is a folder or file; and whether the
+ *    input file spec was an alias or not.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
+ */
+extern OSErr 
+ResolveAliasWithMountFlags(
+  const FSSpec *  fromFile,         /* can be NULL */
+  AliasHandle     alias,
+  FSSpec *        target,
+  Boolean *       wasChanged,
+  unsigned long   mountFlags)                                 AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  ResolveAliasFile()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    Use FSResolveAliasFile
+ *  
+ *  Summary:
+ *    Given a file spec, return target file spec if input file spec is
+ *    an alias. It resolves the entire alias chain or one step of the
+ *    chain.  It returns info about whether the target is a folder or
+ *    file; and whether the input file spec was an alias or not.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+ResolveAliasFile(
+  FSSpec *   theSpec,
+  Boolean    resolveAliasChains,
+  Boolean *  targetIsFolder,
+  Boolean *  wasAliased)                                      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* Deprecated: Use FSResolveAliasFileWithMountFlags instead*/
+/*
+ *  ResolveAliasFileWithMountFlags()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
+ */
+extern OSErr 
+ResolveAliasFileWithMountFlags(
+  FSSpec *        theSpec,
+  Boolean         resolveAliasChains,
+  Boolean *       targetIsFolder,
+  Boolean *       wasAliased,
+  unsigned long   mountFlags)                                 AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/* Deprecated:  Use FSFollowFinderAlias instead*/
+/*
+ *  FollowFinderAlias()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
+ */
+extern OSErr 
+FollowFinderAlias(
+  const FSSpec *  fromFile,         /* can be NULL */
+  AliasHandle     alias,
+  Boolean         logon,
+  FSSpec *        target,
+  Boolean *       wasChanged)                                 AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/* 
+   Low Level Routines 
+*/
+/*
+ *  UpdateAlias()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    UseFSUpdateAlias
+ *  
+ *  Summary:
+ *    given a fromFile-target pair and an alias handle, update the
+ *    alias record pointed to by alias handle to represent target as
+ *    the new alias.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+UpdateAlias(
+  const FSSpec *  fromFile,         /* can be NULL */
+  const FSSpec *  target,
+  AliasHandle     alias,
+  Boolean *       wasChanged)                                 AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+
+/*
+ *  MatchAlias()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    Use FSMatchAliasBulk instead
+ *  
+ *  Summary:
+ *    Given an alias handle and fromFile, match the alias and return
+ *    FSSpecs to the aliased file(s) and needsUpdate flag
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+MatchAlias(
+  const FSSpec *   fromFile,          /* can be NULL */
+  unsigned long    rulesMask,
+  AliasHandle      alias,
+  short *          aliasCount,
+  FSSpecArrayPtr   aliasList,
+  Boolean *        needsUpdate,
+  AliasFilterUPP   aliasFilter,
+  void *           yourDataPtr)                               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+
+
+/*
+ *  ResolveAliasFileWithMountFlagsNoUI()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    Use FSResolveAliasFileWithMountFlags passing in the
+ *    kResolveAliasFileNoUI flag
+ *  
+ *  Summary:
+ *    variation on ResolveAliasFile that does not prompt user with a
+ *    dialog
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern OSErr 
+ResolveAliasFileWithMountFlagsNoUI(
+  FSSpec *        theSpec,
+  Boolean         resolveAliasChains,
+  Boolean *       targetIsFolder,
+  Boolean *       wasAliased,
+  unsigned long   mountFlags)                                 AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  MatchAliasNoUI()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    Use FSMatchAliasBulk with the kARMNoUI flag instead
+ *  
+ *  Summary:
+ *    variation on MatchAlias that does not prompt user with a dialog
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern OSErr 
+MatchAliasNoUI(
+  const FSSpec *   fromFile,          /* can be NULL */
+  unsigned long    rulesMask,
+  AliasHandle      alias,
+  short *          aliasCount,
+  FSSpecArrayPtr   aliasList,
+  Boolean *        needsUpdate,
+  AliasFilterUPP   aliasFilter,
+  void *           yourDataPtr)                               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+
+#endif  /* !__LP64__ */
+
+
+#pragma pack(pop)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __ALIASES__ */
+
diff -Nru ../CarbonHeaders-18.1.orig/ConditionalMacros.h ./ConditionalMacros.h
--- ../CarbonHeaders-18.1.orig/ConditionalMacros.h	2009-09-29 13:46:25.000000000 -0700
+++ ./ConditionalMacros.h	2009-09-29 13:59:47.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1993-2008 by Apple Inc.. All rights reserved.
+ * Copyright (c) 2007-2009 by Apple Inc.. All rights reserved.
  *
  * @APPLE_LICENSE_HEADER_START@
  * 
@@ -20,14 +20,15 @@
  * 
  * @APPLE_LICENSE_HEADER_END@
  */
-
 /*
-     File:       ConditionalMacros.h
+     File:       CarbonCore/ConditionalMacros.h
  
      Contains:   Set up for compiler independent conditionals
  
-     Version:    CarbonCore-769~1
-  
+     Version:    CarbonCore-859.2~1
+ 
+     Copyright:  © 1993-2008 by Apple Computer, Inc., all rights reserved
+ 
      Bugs?:      For bug reports, consult the following page on
                  the World Wide Web:
  
@@ -135,7 +136,11 @@
   #define TYPE_EXTENDED               0
 
   #ifdef __ppc__
-    #define TYPE_LONGDOUBLE_IS_DOUBLE 1
+  #ifdef __LONG_DOUBLE_128__
+     #define TYPE_LONGDOUBLE_IS_DOUBLE 0
+    #else
+      #define TYPE_LONGDOUBLE_IS_DOUBLE 1
+    #endif
   #else
     #define TYPE_LONGDOUBLE_IS_DOUBLE 0
   #endif
@@ -152,7 +157,7 @@
   #define FUNCTION_WIN32CC            0 
   
   #ifdef __MACOS_CLASSIC__
-    #ifndef TARGET_API_MAC_CARBON            /* gcc cfm cross compiler assumes you're building Carbon code */
+    #ifndef TARGET_API_MAC_CARBON           /* gcc cfm cross compiler assumes you're building Carbon code */
        #define TARGET_API_MAC_CARBON 1
     #endif
   #endif
diff -Nru ../CarbonHeaders-18.1.orig/DateTimeUtils.h ./DateTimeUtils.h
--- ../CarbonHeaders-18.1.orig/DateTimeUtils.h	1969-12-31 16:00:00.000000000 -0800
+++ ./DateTimeUtils.h	2009-09-29 14:00:25.000000000 -0700
@@ -0,0 +1,1016 @@
+/*
+ * Copyright (c) 2007-2009 by Apple Inc.. All rights reserved.
+ *
+ * @APPLE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this
+ * file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_LICENSE_HEADER_END@
+ */
+/*
+     File:       CarbonCore/DateTimeUtils.h
+ 
+     Contains:   International Date and Time Interfaces (previously in TextUtils)
+ 
+     Version:    CarbonCore-859.2~1
+ 
+     Copyright:  © 1994-2008 by Apple Computer, Inc., all rights reserved.
+ 
+     Bugs?:      For bug reports, consult the following page on
+                 the World Wide Web:
+ 
+                     http://developer.apple.com/bugreporter/
+ 
+*/
+#ifndef __DATETIMEUTILS__
+#define __DATETIMEUTILS__
+
+#ifndef __CONDITIONALMACROS__
+#include <CarbonCore/ConditionalMacros.h>
+#endif
+
+#ifndef __MACTYPES__
+#include <CarbonCore/MacTypes.h>
+#endif
+
+#ifndef __UTCUTILS__
+#include <CarbonCore/UTCUtils.h>
+#endif
+
+#ifndef __CFDATE__
+#include <CoreFoundation/CFDate.h>
+#endif
+
+
+
+#include <AvailabilityMacros.h>
+
+#if PRAGMA_ONCE
+#pragma once
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#pragma pack(push, 2)
+
+/*
+
+    Here are the current routine names and the translations to the older forms.
+    Please use the newer forms in all new code and migrate the older names out of existing
+    code as maintainance permits.
+    
+    New Name                    Old Name(s)
+    
+    DateString                  IUDatePString IUDateString 
+    InitDateCache
+    LongDateString              IULDateString
+    LongTimeString              IULTimeString
+    StringToDate                String2Date
+    StringToTime                                
+    TimeString                  IUTimeString IUTimePString
+    LongDateToSeconds           LongDate2Secs
+    LongSecondsToDate           LongSecs2Date
+    DateToSeconds               Date2Secs
+    SecondsToDate               Secs2Date
+
+
+    Carbon only supports the new names.  The old names are undefined for Carbon targets.
+    This is true for C, Assembly and Pascal.
+    
+    InterfaceLib always has exported the old names.  For C macros have been defined to allow
+    the use of the new names.  For Pascal and Assembly using the new names will result
+    in link errors. 
+    
+*/
+
+typedef SInt16 ToggleResults;
+enum {
+                                        /* Toggle results */
+  toggleUndefined               = 0,
+  toggleOK                      = 1,
+  toggleBadField                = 2,
+  toggleBadDelta                = 3,
+  toggleBadChar                 = 4,
+  toggleUnknown                 = 5,
+  toggleBadNum                  = 6,
+  toggleOutOfRange              = 7,    /*synonym for toggleErr3*/
+  toggleErr3                    = 7,
+  toggleErr4                    = 8,
+  toggleErr5                    = 9
+};
+
+enum {
+                                        /* Date equates */
+  smallDateBit                  = 31,   /*Restrict valid date/time to range of Time global*/
+  togChar12HourBit              = 30,   /*If toggling hour by char, accept hours 1..12 only*/
+  togCharZCycleBit              = 29,   /*Modifier for togChar12HourBit: accept hours 0..11 only*/
+  togDelta12HourBit             = 28,   /*If toggling hour up/down, restrict to 12-hour range (am/pm)*/
+  genCdevRangeBit               = 27,   /*Restrict date/time to range used by genl CDEV*/
+  validDateFields               = -1,
+  maxDateField                  = 10
+};
+
+enum {
+  eraMask                       = 0x0001,
+  yearMask                      = 0x0002,
+  monthMask                     = 0x0004,
+  dayMask                       = 0x0008,
+  hourMask                      = 0x0010,
+  minuteMask                    = 0x0020,
+  secondMask                    = 0x0040,
+  dayOfWeekMask                 = 0x0080,
+  dayOfYearMask                 = 0x0100,
+  weekOfYearMask                = 0x0200,
+  pmMask                        = 0x0400,
+  dateStdMask                   = 0x007F /*default for ValidDate flags and ToggleDate TogglePB.togFlags*/
+};
+
+typedef SInt8 LongDateField;
+enum {
+  eraField                      = 0,
+  yearField                     = 1,
+  monthField                    = 2,
+  dayField                      = 3,
+  hourField                     = 4,
+  minuteField                   = 5,
+  secondField                   = 6,
+  dayOfWeekField                = 7,
+  dayOfYearField                = 8,
+  weekOfYearField               = 9,
+  pmField                       = 10,
+  res1Field                     = 11,
+  res2Field                     = 12,
+  res3Field                     = 13
+};
+
+typedef SInt8 DateForm;
+enum {
+  shortDate                     = 0,
+  longDate                      = 1,
+  abbrevDate                    = 2
+};
+
+enum {
+                                        /* StringToDate status values */
+  fatalDateTime                 = 0x8000, /* StringToDate and String2Time mask to a fatal error */
+  longDateFound                 = 1,    /* StringToDate mask to long date found */
+  leftOverChars                 = 2,    /* StringToDate & Time mask to warn of left over characters */
+  sepNotIntlSep                 = 4,    /* StringToDate & Time mask to warn of non-standard separators */
+  fieldOrderNotIntl             = 8,    /* StringToDate & Time mask to warn of non-standard field order */
+  extraneousStrings             = 16,   /* StringToDate & Time mask to warn of unparsable strings in text */
+  tooManySeps                   = 32,   /* StringToDate & Time mask to warn of too many separators */
+  sepNotConsistent              = 64,   /* StringToDate & Time mask to warn of inconsistent separators */
+  tokenErr                      = 0x8100, /* StringToDate & Time mask for 'tokenizer err encountered' */
+  cantReadUtilities             = 0x8200,
+  dateTimeNotFound              = 0x8400,
+  dateTimeInvalid               = 0x8800
+};
+
+typedef short                           StringToDateStatus;
+typedef StringToDateStatus              String2DateStatus;
+struct DateCacheRecord {
+  short               hidden[256];            /* only for temporary use */
+};
+typedef struct DateCacheRecord          DateCacheRecord;
+typedef DateCacheRecord *               DateCachePtr;
+struct DateTimeRec {
+  short               year;
+  short               month;
+  short               day;
+  short               hour;
+  short               minute;
+  short               second;
+  short               dayOfWeek;
+};
+typedef struct DateTimeRec              DateTimeRec;
+
+typedef SInt64                          LongDateTime;
+#if TARGET_RT_BIG_ENDIAN
+union LongDateCvt {
+  SInt64              c;
+  struct {
+    UInt32              lHigh;
+    UInt32              lLow;
+  }                       hl;
+};
+typedef union LongDateCvt               LongDateCvt;
+#else
+union LongDateCvt {
+  SInt64              c;
+  struct {
+    UInt32              lLow;
+    UInt32              lHigh;
+  }                       hl;
+};
+typedef union LongDateCvt               LongDateCvt;
+#endif  /* TARGET_RT_BIG_ENDIAN */
+
+union LongDateRec {
+  struct {
+    short               era;
+    short               year;
+    short               month;
+    short               day;
+    short               hour;
+    short               minute;
+    short               second;
+    short               dayOfWeek;
+    short               dayOfYear;
+    short               weekOfYear;
+    short               pm;
+    short               res1;
+    short               res2;
+    short               res3;
+  }                       ld;
+  short               list[14];               /*Index by LongDateField!*/
+  struct {
+    short               eraAlt;
+    DateTimeRec         oldDate;
+  }                       od;
+};
+typedef union LongDateRec               LongDateRec;
+
+typedef SInt8                           DateDelta;
+struct TogglePB {
+  long                togFlags;               /*caller normally sets low word to dateStdMask=$7F*/
+  ResType             amChars;                /*from 'itl0', but uppercased*/
+  ResType             pmChars;                /*from 'itl0', but uppercased*/
+  long                reserved[4];
+};
+typedef struct TogglePB                 TogglePB;
+/*
+    Conversion utilities between CF and Carbon time types. 
+*/
+/*
+ *  UCConvertUTCDateTimeToCFAbsoluteTime()
+ *  
+ *  Discussion:
+ *    Use UCConvertUTCDateTimeToCFAbsoluteTime to convert from a
+ *    UTCDDateTime to a CFAbsoluteTime. Remember that the epoch for
+ *    UTCDateTime is January 1, 1904 while the epoch for CFAbsoluteTime
+ *    is January 1, 2001.
+ *  
+ *  Parameters:
+ *    
+ *    iUTCDate:
+ *      A pointer to a UTCDateTime struct that represents the time you
+ *      wish to convert from.
+ *    
+ *    oCFTime:
+ *      A pointer to a CFAbsoluteTime. On successful return, this will
+ *      contain the converted time from the input time type.
+ *  
+ *  Result:
+ *    A result code indicating whether or not conversion was successful.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.2 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus 
+UCConvertUTCDateTimeToCFAbsoluteTime(
+  const UTCDateTime *  iUTCDate,
+  CFAbsoluteTime *     oCFTime)                               AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;
+
+
+/*
+ *  UCConvertSecondsToCFAbsoluteTime()
+ *  
+ *  Discussion:
+ *    Use UCConvertSecondsToCFAbsoluteTime to convert from the normal
+ *    seconds representation of time to a CFAbsoluteTime. Remember that
+ *    the epoch for seconds is January 1, 1904 while the epoch for
+ *    CFAbsoluteTime is January 1, 2001.
+ *  
+ *  Parameters:
+ *    
+ *    iSeconds:
+ *      A UInt32 value that represents the time you wish to convert
+ *      from.
+ *    
+ *    oCFTime:
+ *      A pointer to a CFAbsoluteTime. On successful return, this will
+ *      contain the converted time from the input time type.
+ *  
+ *  Result:
+ *    A result code indicating whether or not conversion was successful.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.2 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus 
+UCConvertSecondsToCFAbsoluteTime(
+  UInt32            iSeconds,
+  CFAbsoluteTime *  oCFTime)                                  AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;
+
+
+/*
+ *  UCConvertLongDateTimeToCFAbsoluteTime()
+ *  
+ *  Discussion:
+ *    Use UCConvertLongDateTimeToCFAbsoluteTime to convert from a
+ *    LongDateTime to a CFAbsoluteTime. Remember that the epoch for
+ *    LongDateTime is January 1, 1904 while the epoch for
+ *    CFAbsoluteTime is January 1, 2001.
+ *  
+ *  Parameters:
+ *    
+ *    iLongTime:
+ *      A LongDateTime value that represents the time you wish to
+ *      convert from.
+ *    
+ *    oCFTime:
+ *      A pointer to a CFAbsoluteTime. On successful return, this will
+ *      contain the converted time from the input time type.
+ *  
+ *  Result:
+ *    A result code indicating whether or not conversion was successful.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.2 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus 
+UCConvertLongDateTimeToCFAbsoluteTime(
+  LongDateTime      iLongTime,
+  CFAbsoluteTime *  oCFTime)                                  AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;
+
+
+/*
+ *  UCConvertCFAbsoluteTimeToUTCDateTime()
+ *  
+ *  Discussion:
+ *    Use UCConvertCFAbsoluteTimeToUTCDateTime to convert from a
+ *    CFAbsoluteTime to a UTCDateTime. Remember that the epoch for
+ *    UTCDateTime is January 1, 1904 while the epoch for CFAbsoluteTime
+ *    is January 1, 2001.
+ *  
+ *  Parameters:
+ *    
+ *    iCFTime:
+ *      A CFAbsoluteTime value that represents the time you wish to
+ *      convert from.
+ *    
+ *    oUTCDate:
+ *      A pointer to a UTCDateTime. On successful return, this will
+ *      contain the converted time from the CFAbsoluteTime input.
+ *  
+ *  Result:
+ *    A result code indicating whether or not conversion was successful.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.2 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus 
+UCConvertCFAbsoluteTimeToUTCDateTime(
+  CFAbsoluteTime   iCFTime,
+  UTCDateTime *    oUTCDate)                                  AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;
+
+
+/*
+ *  UCConvertCFAbsoluteTimeToSeconds()
+ *  
+ *  Discussion:
+ *    Use UCConvertCFAbsoluteTimeToSeconds to convert from a
+ *    CFAbsoluteTime to a UInt32 representation of seconds. Remember
+ *    that the epoch for seconds is January 1, 1904 while the epoch for
+ *    CFAbsoluteTime is January 1, 2001.
+ *  
+ *  Parameters:
+ *    
+ *    iCFTime:
+ *      A CFAbsoluteTime value that represents the time you wish to
+ *      convert from.
+ *    
+ *    oSeconds:
+ *      A pointer to a UInt32. On successful return, this will contain
+ *      the converted time from the CFAbsoluteTime input.
+ *  
+ *  Result:
+ *    A result code indicating whether or not conversion was successful.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.2 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus 
+UCConvertCFAbsoluteTimeToSeconds(
+  CFAbsoluteTime   iCFTime,
+  UInt32 *         oSeconds)                                  AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;
+
+
+/*
+ *  UCConvertCFAbsoluteTimeToLongDateTime()
+ *  
+ *  Discussion:
+ *    Use UCConvertCFAbsoluteTimeToLongDateTime to convert from a
+ *    CFAbsoluteTime to a LongDateTime. Remember that the epoch for
+ *    LongDateTime is January 1, 1904 while the epoch for
+ *    CFAbsoluteTime is January 1, 2001.
+ *  
+ *  Parameters:
+ *    
+ *    iCFTime:
+ *      A CFAbsoluteTime value that represents the time you wish to
+ *      convert from.
+ *    
+ *    oLongDate:
+ *      A pointer to a LongDateTime. On successful return, this will
+ *      contain the converted time from the CFAbsoluteTime input.
+ *  
+ *  Result:
+ *    A result code indicating whether or not conversion was successful.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.2 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus 
+UCConvertCFAbsoluteTimeToLongDateTime(
+  CFAbsoluteTime   iCFTime,
+  LongDateTime *   oLongDate)                                 AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;
+
+
+#if !__LP64__
+/*
+    These routine are available in Carbon with their new name
+*/
+#if !__LP64__
+/*
+ *  DateString()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    use CFDateFormatterCreateStringWithDate instead
+ *  
+ *  Discussion:
+ *    This function is no longer recommended. Please use
+ *    CFDateFormatterCreateStringWithDate instead.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.3
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern void 
+DateString(
+  SInt32     dateTime,
+  DateForm   longFlag,
+  Str255     result,
+  Handle     intlHandle)                                      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3;
+
+
+/*
+ *  TimeString()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    use CFDateFormatterCreateStringWithDate instead
+ *  
+ *  Discussion:
+ *    This function is no longer recommended. Please use
+ *    CFDateFormatterCreateStringWithDate instead.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.3
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern void 
+TimeString(
+  SInt32    dateTime,
+  Boolean   wantSeconds,
+  Str255    result,
+  Handle    intlHandle)                                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3;
+
+
+/*
+ *  LongDateString()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    use CFDateFormatterCreateStringWithDate instead
+ *  
+ *  Discussion:
+ *    This function is no longer recommended. Please use
+ *    CFDateFormatterCreateStringWithDate instead.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.3
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern void 
+LongDateString(
+  const LongDateTime *  dateTime,
+  DateForm              longFlag,
+  Str255                result,
+  Handle                intlHandle)                           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3;
+
+
+/*
+ *  LongTimeString()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    use CFDateFormatterCreateStringWithDate instead
+ *  
+ *  Discussion:
+ *    This function is no longer recommended. Please use
+ *    CFDateFormatterCreateStringWithDate instead.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.3
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern void 
+LongTimeString(
+  const LongDateTime *  dateTime,
+  Boolean               wantSeconds,
+  Str255                result,
+  Handle                intlHandle)                           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3;
+
+
+
+/*
+    These routine are available in Carbon and InterfaceLib with their new name
+*/
+/*
+ *  InitDateCache()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    No longer needed on MacOS X.
+ *  
+ *  Discussion:
+ *    This function is obsolate.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.3
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+InitDateCache(DateCachePtr theCache)                          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3;
+
+
+/*
+ *  StringToDate()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    use CFDateFormatterCreateDateFromString instead
+ *  
+ *  Discussion:
+ *    This function is no longer recommended. Please use
+ *    CFDateFormatterCreateDateFromString instead.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.3
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern StringToDateStatus 
+StringToDate(
+  Ptr            textPtr,
+  SInt32         textLen,
+  DateCachePtr   theCache,
+  SInt32 *       lengthUsed,
+  LongDateRec *  dateTime)                                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3;
+
+
+/*
+ *  StringToTime()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    use CFDateFormatterCreateDateFromString instead
+ *  
+ *  Discussion:
+ *    This function is no longer recommended. Please use
+ *    CFDateFormatterCreateDateFromString instead.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.3
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern StringToDateStatus 
+StringToTime(
+  Ptr            textPtr,
+  SInt32         textLen,
+  DateCachePtr   theCache,
+  SInt32 *       lengthUsed,
+  LongDateRec *  dateTime)                                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3;
+
+
+/*
+ *  LongDateToSeconds()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    use CFCalendar instead.
+ *  
+ *  Discussion:
+ *    This function is no longer recommended. Please use CFCalendar
+ *    instead.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.3
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern void 
+LongDateToSeconds(
+  const LongDateRec *  lDate,
+  LongDateTime *       lSecs)                                 AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3;
+
+
+/*
+ *  LongSecondsToDate()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    use CFCalendar instead.
+ *  
+ *  Discussion:
+ *    This function is no longer recommended. Please use CFCalendar
+ *    instead.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.3
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern void 
+LongSecondsToDate(
+  const LongDateTime *  lSecs,
+  LongDateRec *         lDate)                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3;
+
+
+/*
+ *  ToggleDate()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    use CFCalendar instead.
+ *  
+ *  Discussion:
+ *    This function is no longer recommended. Please use CFCalendar
+ *    instead.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.3
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern ToggleResults 
+ToggleDate(
+  LongDateTime *    lSecs,
+  LongDateField     field,
+  DateDelta         delta,
+  short             ch,
+  const TogglePB *  params)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3;
+
+
+/*
+ *  ValidDate()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    use CFCalendar instead.
+ *  
+ *  Discussion:
+ *    This function is no longer recommended. Please use CFCalendar
+ *    instead.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.3
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern short 
+ValidDate(
+  const LongDateRec *  vDate,
+  long                 flags,
+  LongDateTime *       newSecs)                               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3;
+
+
+/*
+ *  ReadDateTime()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    use CFAbsoluteTimeGetCurrent instead.
+ *  
+ *  Discussion:
+ *    This function is no longer recommended. Please use
+ *    CFAbsoluteTimeGetCurrent instead.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.3
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+ReadDateTime(unsigned long * datetime)                        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3;
+
+
+/*
+ *  GetDateTime()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    use CFAbsoluteTimeGetCurrent instead.
+ *  
+ *  Discussion:
+ *    This function is no longer recommended. Please use
+ *    CFAbsoluteTimeGetCurrent instead.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.3
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern void 
+GetDateTime(unsigned long * secs)                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3;
+
+
+/*
+ *  SetDateTime()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    deprecated it without replacement
+ *  
+ *  Discussion:
+ *    This function is no longer recommended.  One has to be root on
+ *    MacOSX to set. This is done through other means on OS X
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.3
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+SetDateTime(unsigned long datetime)                           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3;
+
+
+/*
+ *  SetTime()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    deprecated it without replacement
+ *  
+ *  Discussion:
+ *    This function is no longer recommended.  One has to be root on
+ *    MacOSX to set. This is done through other means on OS X
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.3
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern void 
+SetTime(const DateTimeRec * d)                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3;
+
+
+/*
+ *  GetTime()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    use CFAbsoluteTimeGetCurrent instead.
+ *  
+ *  Discussion:
+ *    This function is no longer recommended. Please use
+ *    CFAbsoluteTimeGetCurrent instead.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.3
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern void 
+GetTime(DateTimeRec * d)                                      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3;
+
+
+#endif  /* !__LP64__ */
+
+#if !__LP64__
+/*
+ *  DateToSeconds()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    use CFCalendar instead.
+ *  
+ *  Discussion:
+ *    This function is no longer recommended. Please use CFCalendar
+ *    instead.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.3
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern void 
+DateToSeconds(
+  const DateTimeRec *  d,
+  unsigned long *      secs)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3;
+
+
+#endif  /* !__LP64__ */
+
+#if !__LP64__
+/*
+ *  SecondsToDate()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    use CFCalendar instead.
+ *  
+ *  Discussion:
+ *    This function is no longer recommended. Please use CFCalendar
+ *    instead.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.3
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern void 
+SecondsToDate(
+  unsigned long   secs,
+  DateTimeRec *   d)                                          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3;
+
+
+/*
+    These routine are available in InterfaceLib using their old name.
+    Macros allow using the new names in all source code.
+    
+    @deprecated use CFDateFormatter instead.
+*/
+/*
+ *  IUDateString()   *** DEPRECATED ***
+ *  
+ *  Availability:
+ *    Mac OS X:         not available [32-bit only] but deprecated in 10.3
+ *    CarbonLib:        not available
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+
+
+/*
+ *  IUTimeString()   *** DEPRECATED ***
+ *  
+ *  Availability:
+ *    Mac OS X:         not available [32-bit only] but deprecated in 10.3
+ *    CarbonLib:        not available
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+
+
+/*
+ *  IUDatePString()   *** DEPRECATED ***
+ *  
+ *  Availability:
+ *    Mac OS X:         not available [32-bit only] but deprecated in 10.3
+ *    CarbonLib:        not available
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+
+
+/*
+ *  IUTimePString()   *** DEPRECATED ***
+ *  
+ *  Availability:
+ *    Mac OS X:         not available [32-bit only] but deprecated in 10.3
+ *    CarbonLib:        not available
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+
+
+/*
+ *  IULDateString()   *** DEPRECATED ***
+ *  
+ *  Availability:
+ *    Mac OS X:         not available [32-bit only] but deprecated in 10.3
+ *    CarbonLib:        not available
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+
+
+/*
+ *  IULTimeString()   *** DEPRECATED ***
+ *  
+ *  Availability:
+ *    Mac OS X:         not available [32-bit only] but deprecated in 10.3
+ *    CarbonLib:        not available
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+
+
+
+#endif  /* !__LP64__ */
+
+#if CALL_NOT_IN_CARBON
+#define DateString(dateTime, longFlag, result, intlHandle) \
+         IUDatePString( dateTime, longFlag, result, intlHandle)
+#define TimeString(dateTime, wantSeconds, result, intlHandle) \
+         IUTimePString(dateTime, wantSeconds, result, intlHandle)
+#define LongDateString(dateTime, longFlag, result, intlHandle) \
+         IULDateString(dateTime, longFlag, result, intlHandle)
+#define LongTimeString(dateTime, wantSeconds, result, intlHandle) \
+         IULTimeString(dateTime, wantSeconds, result, intlHandle)
+#endif /* CALL_NOT_IN_CARBON */
+#if OLDROUTINENAMES
+#define String2Date(textPtr, textLen, theCache, lengthUsed, dateTime)  \
+         StringToDate(textPtr, textLen, theCache, lengthUsed, dateTime)
+#define String2Time(textPtr, textLen, theCache, lengthUsed, dateTime)  \
+         StringToTime(textPtr, textLen, theCache, lengthUsed, dateTime)
+#define LongDate2Secs(lDate, lSecs) LongDateToSeconds(lDate, lSecs)
+#define LongSecs2Date(lSecs, lDate) LongSecondsToDate(lSecs, lDate)
+#define Date2Secs(d, secs) DateToSeconds(d, secs)
+#define Secs2Date(secs, d) SecondsToDate(secs, d)
+#endif  /* OLDROUTINENAMES */
+
+/*
+ *  iudatestring()
+ *  
+ *  Availability:
+ *    Mac OS X:         not available
+ *    CarbonLib:        not available
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+
+
+/*
+ *  iudatepstring()
+ *  
+ *  Availability:
+ *    Mac OS X:         not available
+ *    CarbonLib:        not available
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+
+
+/*
+ *  iutimestring()
+ *  
+ *  Availability:
+ *    Mac OS X:         not available
+ *    CarbonLib:        not available
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+
+
+/*
+ *  iutimepstring()
+ *  
+ *  Availability:
+ *    Mac OS X:         not available
+ *    CarbonLib:        not available
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+
+
+/*
+ *  iuldatestring()
+ *  
+ *  Availability:
+ *    Mac OS X:         not available
+ *    CarbonLib:        not available
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+
+
+/*
+ *  iultimestring()
+ *  
+ *  Availability:
+ *    Mac OS X:         not available
+ *    CarbonLib:        not available
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+
+
+#endif  /* !__LP64__ */
+
+
+
+#pragma pack(pop)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __DATETIMEUTILS__ */
+
diff -Nru ../CarbonHeaders-18.1.orig/Files.h ./Files.h
--- ../CarbonHeaders-18.1.orig/Files.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Files.h	2009-09-29 14:00:41.000000000 -0700
@@ -0,0 +1,10522 @@
+/*
+ * Copyright (c) 2007-2009 by Apple Inc.. All rights reserved.
+ *
+ * @APPLE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this
+ * file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_LICENSE_HEADER_END@
+ */
+/*
+     File:       CarbonCore/Files.h
+ 
+     Contains:   File Manager Interfaces.
+ 
+     Version:    CarbonCore-859.2~1
+ 
+     Copyright:  © 1985-2008 Apple, Inc. All rights reserved
+ 
+     Bugs?:      For bug reports, consult the following page on
+                 the World Wide Web:
+ 
+                     http://developer.apple.com/bugreporter/
+ 
+*/
+#ifndef __FILES__
+#define __FILES__
+
+#ifndef __MACTYPES__
+#include <CarbonCore/MacTypes.h>
+#endif
+
+#ifndef __MIXEDMODE__
+#include <CarbonCore/MixedMode.h>
+#endif
+
+#ifndef __OSUTILS__
+#include <CarbonCore/OSUtils.h>
+#endif
+
+#ifndef __TEXTCOMMON__
+#include <CarbonCore/TextCommon.h>
+#endif
+
+#ifndef __UTCUTILS__
+#include <CarbonCore/UTCUtils.h>
+#endif
+
+
+/* Finder constants were moved to Finder.Å */
+#ifndef __FINDER__
+#include <CarbonCore/Finder.h>
+#endif
+
+
+#ifndef __CFURL__
+#include <CoreFoundation/CFURL.h>
+#endif
+
+#ifndef __CFRUNLOOP__
+#include <CoreFoundation/CFRunLoop.h>
+#endif
+
+#ifndef __CFUUID__
+#include <CoreFoundation/CFUUID.h>
+#endif
+
+
+#include <sys/types.h>
+#include <sys/fcntl.h>
+#include <sys/acl.h>
+#include <DiskArbitration/DADisk.h>
+
+#include <AvailabilityMacros.h>
+
+#if PRAGMA_ONCE
+#pragma once
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#pragma pack(push, 2)
+
+#ifndef _HFSUNISTR255_DEFINED_
+#define _HFSUNISTR255_DEFINED_
+/* HFSUniStr255 is the Unicode equivalent of Str255 */
+struct HFSUniStr255 {
+  UInt16              length;                 /* number of unicode characters */
+  UniChar             unicode[255];           /* unicode characters */
+};
+typedef struct HFSUniStr255             HFSUniStr255;
+typedef const HFSUniStr255 *            ConstHFSUniStr255Param;
+#endif
+#define kFSFileSecurityRemoveACL (acl_t) _FILESEC_REMOVE_ACL
+/*
+    File Permissions
+
+    Do not mix and match the following two sets of constants
+    see DTS Technote FL 37 "You Want Permission To Do What?!!"
+    <http://developer.apple.com/technotes/fl/fl_37.html>
+    for a detailed discussion of the two separate models
+    and how they are related.
+*/
+/*  Permissions for File Manager routines which follow the original model */
+enum {
+  fsCurPerm                     = 0x00, /* open access permissions in ioPermssn */
+  fsRdPerm                      = 0x01,
+  fsWrPerm                      = 0x02,
+  fsRdWrPerm                    = 0x03,
+  fsRdWrShPerm                  = 0x04
+};
+
+/*    Permissions for File Manager routines which follow the AFP model
+    that is, routines with "OpenDeny" in the name.
+    
+    The most useful combinations of these are:
+        fsRdAccessPerm -> one writer, multiple readers: the readers
+        fsRdAccessPerm + fsWrAccessPerm + fsWrDenyPerm -> one writer, multiple readers: the writer
+        fsWrDenyPerm + fsRdAccessPerm -> multiple readers, no writers
+        fsRdAccessPerm + fsWrAccessPerm -> shared read/write access
+        fsRdAccessPerm + fsWrAccessPerm + fsRdDenyPerm + fsWrDenyPerm -> exclusive access
+*/
+enum {
+  fsRdAccessPerm                = 0x01,
+  fsWrAccessPerm                = 0x02,
+  fsRdDenyPerm                  = 0x10,
+  fsWrDenyPerm                  = 0x20
+};
+
+enum {
+  fsRtParID                     = 1,
+  fsRtDirID                     = 2
+};
+
+enum {
+  fsAtMark                      = 0,    /* positioning modes in ioPosMode */
+  fsFromStart                   = 1,
+  fsFromLEOF                    = 2,
+  fsFromMark                    = 3
+};
+
+enum {
+                                        /* positionMode (ioPosMode) flags */
+  kFSAllowConcurrentAsyncIOBit  = 3,    /* allow concurrent execution of async calls */
+  kFSAllowConcurrentAsyncIOMask = 0x0008,
+  kFSPleaseCacheBit             = 4,    /* please cache this request */
+  kFSPleaseCacheMask            = 0x0010,
+  kFSNoCacheBit                 = 5,    /* please don't cache this request */
+  kFSNoCacheMask                = 0x0020,
+  kFSRdVerifyBit                = 6,    /* read verify mode */
+  kFSRdVerifyMask               = 0x0040,
+  kFSForceReadBit               = 6,
+  kFSForceReadMask              = 0x0040,
+  kFSNewLineBit                 = 7,    /* newline mode */
+  kFSNewLineMask                = 0x0080,
+  kFSNewLineCharMask            = 0xFF00 /* newline character */
+};
+
+
+enum {
+                                        /* CatSearch Search bitmask Constants */
+  fsSBPartialName               = 0x01,
+  fsSBFullName                  = 0x02,
+  fsSBFlAttrib                  = 0x04,
+  fsSBFlFndrInfo                = 0x08,
+  fsSBFlLgLen                   = 0x20,
+  fsSBFlPyLen                   = 0x40,
+  fsSBFlRLgLen                  = 0x80,
+  fsSBFlRPyLen                  = 0x0100,
+  fsSBFlCrDat                   = 0x0200,
+  fsSBFlMdDat                   = 0x0400,
+  fsSBFlBkDat                   = 0x0800,
+  fsSBFlXFndrInfo               = 0x1000,
+  fsSBFlParID                   = 0x2000,
+  fsSBNegate                    = 0x4000,
+  fsSBDrUsrWds                  = 0x08,
+  fsSBDrNmFls                   = 0x10,
+  fsSBDrCrDat                   = 0x0200,
+  fsSBDrMdDat                   = 0x0400,
+  fsSBDrBkDat                   = 0x0800,
+  fsSBDrFndrInfo                = 0x1000,
+  fsSBDrParID                   = 0x2000,
+  fsSBNodeID                    = 0x8000,
+  fsSBAttributeModDate          = 0x00010000,
+  fsSBAccessDate                = 0x00020000,
+  fsSBPermissions               = 0x00040000,
+  fsSBSkipPackageContents       = 0x00080000,
+  fsSBSkipHiddenItems           = 0x00100000,
+  fsSBUserID                    = 0x00200000,
+  fsSBGroupID                   = 0x00400000
+};
+
+enum {
+                                        /* CatSearch Search bit value Constants */
+  fsSBPartialNameBit            = 0,    /*ioFileName points to a substring*/
+  fsSBFullNameBit               = 1,    /*ioFileName points to a match string*/
+  fsSBFlAttribBit               = 2,    /*search includes file attributes*/
+  fsSBFlFndrInfoBit             = 3,    /*search includes finder info*/
+  fsSBFlLgLenBit                = 5,    /*search includes data logical length*/
+  fsSBFlPyLenBit                = 6,    /*search includes data physical length*/
+  fsSBFlRLgLenBit               = 7,    /*search includes resource logical length*/
+  fsSBFlRPyLenBit               = 8,    /*search includes resource physical length*/
+  fsSBFlCrDatBit                = 9,    /*search includes create date*/
+  fsSBFlMdDatBit                = 10,   /*search includes modification date*/
+  fsSBFlBkDatBit                = 11,   /*search includes backup date*/
+  fsSBFlXFndrInfoBit            = 12,   /*search includes extended finder info*/
+  fsSBFlParIDBit                = 13,   /*search includes file's parent ID*/
+  fsSBNegateBit                 = 14,   /*return all non-matches*/
+  fsSBDrUsrWdsBit               = 3,    /*search includes directory finder info*/
+  fsSBDrNmFlsBit                = 4,    /*search includes directory valence*/
+  fsSBDrCrDatBit                = 9,    /*directory-named version of fsSBFlCrDatBit*/
+  fsSBDrMdDatBit                = 10,   /*directory-named version of fsSBFlMdDatBit*/
+  fsSBDrBkDatBit                = 11,   /*directory-named version of fsSBFlBkDatBit*/
+  fsSBDrFndrInfoBit             = 12,   /*directory-named version of fsSBFlXFndrInfoBit*/
+  fsSBDrParIDBit                = 13,   /*directory-named version of fsSBFlParIDBit*/
+  fsSBNodeIDBit                 = 15,   /* search by range of nodeID */
+  fsSBAttributeModDateBit       = 16,   /* search by range of attributeModDate */
+  fsSBAccessDateBit             = 17,   /* search by range of accessDate [CatalogSearch only] */
+  fsSBPermissionsBit            = 18,   /* search by value/mask of permissions [CatalogSearch only] */
+  fsSBSkipPackageContentsBit    = 19,   /*do not return items inside of packages*/
+  fsSBSkipHiddenItemsBit        = 20,   /*do not return items with an invisible element in their path*/
+  fsSBUserIDBit                 = 21,   /* search by userID in permissions field [CatalogSearch only] */
+  fsSBGroupIDBit                = 22    /* search by groupID in permissions field [CatalogSearch only] */
+};
+
+enum {
+                                        /* vMAttrib (GetVolParms) bit position constants */
+  bLimitFCBs                    = 31,
+  bLocalWList                   = 30,
+  bNoMiniFndr                   = 29,
+  bNoVNEdit                     = 28,
+  bNoLclSync                    = 27,
+  bTrshOffLine                  = 26,
+  bNoSwitchTo                   = 25,
+  bNoDeskItems                  = 20,
+  bNoBootBlks                   = 19,
+  bAccessCntl                   = 18,
+  bNoSysDir                     = 17,
+  bHasExtFSVol                  = 16,
+  bHasOpenDeny                  = 15,
+  bHasCopyFile                  = 14,
+  bHasMoveRename                = 13,
+  bHasDesktopMgr                = 12,
+  bHasShortName                 = 11,
+  bHasFolderLock                = 10,
+  bHasPersonalAccessPrivileges  = 9,
+  bHasUserGroupList             = 8,
+  bHasCatSearch                 = 7,
+  bHasFileIDs                   = 6,
+  bHasBTreeMgr                  = 5,
+  bHasBlankAccessPrivileges     = 4,
+  bSupportsAsyncRequests        = 3,    /* asynchronous requests to this volume are handled correctly at any time*/
+  bSupportsTrashVolumeCache     = 2
+};
+
+enum {
+                                        /* vMAttrib (GetVolParms) bit position constants */
+  bHasDirectIO                  = 1
+};
+
+enum {
+                                        /* vMExtendedAttributes (GetVolParms) bit position constants */
+  bIsEjectable                  = 0,    /* volume is in an ejectable disk drive */
+  bSupportsHFSPlusAPIs          = 1,    /* volume supports HFS Plus APIs directly (not through compatibility layer) */
+  bSupportsFSCatalogSearch      = 2,    /* volume supports FSCatalogSearch */
+  bSupportsFSExchangeObjects    = 3,    /* volume supports FSExchangeObjects */
+  bSupports2TBFiles             = 4,    /* volume supports supports 2 terabyte files */
+  bSupportsLongNames            = 5,    /* volume supports file/directory/volume names longer than 31 characters */
+  bSupportsMultiScriptNames     = 6,    /* volume supports file/directory/volume names with characters from multiple script systems */
+  bSupportsNamedForks           = 7,    /* volume supports forks beyond the data and resource forks */
+  bSupportsSubtreeIterators     = 8,    /* volume supports recursive iterators not at the volume root */
+  bL2PCanMapFileBlocks          = 9,    /* volume supports Lg2Phys SPI correctly */
+  bParentModDateChanges         = 10,   /* Changing a file or folder causes its parent's mod date to change */
+  bAncestorModDateChanges       = 11,   /* Changing a file or folder causes all ancestor mod dates to change */
+  bSupportsSymbolicLinks        = 13,   /* volume supports the creation and use of symbolic links (Mac OS X only) */
+  bIsAutoMounted                = 14,   /* volume was mounted automatically (Mac OS X only) */
+  bAllowCDiDataHandler          = 17,   /* allow QuickTime's CDi data handler to examine this volume */
+  bSupportsExclusiveLocks       = 18,   /* volume supports exclusive opens for writing */
+  bSupportsJournaling           = 19,   /* volume supports journal (journal may not be active) */
+  bNoVolumeSizes                = 20,   /* volume is unable to report volume size or free space */
+  bIsOnInternalBus              = 21,   /* device is on an internal bus - see note below */
+  bIsCaseSensitive              = 22,   /* volume is case sensitive */
+  bIsCasePreserving             = 23,   /* volume is case preserving */
+  bDoNotDisplay                 = 24,   /* volume should not be displayed in UI */
+  bIsRemovable                  = 25,   /* device is removable according to IOKit */
+  bNoRootTimes                  = 26,   /* volume does not set reliable times for its root directory */
+  bIsOnExternalBus              = 27,   /* device is on an external bus -- see note below */
+  bSupportsExtendedFileSecurity = 28    /* volume supports FSFileSecurity objects */
+};
+
+/*    Note: A volume can return one of four states via the bIsInternal and bIsExternal bits.  A volume known
+        to be on an internal bus will set bIsInternal and clear bIsExternal.  A volume known to
+        be on an external bus will clear bIsInternal and set bIsExternal.  A volume on a bus that
+        is indeterminate (could be either) will set both bits.  A volume not on a local bus will, such
+        as a network volume, will leave both bits clear. */
+enum {
+                                        /* Large Volume Constants */
+  kWidePosOffsetBit             = 8,
+  kUseWidePositioning           = (1 << kWidePosOffsetBit),
+  kMaximumBlocksIn4GB           = 0x007FFFFF
+};
+
+enum {
+                                        /* Foreign Privilege Model Identifiers */
+  fsUnixPriv                    = 1
+};
+
+enum {
+                                        /* Authentication Constants */
+  kNoUserAuthentication         = 1,
+  kPassword                     = 2,
+  kEncryptPassword              = 3,
+  kTwoWayEncryptPassword        = 6
+};
+
+
+/* values of user IDs and group IDs */
+enum {
+  knoUser                       = 0,
+  kadministratorUser            = 1
+};
+
+enum {
+  knoGroup                      = 0
+};
+
+
+typedef SInt16                          FSVolumeRefNum;
+#if __LP64__
+typedef int                             FSIORefNum;
+#else
+typedef SInt16                          FSIORefNum;
+#endif  /* __LP64__ */
+
+enum {
+  kFSInvalidVolumeRefNum        = 0
+};
+
+struct FSRef {
+  UInt8               hidden[80];             /* private to File Manager; ¥¥ need symbolic constant */
+};
+typedef struct FSRef                    FSRef;
+typedef FSRef *                         FSRefPtr;
+typedef struct __FSFileSecurity*        FSFileSecurityRef;
+/* Catalog position record */
+struct CatPositionRec {
+  SInt32              initialize;
+  SInt16              priv[6];
+};
+typedef struct CatPositionRec           CatPositionRec;
+#if __LP64__
+struct FSSpec {
+  UInt8               hidden[70];             /* FSSpecs are invalid for 64 bit, but defined in case they appear in shared structs*/
+};
+typedef struct FSSpec                   FSSpec;
+#else
+struct FSSpec {
+  FSVolumeRefNum      vRefNum;
+  SInt32              parID;
+  StrFileName         name;                   /* a Str63 on MacOS*/
+};
+typedef struct FSSpec                   FSSpec;
+#endif  /* __LP64__ */
+
+typedef FSSpec *                        FSSpecPtr;
+typedef FSSpecPtr *                     FSSpecHandle;
+/* pointer to array of FSSpecs */
+typedef FSSpecPtr                       FSSpecArrayPtr;
+/* 
+    The only difference between "const FSSpec*" and "ConstFSSpecPtr" is 
+    that as a parameter, ConstFSSpecPtr is allowed to be NULL 
+*/
+typedef const FSSpec *                  ConstFSSpecPtr;
+typedef union ParamBlockRec             ParamBlockRec;
+#if __LP64__
+typedef void *                          ParmBlkPtr;
+#else
+typedef ParamBlockRec *                 ParmBlkPtr;
+#endif  /* __LP64__ */
+
+typedef CALLBACK_API( void , IOCompletionProcPtr )(ParmBlkPtr paramBlock);
+typedef STACK_UPP_TYPE(IOCompletionProcPtr)                     IOCompletionUPP;
+#if !__LP64__
+struct IOParam {
+  QElemPtr            qLink;                  /*queue link in header*/
+  SInt16              qType;                  /*type byte for safety check*/
+  SInt16              ioTrap;                 /*FS: the Trap*/
+  Ptr                 ioCmdAddr;              /*FS: address to dispatch to*/
+  IOCompletionUPP     ioCompletion;           /*completion routine addr (0 for synch calls)*/
+  volatile OSErr      ioResult;               /*result code*/
+  StringPtr           ioNamePtr;              /*ptr to Vol:FileName string*/
+  FSVolumeRefNum      ioVRefNum;              /*volume refnum (DrvNum for Eject and MountVol)*/
+  FSIORefNum          ioRefNum;               /*refNum for I/O operation*/
+  SInt8               ioVersNum;              /*version number*/
+  SInt8               ioPermssn;              /*Open: permissions (byte)*/
+  Ptr                 ioMisc;                 /*Rename: new name (GetEOF,SetEOF: logical end of file) (Open: optional ptr to buffer) (SetFileType: new type)*/
+  Ptr                 ioBuffer;               /*data buffer Ptr*/
+  SInt32              ioReqCount;             /*requested byte count; also = ioNewDirID*/
+  SInt32              ioActCount;             /*actual byte count completed*/
+  SInt16              ioPosMode;              /*initial file positioning*/
+  SInt32              ioPosOffset;            /*file position offset*/
+};
+typedef struct IOParam                  IOParam;
+typedef IOParam *                       IOParamPtr;
+struct FileParam {
+  QElemPtr            qLink;                  /*queue link in header*/
+  SInt16              qType;                  /*type byte for safety check*/
+  SInt16              ioTrap;                 /*FS: the Trap*/
+  Ptr                 ioCmdAddr;              /*FS: address to dispatch to*/
+  IOCompletionUPP     ioCompletion;           /*completion routine addr (0 for synch calls)*/
+  volatile OSErr      ioResult;               /*result code*/
+  StringPtr           ioNamePtr;              /*ptr to Vol:FileName string*/
+  FSVolumeRefNum      ioVRefNum;              /*volume refnum (DrvNum for Eject and MountVol)*/
+  FSIORefNum          ioFRefNum;              /*reference number*/
+  SInt8               ioFVersNum;             /*version number*/
+  SInt8               filler1;
+  SInt16              ioFDirIndex;            /*GetFInfo directory index*/
+  SInt8               ioFlAttrib;             /*GetFInfo: in-use bit=7, lock bit=0*/
+  SInt8               ioFlVersNum;            /*file version number*/
+  FInfo               ioFlFndrInfo;           /*user info*/
+  UInt32              ioFlNum;                /*GetFInfo: file number; TF- ioDirID*/
+  UInt16              ioFlStBlk;              /*start file block (0 if none)*/
+  SInt32              ioFlLgLen;              /*logical length (EOF)*/
+  SInt32              ioFlPyLen;              /*physical length*/
+  UInt16              ioFlRStBlk;             /*start block rsrc fork*/
+  SInt32              ioFlRLgLen;             /*file logical length rsrc fork*/
+  SInt32              ioFlRPyLen;             /*file physical length rsrc fork*/
+  UInt32              ioFlCrDat;              /*file creation date& time (32 bits in secs)*/
+  UInt32              ioFlMdDat;              /*last modified date and time*/
+};
+typedef struct FileParam                FileParam;
+typedef FileParam *                     FileParamPtr;
+struct VolumeParam {
+  QElemPtr            qLink;                  /*queue link in header*/
+  SInt16              qType;                  /*type byte for safety check*/
+  SInt16              ioTrap;                 /*FS: the Trap*/
+  Ptr                 ioCmdAddr;              /*FS: address to dispatch to*/
+  IOCompletionUPP     ioCompletion;           /*completion routine addr (0 for synch calls)*/
+  volatile OSErr      ioResult;               /*result code*/
+  StringPtr           ioNamePtr;              /*ptr to Vol:FileName string*/
+  FSVolumeRefNum      ioVRefNum;              /*volume refnum (DrvNum for Eject and MountVol)*/
+  UInt32              filler2;
+  SInt16              ioVolIndex;             /*volume index number*/
+  UInt32              ioVCrDate;              /*creation date and time*/
+  UInt32              ioVLsBkUp;              /*last backup date and time*/
+  UInt16              ioVAtrb;                /*volume attrib*/
+  UInt16              ioVNmFls;               /*number of files in directory*/
+  UInt16              ioVDirSt;               /*start block of file directory*/
+  SInt16              ioVBlLn;                /*GetVolInfo: length of dir in blocks*/
+  UInt16              ioVNmAlBlks;            /*for compatibilty ioVNmAlBlks * ioVAlBlkSiz <= 2 GB*/
+  UInt32              ioVAlBlkSiz;            /*for compatibilty ioVAlBlkSiz is <= $0000FE00 (65,024)*/
+  UInt32              ioVClpSiz;              /*GetVolInfo: bytes to allocate at a time*/
+  UInt16              ioAlBlSt;               /*starting disk(512-byte) block in block map*/
+  UInt32              ioVNxtFNum;             /*GetVolInfo: next free file number*/
+  UInt16              ioVFrBlk;               /*GetVolInfo: # free alloc blks for this vol*/
+};
+typedef struct VolumeParam              VolumeParam;
+typedef VolumeParam *                   VolumeParamPtr;
+struct CntrlParam {
+  QElemPtr            qLink;                  /*queue link in header*/
+  SInt16              qType;                  /*type byte for safety check*/
+  SInt16              ioTrap;                 /*FS: the Trap*/
+  Ptr                 ioCmdAddr;              /*FS: address to dispatch to*/
+  IOCompletionUPP     ioCompletion;           /*completion routine addr (0 for synch calls)*/
+  volatile OSErr      ioResult;               /*result code*/
+  StringPtr           ioNamePtr;              /*ptr to Vol:FileName string*/
+  FSVolumeRefNum      ioVRefNum;              /*volume refnum (DrvNum for Eject and MountVol)*/
+  FSIORefNum          ioCRefNum;              /*refNum for I/O operation*/
+  SInt16              csCode;                 /*word for control status code*/
+  SInt16              csParam[11];            /*operation-defined parameters*/
+};
+typedef struct CntrlParam               CntrlParam;
+typedef CntrlParam *                    CntrlParamPtr;
+struct SlotDevParam {
+  QElemPtr            qLink;                  /*queue link in header*/
+  SInt16              qType;                  /*type byte for safety check*/
+  SInt16              ioTrap;                 /*FS: the Trap*/
+  Ptr                 ioCmdAddr;              /*FS: address to dispatch to*/
+  IOCompletionUPP     ioCompletion;           /*completion routine addr (0 for synch calls)*/
+  volatile OSErr      ioResult;               /*result code*/
+  StringPtr           ioNamePtr;              /*ptr to Vol:FileName string*/
+  FSVolumeRefNum      ioVRefNum;              /*volume refnum (DrvNum for Eject and MountVol)*/
+  FSIORefNum          ioSRefNum;
+  SInt8               ioSVersNum;
+  SInt8               ioSPermssn;
+  Ptr                 ioSMix;
+  SInt16              ioSFlags;
+  SInt8               ioSlot;
+  SInt8               ioID;
+};
+typedef struct SlotDevParam             SlotDevParam;
+typedef SlotDevParam *                  SlotDevParamPtr;
+struct MultiDevParam {
+  QElemPtr            qLink;                  /*queue link in header*/
+  SInt16              qType;                  /*type byte for safety check*/
+  SInt16              ioTrap;                 /*FS: the Trap*/
+  Ptr                 ioCmdAddr;              /*FS: address to dispatch to*/
+  IOCompletionUPP     ioCompletion;           /*completion routine addr (0 for synch calls)*/
+  volatile OSErr      ioResult;               /*result code*/
+  StringPtr           ioNamePtr;              /*ptr to Vol:FileName string*/
+  FSVolumeRefNum      ioVRefNum;              /*volume refnum (DrvNum for Eject and MountVol)*/
+  FSIORefNum          ioMRefNum;
+  SInt8               ioMVersNum;
+  SInt8               ioMPermssn;
+  Ptr                 ioMMix;
+  SInt16              ioMFlags;
+  Ptr                 ioSEBlkPtr;
+};
+typedef struct MultiDevParam            MultiDevParam;
+typedef MultiDevParam *                 MultiDevParamPtr;
+union ParamBlockRec {
+  IOParam             ioParam;
+  FileParam           fileParam;
+  VolumeParam         volumeParam;
+  CntrlParam          cntrlParam;
+  SlotDevParam        slotDevParam;
+  MultiDevParam       multiDevParam;
+};
+
+struct HFileInfo {
+  QElemPtr            qLink;                  /*queue link in header*/
+  SInt16              qType;                  /*type byte for safety check*/
+  SInt16              ioTrap;                 /*FS: the Trap*/
+  Ptr                 ioCmdAddr;              /*FS: address to dispatch to*/
+  IOCompletionUPP     ioCompletion;           /*completion routine addr (0 for synch calls)*/
+  volatile OSErr      ioResult;               /*result code*/
+  StringPtr           ioNamePtr;              /*ptr to Vol:FileName string*/
+  FSVolumeRefNum      ioVRefNum;              /*volume refnum (DrvNum for Eject and MountVol)*/
+  FSIORefNum          ioFRefNum;
+  SInt8               ioFVersNum;
+  SInt8               filler1;
+  SInt16              ioFDirIndex;
+  SInt8               ioFlAttrib;
+  SInt8               ioACUser;
+  FInfo               ioFlFndrInfo;
+  SInt32              ioDirID;
+  UInt16              ioFlStBlk;
+  SInt32              ioFlLgLen;
+  SInt32              ioFlPyLen;
+  UInt16              ioFlRStBlk;
+  SInt32              ioFlRLgLen;
+  SInt32              ioFlRPyLen;
+  UInt32              ioFlCrDat;
+  UInt32              ioFlMdDat;
+  UInt32              ioFlBkDat;
+  FXInfo              ioFlXFndrInfo;
+  SInt32              ioFlParID;
+  SInt32              ioFlClpSiz;
+};
+typedef struct HFileInfo                HFileInfo;
+struct DirInfo {
+  QElemPtr            qLink;                  /*queue link in header*/
+  SInt16              qType;                  /*type byte for safety check*/
+  SInt16              ioTrap;                 /*FS: the Trap*/
+  Ptr                 ioCmdAddr;              /*FS: address to dispatch to*/
+  IOCompletionUPP     ioCompletion;           /*completion routine addr (0 for synch calls)*/
+  volatile OSErr      ioResult;               /*result code*/
+  StringPtr           ioNamePtr;              /*ptr to Vol:FileName string*/
+  FSVolumeRefNum      ioVRefNum;              /*volume refnum (DrvNum for Eject and MountVol)*/
+  FSIORefNum          ioFRefNum;
+  SInt8               ioFVersNum;
+  SInt8               filler1;
+  SInt16              ioFDirIndex;
+  SInt8               ioFlAttrib;
+  SInt8               ioACUser;
+  DInfo               ioDrUsrWds;
+  SInt32              ioDrDirID;
+  UInt16              ioDrNmFls;
+  SInt16              filler3[9];
+  UInt32              ioDrCrDat;
+  UInt32              ioDrMdDat;
+  UInt32              ioDrBkDat;
+  DXInfo              ioDrFndrInfo;
+  SInt32              ioDrParID;
+};
+typedef struct DirInfo                  DirInfo;
+union CInfoPBRec {
+  HFileInfo           hFileInfo;
+  DirInfo             dirInfo;
+};
+typedef union CInfoPBRec                CInfoPBRec;
+typedef CInfoPBRec *                    CInfoPBPtr;
+struct XCInfoPBRec {
+  QElemPtr            qLink;
+  SInt16              qType;
+  SInt16              ioTrap;
+  Ptr                 ioCmdAddr;
+  ProcPtr             ioCompletion;           /* --> A pointer to a completion routine */
+  volatile OSErr      ioResult;               /* --> The result code of the function */
+  StringPtr           ioNamePtr;              /* --> Pointer to pathname to object */
+  FSVolumeRefNum      ioVRefNum;              /* --> A volume specification */
+  SInt32              filler1;
+  StringPtr           ioShortNamePtr;         /* <-> A pointer to the short name string buffer - required! */
+  SInt16              filler2;
+  SInt16              ioPDType;               /* <-- The ProDOS file type */
+  SInt32              ioPDAuxType;            /* <-- The ProDOS aux type */
+  SInt32              filler3[2];
+  SInt32              ioDirID;                /* --> A directory ID */
+};
+typedef struct XCInfoPBRec              XCInfoPBRec;
+typedef XCInfoPBRec *                   XCInfoPBPtr;
+struct DTPBRec {
+  QElemPtr            qLink;                  /*queue link in header*/
+  SInt16              qType;                  /*type byte for safety check*/
+  SInt16              ioTrap;                 /*FS: the Trap*/
+  Ptr                 ioCmdAddr;              /*FS: address to dispatch to*/
+  IOCompletionUPP     ioCompletion;           /*completion routine addr (0 for synch calls)*/
+  volatile OSErr      ioResult;               /*result code*/
+  StringPtr           ioNamePtr;              /*ptr to Vol:FileName string*/
+  FSVolumeRefNum      ioVRefNum;              /*volume refnum (DrvNum for Eject and MountVol)*/
+  FSIORefNum          ioDTRefNum;             /* desktop refnum */
+  SInt16              ioIndex;
+  SInt32              ioTagInfo;
+  Ptr                 ioDTBuffer;
+  SInt32              ioDTReqCount;
+  SInt32              ioDTActCount;
+  SInt8               ioFiller1;
+  UInt8               ioIconType;
+  SInt16              ioFiller2;
+  SInt32              ioDirID;
+  OSType              ioFileCreator;
+  OSType              ioFileType;
+  SInt32              ioFiller3;
+  SInt32              ioDTLgLen;
+  SInt32              ioDTPyLen;
+  SInt16              ioFiller4[14];
+  SInt32              ioAPPLParID;
+};
+typedef struct DTPBRec                  DTPBRec;
+typedef DTPBRec *                       DTPBPtr;
+
+struct HIOParam {
+  QElemPtr            qLink;                  /*queue link in header*/
+  SInt16              qType;                  /*type byte for safety check*/
+  SInt16              ioTrap;                 /*FS: the Trap*/
+  Ptr                 ioCmdAddr;              /*FS: address to dispatch to*/
+  IOCompletionUPP     ioCompletion;           /*completion routine addr (0 for synch calls)*/
+  volatile OSErr      ioResult;               /*result code*/
+  StringPtr           ioNamePtr;              /*ptr to Vol:FileName string*/
+  FSVolumeRefNum      ioVRefNum;              /*volume refnum (DrvNum for Eject and MountVol)*/
+  FSIORefNum          ioRefNum;
+  SInt8               ioVersNum;
+  SInt8               ioPermssn;
+  Ptr                 ioMisc;
+  Ptr                 ioBuffer;
+  SInt32              ioReqCount;
+  SInt32              ioActCount;
+  SInt16              ioPosMode;
+  SInt32              ioPosOffset;
+};
+typedef struct HIOParam                 HIOParam;
+typedef HIOParam *                      HIOParamPtr;
+struct HFileParam {
+  QElemPtr            qLink;                  /*queue link in header*/
+  SInt16              qType;                  /*type byte for safety check*/
+  SInt16              ioTrap;                 /*FS: the Trap*/
+  Ptr                 ioCmdAddr;              /*FS: address to dispatch to*/
+  IOCompletionUPP     ioCompletion;           /*completion routine addr (0 for synch calls)*/
+  volatile OSErr      ioResult;               /*result code*/
+  StringPtr           ioNamePtr;              /*ptr to Vol:FileName string*/
+  FSVolumeRefNum      ioVRefNum;              /*volume refnum (DrvNum for Eject and MountVol)*/
+  FSIORefNum          ioFRefNum;
+  SInt8               ioFVersNum;
+  SInt8               filler1;
+  SInt16              ioFDirIndex;
+  SInt8               ioFlAttrib;
+  SInt8               ioFlVersNum;
+  FInfo               ioFlFndrInfo;
+  SInt32              ioDirID;
+  UInt16              ioFlStBlk;
+  SInt32              ioFlLgLen;
+  SInt32              ioFlPyLen;
+  UInt16              ioFlRStBlk;
+  SInt32              ioFlRLgLen;
+  SInt32              ioFlRPyLen;
+  UInt32              ioFlCrDat;
+  UInt32              ioFlMdDat;
+};
+typedef struct HFileParam               HFileParam;
+typedef HFileParam *                    HFileParamPtr;
+struct HVolumeParam {
+  QElemPtr            qLink;                  /*queue link in header*/
+  SInt16              qType;                  /*type byte for safety check*/
+  SInt16              ioTrap;                 /*FS: the Trap*/
+  Ptr                 ioCmdAddr;              /*FS: address to dispatch to*/
+  IOCompletionUPP     ioCompletion;           /*completion routine addr (0 for synch calls)*/
+  volatile OSErr      ioResult;               /*result code*/
+  StringPtr           ioNamePtr;              /*ptr to Vol:FileName string*/
+  FSVolumeRefNum      ioVRefNum;              /*volume refnum (DrvNum for Eject and MountVol)*/
+  SInt32              filler2;
+  SInt16              ioVolIndex;
+  UInt32              ioVCrDate;
+  UInt32              ioVLsMod;
+  SInt16              ioVAtrb;
+  UInt16              ioVNmFls;
+  UInt16              ioVBitMap;
+  UInt16              ioAllocPtr;
+  UInt16              ioVNmAlBlks;
+  UInt32              ioVAlBlkSiz;
+  UInt32              ioVClpSiz;
+  UInt16              ioAlBlSt;
+  UInt32              ioVNxtCNID;
+  UInt16              ioVFrBlk;
+  UInt16              ioVSigWord;
+  SInt16              ioVDrvInfo;
+  FSIORefNum          ioVDRefNum;
+  SInt16              ioVFSID;
+  UInt32              ioVBkUp;
+  SInt16              ioVSeqNum;
+  UInt32              ioVWrCnt;
+  UInt32              ioVFilCnt;
+  UInt32              ioVDirCnt;
+  SInt32              ioVFndrInfo[8];
+};
+typedef struct HVolumeParam             HVolumeParam;
+typedef HVolumeParam *                  HVolumeParamPtr;
+struct XIOParam {
+  QElemPtr            qLink;                  /*queue link in header*/
+  SInt16              qType;                  /*type byte for safety check*/
+  SInt16              ioTrap;                 /*FS: the Trap*/
+  Ptr                 ioCmdAddr;              /*FS: address to dispatch to*/
+  IOCompletionUPP     ioCompletion;           /*completion routine addr (0 for synch calls)*/
+  volatile OSErr      ioResult;               /*result code*/
+  StringPtr           ioNamePtr;              /*ptr to Vol:FileName string*/
+  FSVolumeRefNum      ioVRefNum;              /*volume refnum (DrvNum for Eject and MountVol)*/
+  FSIORefNum          ioRefNum;
+  SInt8               ioVersNum;
+  SInt8               ioPermssn;
+  Ptr                 ioMisc;
+  Ptr                 ioBuffer;
+  SInt32              ioReqCount;
+  SInt32              ioActCount;
+  SInt16              ioPosMode;              /* must have kUseWidePositioning bit set */
+  wide                ioWPosOffset;           /* wide positioning offset */
+};
+typedef struct XIOParam                 XIOParam;
+typedef XIOParam *                      XIOParamPtr;
+struct XVolumeParam {
+  QElemPtr            qLink;                  /*queue link in header*/
+  SInt16              qType;                  /*type byte for safety check*/
+  SInt16              ioTrap;                 /*FS: the Trap*/
+  Ptr                 ioCmdAddr;              /*FS: address to dispatch to*/
+  IOCompletionUPP     ioCompletion;           /*completion routine addr (0 for synch calls)*/
+  volatile OSErr      ioResult;               /*result code*/
+  StringPtr           ioNamePtr;              /*ptr to Vol:FileName string*/
+  FSVolumeRefNum      ioVRefNum;              /*volume refnum (DrvNum for Eject and MountVol)*/
+  UInt32              ioXVersion;             /* this XVolumeParam version (0) */
+  SInt16              ioVolIndex;
+  UInt32              ioVCrDate;
+  UInt32              ioVLsMod;
+  SInt16              ioVAtrb;
+  UInt16              ioVNmFls;
+  UInt16              ioVBitMap;
+  UInt16              ioAllocPtr;
+  UInt16              ioVNmAlBlks;
+  UInt32              ioVAlBlkSiz;
+  UInt32              ioVClpSiz;
+  UInt16              ioAlBlSt;
+  UInt32              ioVNxtCNID;
+  UInt16              ioVFrBlk;
+  UInt16              ioVSigWord;
+  SInt16              ioVDrvInfo;
+  SInt16              ioVDRefNum;
+  SInt16              ioVFSID;
+  UInt32              ioVBkUp;
+  SInt16              ioVSeqNum;
+  UInt32              ioVWrCnt;
+  UInt32              ioVFilCnt;
+  UInt32              ioVDirCnt;
+  SInt32              ioVFndrInfo[8];
+  UInt64              ioVTotalBytes;          /* total number of bytes on volume */
+  UInt64              ioVFreeBytes;           /* number of free bytes on volume */
+};
+typedef struct XVolumeParam             XVolumeParam;
+typedef XVolumeParam *                  XVolumeParamPtr;
+struct AccessParam {
+  QElemPtr            qLink;                  /*queue link in header*/
+  SInt16              qType;                  /*type byte for safety check*/
+  SInt16              ioTrap;                 /*FS: the Trap*/
+  Ptr                 ioCmdAddr;              /*FS: address to dispatch to*/
+  IOCompletionUPP     ioCompletion;           /*completion routine addr (0 for synch calls)*/
+  volatile OSErr      ioResult;               /*result code*/
+  StringPtr           ioNamePtr;              /*ptr to Vol:FileName string*/
+  FSVolumeRefNum      ioVRefNum;              /*volume refnum (DrvNum for Eject and MountVol)*/
+  FSIORefNum          ioRefNum;               /* <- , ioRefNum ( use to be filler3 ) */
+  SInt16              ioDenyModes;            /*access rights data*/
+  SInt16              filler4;
+  SInt8               filler5;
+  SInt8               ioACUser;               /*access rights for directory only*/
+  SInt32              filler6;
+  SInt32              ioACOwnerID;            /*owner ID*/
+  SInt32              ioACGroupID;            /*group ID*/
+  SInt32              ioACAccess;             /*access rights*/
+  SInt32              ioDirID;
+};
+typedef struct AccessParam              AccessParam;
+typedef AccessParam *                   AccessParamPtr;
+struct ObjParam {
+  QElemPtr            qLink;                  /*queue link in header*/
+  SInt16              qType;                  /*type byte for safety check*/
+  SInt16              ioTrap;                 /*FS: the Trap*/
+  Ptr                 ioCmdAddr;              /*FS: address to dispatch to*/
+  IOCompletionUPP     ioCompletion;           /*completion routine addr (0 for synch calls)*/
+  volatile OSErr      ioResult;               /*result code*/
+  StringPtr           ioNamePtr;              /*ptr to Vol:FileName string*/
+  FSVolumeRefNum      ioVRefNum;              /*volume refnum (DrvNum for Eject and MountVol)*/
+  SInt16              filler7;
+  SInt16              ioObjType;              /*function code*/
+  StringPtr           ioObjNamePtr;           /*ptr to returned creator/group name*/
+  SInt32              ioObjID;                /*creator/group ID*/
+};
+typedef struct ObjParam                 ObjParam;
+typedef ObjParam *                      ObjParamPtr;
+struct CopyParam {
+  QElemPtr            qLink;                  /*queue link in header*/
+  SInt16              qType;                  /*type byte for safety check*/
+  SInt16              ioTrap;                 /*FS: the Trap*/
+  Ptr                 ioCmdAddr;              /*FS: address to dispatch to*/
+  IOCompletionUPP     ioCompletion;           /*completion routine addr (0 for synch calls)*/
+  volatile OSErr      ioResult;               /*result code*/
+  StringPtr           ioNamePtr;              /*ptr to Vol:FileName string*/
+  FSVolumeRefNum      ioVRefNum;              /*volume refnum (DrvNum for Eject and MountVol)*/
+  FSVolumeRefNum      ioDstVRefNum;           /*destination vol identifier*/
+  SInt16              filler8;
+  StringPtr           ioNewName;              /*ptr to destination pathname*/
+  StringPtr           ioCopyName;             /*ptr to optional name*/
+  SInt32              ioNewDirID;             /*destination directory ID*/
+  SInt32              filler14;
+  SInt32              filler15;
+  SInt32              ioDirID;
+};
+typedef struct CopyParam                CopyParam;
+typedef CopyParam *                     CopyParamPtr;
+struct WDParam {
+  QElemPtr            qLink;                  /*queue link in header*/
+  SInt16              qType;                  /*type byte for safety check*/
+  SInt16              ioTrap;                 /*FS: the Trap*/
+  Ptr                 ioCmdAddr;              /*FS: address to dispatch to*/
+  IOCompletionUPP     ioCompletion;           /*completion routine addr (0 for synch calls)*/
+  volatile OSErr      ioResult;               /*result code*/
+  StringPtr           ioNamePtr;              /*ptr to Vol:FileName string*/
+  FSVolumeRefNum      ioVRefNum;              /*volume refnum (DrvNum for Eject and MountVol)*/
+  SInt16              ioWDCreated;
+  SInt16              ioWDIndex;
+  SInt32              ioWDProcID;
+  FSVolumeRefNum      ioWDVRefNum;
+  SInt16              filler10;
+  SInt32              filler11;
+  SInt32              filler12;
+  SInt32              filler13;
+  SInt32              ioWDDirID;
+};
+typedef struct WDParam                  WDParam;
+typedef WDParam *                       WDParamPtr;
+struct FIDParam {
+  QElemPtr            qLink;                  /*queue link in header*/
+  SInt16              qType;                  /*type byte for safety check*/
+  SInt16              ioTrap;                 /*FS: the Trap*/
+  Ptr                 ioCmdAddr;              /*FS: address to dispatch to*/
+  IOCompletionUPP     ioCompletion;           /*completion routine addr (0 for synch calls)*/
+  volatile OSErr      ioResult;               /*result code*/
+  StringPtr           ioNamePtr;              /*ptr to Vol:FileName string*/
+  FSVolumeRefNum      ioVRefNum;              /*volume refnum (DrvNum for Eject and MountVol)*/
+  SInt32              filler14;
+  StringPtr           ioDestNamePtr;          /* dest file name */
+  SInt32              filler15;
+  SInt32              ioDestDirID;            /* dest file's directory id */
+  SInt32              filler16;
+  SInt32              filler17;
+  SInt32              ioSrcDirID;             /* source file's directory id */
+  SInt16              filler18;
+  SInt32              ioFileID;               /* file ID */
+};
+typedef struct FIDParam                 FIDParam;
+typedef FIDParam *                      FIDParamPtr;
+struct ForeignPrivParam {
+  QElemPtr            qLink;                  /*queue link in header*/
+  SInt16              qType;                  /*type byte for safety check*/
+  SInt16              ioTrap;                 /*FS: the Trap*/
+  Ptr                 ioCmdAddr;              /*FS: address to dispatch to*/
+  IOCompletionUPP     ioCompletion;           /*completion routine addr (0 for synch calls)*/
+  volatile OSErr      ioResult;               /*result code*/
+  StringPtr           ioNamePtr;              /*ptr to Vol:FileName string*/
+  FSVolumeRefNum      ioVRefNum;              /*volume refnum (DrvNum for Eject and MountVol)*/
+  SInt32              ioFiller21;
+  SInt32              ioFiller22;
+  Ptr                 ioForeignPrivBuffer;
+  SInt32              ioForeignPrivActCount;
+  SInt32              ioForeignPrivReqCount;
+  SInt32              ioFiller23;
+  SInt32              ioForeignPrivDirID;
+  SInt32              ioForeignPrivInfo1;
+  SInt32              ioForeignPrivInfo2;
+  SInt32              ioForeignPrivInfo3;
+  SInt32              ioForeignPrivInfo4;
+};
+typedef struct ForeignPrivParam         ForeignPrivParam;
+typedef ForeignPrivParam *              ForeignPrivParamPtr;
+struct CSParam {
+  QElemPtr            qLink;                  /*queue link in header*/
+  SInt16              qType;                  /*type byte for safety check*/
+  SInt16              ioTrap;                 /*FS: the Trap*/
+  Ptr                 ioCmdAddr;              /*FS: address to dispatch to*/
+  IOCompletionUPP     ioCompletion;           /*completion routine addr (0 for synch calls)*/
+  volatile OSErr      ioResult;               /*result code*/
+  StringPtr           ioNamePtr;              /*ptr to Vol:FileName string*/
+  FSVolumeRefNum      ioVRefNum;              /*volume refnum (DrvNum for Eject and MountVol)*/
+  FSSpecPtr           ioMatchPtr;             /* match array */
+  SInt32              ioReqMatchCount;        /* maximum allowable matches */
+  SInt32              ioActMatchCount;        /* actual match count */
+  SInt32              ioSearchBits;           /* search criteria selector */
+  CInfoPBPtr          ioSearchInfo1;          /* search values and range lower bounds */
+  CInfoPBPtr          ioSearchInfo2;          /* search values and range upper bounds */
+  SInt32              ioSearchTime;           /* length of time to run search */
+  CatPositionRec      ioCatPosition;          /* current position in the catalog */
+  Ptr                 ioOptBuffer;            /* optional performance enhancement buffer */
+  SInt32              ioOptBufSize;           /* size of buffer pointed to by ioOptBuffer */
+};
+typedef struct CSParam                  CSParam;
+typedef CSParam *                       CSParamPtr;
+union HParamBlockRec {
+  HIOParam            ioParam;
+  HFileParam          fileParam;
+  HVolumeParam        volumeParam;
+  AccessParam         accessParam;
+  ObjParam            objParam;
+  CopyParam           copyParam;
+  WDParam             wdParam;
+  FIDParam            fidParam;
+  CSParam             csParam;
+  ForeignPrivParam    foreignPrivParam;
+};
+typedef union HParamBlockRec            HParamBlockRec;
+
+
+typedef HParamBlockRec *                HParmBlkPtr;
+
+struct CMovePBRec {
+  QElemPtr            qLink;                  /*queue link in header*/
+  SInt16              qType;                  /*type byte for safety check*/
+  SInt16              ioTrap;                 /*FS: the Trap*/
+  Ptr                 ioCmdAddr;              /*FS: address to dispatch to*/
+  IOCompletionUPP     ioCompletion;           /*completion routine addr (0 for synch calls)*/
+  volatile OSErr      ioResult;               /*result code*/
+  StringPtr           ioNamePtr;              /*ptr to Vol:FileName string*/
+  FSVolumeRefNum      ioVRefNum;              /*volume refnum (DrvNum for Eject and MountVol)*/
+  SInt32              filler1;
+  StringPtr           ioNewName;
+  SInt32              filler2;
+  SInt32              ioNewDirID;
+  SInt32              filler3[2];
+  SInt32              ioDirID;
+};
+typedef struct CMovePBRec               CMovePBRec;
+typedef CMovePBRec *                    CMovePBPtr;
+struct WDPBRec {
+  QElemPtr            qLink;                  /*queue link in header*/
+  SInt16              qType;                  /*type byte for safety check*/
+  SInt16              ioTrap;                 /*FS: the Trap*/
+  Ptr                 ioCmdAddr;              /*FS: address to dispatch to*/
+  IOCompletionUPP     ioCompletion;           /*completion routine addr (0 for synch calls)*/
+  volatile OSErr      ioResult;               /*result code*/
+  StringPtr           ioNamePtr;              /*ptr to Vol:FileName string*/
+  FSVolumeRefNum      ioVRefNum;              /*volume refnum (DrvNum for Eject and MountVol)*/
+  SInt16              filler1;
+  SInt16              ioWDIndex;
+  SInt32              ioWDProcID;
+  FSVolumeRefNum      ioWDVRefNum;
+  SInt16              filler2[7];
+  SInt32              ioWDDirID;
+};
+typedef struct WDPBRec                  WDPBRec;
+typedef WDPBRec *                       WDPBPtr;
+struct FCBPBRec {
+  QElemPtr            qLink;                  /*queue link in header*/
+  SInt16              qType;                  /*type byte for safety check*/
+  SInt16              ioTrap;                 /*FS: the Trap*/
+  Ptr                 ioCmdAddr;              /*FS: address to dispatch to*/
+  IOCompletionUPP     ioCompletion;           /*completion routine addr (0 for synch calls)*/
+  volatile OSErr      ioResult;               /*result code*/
+  StringPtr           ioNamePtr;              /*ptr to Vol:FileName string*/
+  FSVolumeRefNum      ioVRefNum;              /*volume refnum (DrvNum for Eject and MountVol)*/
+  FSIORefNum          ioRefNum;
+  SInt16              filler;
+  SInt16              ioFCBIndx;
+  SInt16              filler1;
+  SInt32              ioFCBFlNm;
+  SInt16              ioFCBFlags;
+  UInt16              ioFCBStBlk;
+  SInt32              ioFCBEOF;
+  SInt32              ioFCBPLen;
+  SInt32              ioFCBCrPs;
+  FSVolumeRefNum      ioFCBVRefNum;
+  SInt32              ioFCBClpSiz;
+  SInt32              ioFCBParID;
+};
+typedef struct FCBPBRec                 FCBPBRec;
+typedef FCBPBRec *                      FCBPBPtr;
+struct VCB {
+  QElemPtr            qLink;
+  SInt16              qType;
+  SInt16              vcbFlags;
+  UInt16              vcbSigWord;
+  UInt32              vcbCrDate;
+  UInt32              vcbLsMod;
+  SInt16              vcbAtrb;
+  UInt16              vcbNmFls;
+  SInt16              vcbVBMSt;
+  SInt16              vcbAllocPtr;
+  UInt16              vcbNmAlBlks;
+  SInt32              vcbAlBlkSiz;
+  SInt32              vcbClpSiz;
+  SInt16              vcbAlBlSt;
+  SInt32              vcbNxtCNID;
+  UInt16              vcbFreeBks;
+  Str27               vcbVN;
+  SInt16              vcbDrvNum;
+  FSIORefNum          vcbDRefNum;
+  SInt16              vcbFSID;
+  FSVolumeRefNum      vcbVRefNum;
+  Ptr                 vcbMAdr;
+  Ptr                 vcbBufAdr;
+  SInt16              vcbMLen;
+  SInt16              vcbDirIndex;
+  SInt16              vcbDirBlk;
+  UInt32              vcbVolBkUp;
+  UInt16              vcbVSeqNum;
+  SInt32              vcbWrCnt;
+  SInt32              vcbXTClpSiz;
+  SInt32              vcbCTClpSiz;
+  UInt16              vcbNmRtDirs;
+  SInt32              vcbFilCnt;
+  SInt32              vcbDirCnt;
+  SInt32              vcbFndrInfo[8];
+  UInt16              vcbVCSize;
+  UInt16              vcbVBMCSiz;
+  UInt16              vcbCtlCSiz;
+  UInt16              vcbXTAlBlks;
+  UInt16              vcbCTAlBlks;
+  SInt16              vcbXTRef;
+  SInt16              vcbCTRef;
+  Ptr                 vcbCtlBuf;
+  SInt32              vcbDirIDM;
+  SInt16              vcbOffsM;
+};
+typedef struct VCB                      VCB;
+typedef VCB *                           VCBPtr;
+struct DrvQEl {
+  QElemPtr            qLink;
+  SInt16              qType;
+  SInt16              dQDrive;
+  SInt16              dQRefNum;
+  SInt16              dQFSID;
+  UInt16              dQDrvSz;
+  UInt16              dQDrvSz2;
+};
+typedef struct DrvQEl                   DrvQEl;
+typedef DrvQEl *                        DrvQElPtr;
+#endif  /* !__LP64__ */
+
+
+/*
+ *  FSPermissionInfo
+ *  
+ *  Discussion:
+ *    This structure is used when kFSCatInfoPermissions is passed to
+ *    the HFSPlus API. On return from GetCatalogInfo and
+ *    GetCatalogInfoBulk, the userID, groupID, and mode fields are
+ *    returned.  When passed to SetCatalogInfo, only the mode field is
+ *    set.  See chmod(2) for details about the mode field. This is
+ *    supported on Mac OS X only. NOTE: An FSFileSecurityRef retrieved
+ *    via FSGetCatalogInfo is a copy and must be released using
+ *    CFRelease() when no longer needed.
+ */
+struct FSPermissionInfo {
+  UInt32              userID;
+  UInt32              groupID;
+  UInt8               reserved1;
+  UInt8               userAccess;
+  UInt16              mode;
+  FSFileSecurityRef   fileSec;
+};
+typedef struct FSPermissionInfo         FSPermissionInfo;
+/*  CatalogInfoBitmap describes which fields of the CatalogInfo you wish to get or set.*/
+
+typedef UInt32                          FSCatalogInfoBitmap;
+enum {
+  kFSCatInfoNone                = 0x00000000,
+  kFSCatInfoTextEncoding        = 0x00000001,
+  kFSCatInfoNodeFlags           = 0x00000002, /* Locked (bit 0) and directory (bit 4) only */
+  kFSCatInfoVolume              = 0x00000004,
+  kFSCatInfoParentDirID         = 0x00000008,
+  kFSCatInfoNodeID              = 0x00000010,
+  kFSCatInfoCreateDate          = 0x00000020,
+  kFSCatInfoContentMod          = 0x00000040,
+  kFSCatInfoAttrMod             = 0x00000080,
+  kFSCatInfoAccessDate          = 0x00000100,
+  kFSCatInfoBackupDate          = 0x00000200,
+  kFSCatInfoPermissions         = 0x00000400,
+  kFSCatInfoFinderInfo          = 0x00000800,
+  kFSCatInfoFinderXInfo         = 0x00001000,
+  kFSCatInfoValence             = 0x00002000, /* Folders only, zero for files */
+  kFSCatInfoDataSizes           = 0x00004000, /* Data fork logical and physical size */
+  kFSCatInfoRsrcSizes           = 0x00008000, /* Resource fork logical and physical size */
+  kFSCatInfoSharingFlags        = 0x00010000, /* sharingFlags: kioFlAttribMountedBit, kioFlAttribSharePointBit */
+  kFSCatInfoUserPrivs           = 0x00020000, /* userPrivileges */
+  kFSCatInfoUserAccess          = 0x00080000, /* (OS X only) */
+  kFSCatInfoSetOwnership        = 0x00100000, /* (OS X only) */
+  kFSCatInfoFSFileSecurityRef   = 0x00400000, /* FSFileSecurity Object, will show up in the permissions field independent of kFSCatInfoPermissions.  This is also not part of settable, gettable since it requires being released */
+  kFSCatInfoAllDates            = 0x000003E0,
+  kFSCatInfoGettableInfo        = 0x0003FFFF,
+  kFSCatInfoSettableInfo        = 0x00001FE3, /* flags, dates, permissions, Finder info, text encoding */
+  kFSCatInfoReserved            = (int)0xFFFC0000 /* bits that are currently reserved */
+};
+
+/*  Constants for nodeFlags field of FSCatalogInfo */
+enum {
+  kFSNodeLockedBit              = 0,    /* Set if file or directory is locked */
+  kFSNodeLockedMask             = 0x0001,
+  kFSNodeResOpenBit             = 2,    /* Set if the resource fork is open */
+  kFSNodeResOpenMask            = 0x0004,
+  kFSNodeDataOpenBit            = 3,    /* Set if the data fork is open */
+  kFSNodeDataOpenMask           = 0x0008,
+  kFSNodeIsDirectoryBit         = 4,    /* Set if the object is a directory */
+  kFSNodeIsDirectoryMask        = 0x0010,
+  kFSNodeCopyProtectBit         = 6,
+  kFSNodeCopyProtectMask        = 0x0040,
+  kFSNodeForkOpenBit            = 7,    /* Set if the file or directory has any open fork */
+  kFSNodeForkOpenMask           = 0x0080,
+  kFSNodeHardLinkBit            = 8,    /* Set if the file or directory has a link count > 1 */
+  kFSNodeHardLinkMask           = 0x00000100
+};
+
+/*  Constants for sharingFlags field of FSCatalogInfo */
+enum {
+  kFSNodeInSharedBit            = 2,    /* Set if a directory is within a share point */
+  kFSNodeInSharedMask           = 0x0004,
+  kFSNodeIsMountedBit           = 3,    /* Set if a directory is a share point currently mounted by some user */
+  kFSNodeIsMountedMask          = 0x0008,
+  kFSNodeIsSharePointBit        = 5,    /* Set if a directory is a share point (exported volume) */
+  kFSNodeIsSharePointMask       = 0x0020
+};
+
+#ifdef __LP64__
+
+/*
+ *  FSCatalogInfo
+ *  
+ *  Discussion:
+ *    For each of the items in this structure, if the given bit is set
+ *    in the whichInfo paramater to the FSGetCatalogInfo call then the
+ *    field will be filled in on return.  Some fields which are not
+ *    asked for my be returned as well, but do not depend on this
+ *    behaviour.
+ */
+struct FSCatalogInfo {
+
+  /*
+   * kFSCatInfoNodeFlags / flag bits set if the file is locked, open,
+   * is a directory, etc.
+   */
+  UInt16              nodeFlags;              /* node flags */
+
+  /*
+   * kFSCatInfoVolume / the volume reference of the returned item
+   */
+  FSVolumeRefNum      volume;                 /* object's volume ref */
+
+  /*
+   * kFSCatInfoParentDirID / the directory id of the parent of the
+   * returned item
+   */
+  UInt32              parentDirID;            /* parent directory's ID */
+
+  /*
+   * kFSCatInfoNodeID / the file id of the returned item
+   */
+  UInt32              nodeID;                 /* file/directory ID */
+
+  /*
+   * kFSCatInfoSharingFlags / kioFlAttribMountedBit,
+   * kioFlAttribSharePointBit
+   */
+  UInt8               sharingFlags;           /* kioFlAttribMountedBit and kioFlAttribSharePointBit */
+  UInt8               userPrivileges;         /* user's effective AFP privileges (same as ioACUser) */
+  UInt8               reserved1;
+
+  /*
+   * Unused
+   */
+  UInt8               reserved2;
+
+  /*
+   * kFSCatInfoCreateDate / date and time of creation
+   */
+  UTCDateTime         createDate;             /* date and time of creation */
+
+  /*
+   * kFSCatInfoContentMod / date and time of last modification of the
+   * content of the returned item
+   */
+  UTCDateTime         contentModDate;         /* date and time of last fork modification */
+
+  /*
+   * kFSCatInfoAttrMod / date and time of the last modification of the
+   * attributes of the returned item
+   */
+  UTCDateTime         attributeModDate;       /* date and time of last attribute modification */
+
+  /*
+   * kFSCatInfoAccessDate / date and time of the last access to the
+   * returned item
+   */
+  UTCDateTime         accessDate;             /* date and time of last access (for Mac OS X) */
+
+  /*
+   * kFSCatInfoBackupDate / date and time of the last backup for the
+   * returned item
+   */
+  UTCDateTime         backupDate;             /* date and time of last backup */
+
+  /*
+   * kFSCatInfoPermissions / Mac OS X only, file system permissions of
+   * the returned item.  Coerce to a FSPermissionInfo to use.
+   */
+  FSPermissionInfo    permissions;            /* permissions (for Mac OS X), as FSPermissionInfo */
+
+  /*
+   * kFSCatInfoFinderInfo / file type, creator, flags, location. 
+   * Coerce to a File/FolderInfo to use.
+   */
+  UInt8               finderInfo[16];         /* Finder information part 1, as FileInfo or FolderInfo  */
+
+  /*
+   * kFSCatInfoFinderXInfo / icon, script, et al.  Coerce to a
+   * ExtendedFile/FolderInfo to use.
+   */
+  UInt8               extFinderInfo[16];      /* Finder information part 2, as ExtendedFileInfo or ExtendedFolderInfo */
+
+
+  /*
+   * kFSCatInfoDataSizes / the logical size of the data fork of the
+   * returned item if a file
+   */
+  UInt64              dataLogicalSize;        /* files only */
+
+  /*
+   * kFSCatInfoDataSizes / the physical size of the data fork of the
+   * returned item if a file
+   */
+  UInt64              dataPhysicalSize;       /* files only */
+
+  /*
+   * kFSCatInfoRsrcSizes / the logical size of the resource fork of the
+   * returned item if a file
+   */
+  UInt64              rsrcLogicalSize;        /* files only */
+
+  /*
+   * kFSCatInfoRsrcSizes / the physical size of the resource fork of
+   * the returned item if a file
+   */
+  UInt64              rsrcPhysicalSize;       /* files only */
+
+
+  /*
+   * kFSCatInfoValence / folders only, zero for files.
+   */
+  UInt32              valence;                /* folders only */
+
+  /*
+   * kFSCatInfoTextEncoding / the text encoding hint for the returned
+   * item
+   */
+  TextEncoding        textEncodingHint;
+};
+typedef struct FSCatalogInfo            FSCatalogInfo;
+#else
+struct FSCatalogInfo {
+  UInt16              nodeFlags;              /* node flags */
+  FSVolumeRefNum      volume;                 /* object's volume ref */
+  UInt32              parentDirID;            /* parent directory's ID */
+  UInt32              nodeID;                 /* file/directory ID */
+  UInt8               sharingFlags;           /* kioFlAttribMountedBit and kioFlAttribSharePointBit */
+  UInt8               userPrivileges;         /* user's effective AFP privileges (same as ioACUser) */
+  UInt8               reserved1;
+  UInt8               reserved2;
+  UTCDateTime         createDate;             /* date and time of creation */
+  UTCDateTime         contentModDate;         /* date and time of last fork modification */
+  UTCDateTime         attributeModDate;       /* date and time of last attribute modification */
+  UTCDateTime         accessDate;             /* date and time of last access (for Mac OS X) */
+  UTCDateTime         backupDate;             /* date and time of last backup */
+  UInt32              permissions[4];         /* permissions (for Mac OS X), as FSPermissionInfo */
+  UInt8               finderInfo[16];         /* Finder information part 1, as FileInfo or FolderInfo  */
+  UInt8               extFinderInfo[16];      /* Finder information part 2, as ExtendedFileInfo or ExtendedFolderInfo */
+
+  UInt64              dataLogicalSize;        /* files only */
+  UInt64              dataPhysicalSize;       /* files only */
+  UInt64              rsrcLogicalSize;        /* files only */
+  UInt64              rsrcPhysicalSize;       /* files only */
+
+  UInt32              valence;                /* folders only */
+  TextEncoding        textEncodingHint;
+};
+typedef struct FSCatalogInfo            FSCatalogInfo;
+#endif  /* defined(__LP64__) */
+
+typedef FSCatalogInfo *                 FSCatalogInfoPtr;
+struct FSRefParam {
+  QElemPtr            qLink;                  /*queue link in header*/
+  SInt16              qType;                  /*type byte for safety check*/
+  SInt16              ioTrap;                 /*FS: the Trap*/
+  Ptr                 ioCmdAddr;              /*FS: address to dispatch to*/
+  IOCompletionUPP     ioCompletion;           /*completion routine addr (0 for synch calls)*/
+  volatile OSErr      ioResult;               /*result code*/
+  ConstStringPtr      ioNamePtr;              /*ptr to Vol:FileName string*/
+  FSVolumeRefNum      ioVRefNum;              /*volume refnum (DrvNum for Eject and MountVol)*/
+
+  SInt16              reserved1;              /* was ioRefNum */
+  UInt8               reserved2;              /* was ioVersNum */
+  UInt8               reserved3;              /* was ioPermssn */
+
+  const FSRef *       ref;                    /* Input ref; the target of the call */
+  FSCatalogInfoBitmap  whichInfo;
+  FSCatalogInfo *     catInfo;
+  UniCharCount        nameLength;             /* input name length for create/rename */
+  const UniChar *     name;                   /* input name for create/rename */
+  UInt32              ioDirID;
+  FSSpecPtr           spec;
+  FSRef *             parentRef;              /* ref of directory to move another ref to */
+  FSRef *             newRef;                 /* Output ref */
+  TextEncoding        textEncodingHint;       /* for Rename, MakeFSRefUnicode */
+  HFSUniStr255 *      outName;                /* Output name for GetCatalogInfo */
+};
+typedef struct FSRefParam               FSRefParam;
+typedef FSRefParam *                    FSRefParamPtr;
+/* for use with PBCreateFileAndOpenFork*/
+struct FSRefForkIOParam {
+  QElemPtr            qLink;                  /*queue link in header*/
+  SInt16              qType;                  /*type byte for safety check*/
+  SInt16              ioTrap;                 /*FS: the Trap*/
+  Ptr                 ioCmdAddr;              /*FS: address to dispatch to*/
+  IOCompletionUPP     ioCompletion;           /*completion routine addr (0 for synch calls)*/
+  volatile OSErr      ioResult;               /*result code*/
+  const FSRef *       parentRef;              /* ref of directory to move another ref to */
+  UniCharCount        nameLength;             /* input name length for create/rename */
+  const UniChar *     name;                   /* input name for create/rename */
+  FSCatalogInfoBitmap  whichInfo;
+  const FSCatalogInfo * catInfo;
+  UniCharCount        forkNameLength;         /* input; length of fork name */
+  const UniChar *     forkName;               /* input; name of fork (NULL indicates data fork) */
+  SInt8               permissions;            /* desired access to the fork */
+  UInt8               reserved1;
+  FSIORefNum          forkRefNum;             /* Output refNum of newly opened fork */
+  FSRef *             newRef;                 /* Output ref */
+};
+typedef struct FSRefForkIOParam         FSRefForkIOParam;
+typedef FSRefForkIOParam *              FSRefForkIOParamPtr;
+typedef struct OpaqueFSIterator*        FSIterator;
+enum {
+  kFSIterateFlat                = 0,    /* Immediate children of container only */
+  kFSIterateSubtree             = 1,    /* Entire subtree rooted at container */
+  kFSIterateDelete              = 2,
+  kFSIterateReserved            = (int)0xFFFFFFFC
+};
+
+typedef OptionBits                      FSIteratorFlags;
+struct FSSearchParams {
+  Duration            searchTime;             /* a Time Manager duration */
+  OptionBits          searchBits;             /* which fields to search on */
+  UniCharCount        searchNameLength;
+  const UniChar *     searchName;
+  FSCatalogInfo *     searchInfo1;            /* values and lower bounds */
+  FSCatalogInfo *     searchInfo2;            /* masks and upper bounds */
+};
+typedef struct FSSearchParams           FSSearchParams;
+typedef FSSearchParams *                FSSearchParamsPtr;
+struct FSCatalogBulkParam {
+  QElemPtr            qLink;                  /*queue link in header*/
+  SInt16              qType;                  /*type byte for safety check*/
+  SInt16              ioTrap;                 /*FS: the Trap*/
+  Ptr                 ioCmdAddr;              /*FS: address to dispatch to*/
+  IOCompletionUPP     ioCompletion;           /*completion routine addr (0 for synch calls)*/
+  volatile OSErr      ioResult;               /*result code*/
+  Boolean             containerChanged;       /* true if container changed since last iteration */
+  UInt8               reserved;               /* make following fields 4-byte aligned */
+
+  FSIteratorFlags     iteratorFlags;
+  FSIterator          iterator;
+  const FSRef *       container;              /* directory/volume to iterate */
+  ItemCount           maximumItems;
+  ItemCount           actualItems;
+  FSCatalogInfoBitmap  whichInfo;
+  FSCatalogInfo *     catalogInfo;            /* returns an array */
+  FSRef *             refs;                   /* returns an array */
+  FSSpecPtr           specs;                  /* returns an array */
+  HFSUniStr255 *      names;                  /* returns an array */
+  const FSSearchParams * searchParams;
+};
+typedef struct FSCatalogBulkParam       FSCatalogBulkParam;
+typedef FSCatalogBulkParam *            FSCatalogBulkParamPtr;
+typedef UInt16                          FSAllocationFlags;
+enum {
+  kFSAllocDefaultFlags          = 0x0000, /* as much as possible, not contiguous */
+  kFSAllocAllOrNothingMask      = 0x0001, /* allocate all of the space, or nothing */
+  kFSAllocContiguousMask        = 0x0002, /* new space must be one contiguous piece */
+  kFSAllocNoRoundUpMask         = 0x0004, /* don't round up allocation to clump size */
+  kFSAllocReservedMask          = 0xFFF8 /* these bits are reserved and must not be set */
+};
+
+struct FSForkIOParam {
+  QElemPtr            qLink;                  /*queue link in header*/
+  SInt16              qType;                  /*type byte for safety check*/
+  SInt16              ioTrap;                 /*FS: the Trap*/
+  Ptr                 ioCmdAddr;              /*FS: address to dispatch to*/
+  IOCompletionUPP     ioCompletion;           /*completion routine addr (0 for synch calls)*/
+  volatile OSErr      ioResult;               /*result code*/
+  void *              reserved1;              /* was ioNamePtr */
+  SInt16              reserved2;              /* was ioVRefNum */
+  FSIORefNum          forkRefNum;             /* same as ioRefNum */
+  UInt8               reserved3;              /* was ioVersNum */
+  SInt8               permissions;            /* desired access to the fork */
+  const FSRef *       ref;                    /* which object to open */
+
+
+  Ptr                 buffer;                 /*data buffer Ptr*/
+  UInt32              requestCount;           /*requested byte count*/
+  UInt32              actualCount;            /*actual byte count completed*/
+  UInt16              positionMode;           /*initial file positioning*/
+  SInt64              positionOffset;         /*file position offset*/
+
+  FSAllocationFlags   allocationFlags;
+  UInt64              allocationAmount;
+
+  UniCharCount        forkNameLength;         /* input; length of fork name */
+  const UniChar *     forkName;               /* input; name of fork */
+
+  CatPositionRec      forkIterator;
+  HFSUniStr255 *      outForkName;            /* output; name of fork */
+};
+typedef struct FSForkIOParam            FSForkIOParam;
+typedef FSForkIOParam *                 FSForkIOParamPtr;
+typedef UInt8                           FSForkInfoFlags;
+struct FSForkInfo {
+  FSForkInfoFlags     flags;                  /* copy of FCB flags */
+  SInt8               permissions;
+  FSVolumeRefNum      volume;
+  UInt32              reserved2;
+  UInt32              nodeID;                 /* file or directory ID */
+  UInt32              forkID;                 /* fork ID */
+  UInt64              currentPosition;
+  UInt64              logicalEOF;
+  UInt64              physicalEOF;
+  UInt64              process;                /* should be ProcessSerialNumber */
+};
+typedef struct FSForkInfo               FSForkInfo;
+typedef FSForkInfo *                    FSForkInfoPtr;
+struct FSForkCBInfoParam {
+  QElemPtr            qLink;                  /*queue link in header*/
+  SInt16              qType;                  /*type byte for safety check*/
+  SInt16              ioTrap;                 /*FS: the Trap*/
+  Ptr                 ioCmdAddr;              /*FS: address to dispatch to*/
+  IOCompletionUPP     ioCompletion;           /*completion routine addr (0 for synch calls)*/
+  volatile OSErr      ioResult;               /*result code*/
+  FSIORefNum          desiredRefNum;          /* 0 to iterate, non-0 for specific refnum */
+  FSVolumeRefNum      volumeRefNum;           /* volume to match, or 0 for all volumes */
+  FSIORefNum          iterator;               /* 0 to start iteration */
+  FSVolumeRefNum      actualRefNum;           /* actual refnum found */
+
+  FSRef *             ref;
+  FSForkInfo *        forkInfo;
+  HFSUniStr255 *      forkName;
+};
+typedef struct FSForkCBInfoParam        FSForkCBInfoParam;
+typedef FSForkCBInfoParam *             FSForkCBInfoParamPtr;
+/* Parameter block for use with 64 bit range lock calls.*/
+struct FSRangeLockParam {
+  QElemPtr            qLink;                  /*queue link in header*/
+  SInt16              qType;                  /*type byte for safety check*/
+  SInt16              ioTrap;                 /*FS: the Trap*/
+  Ptr                 ioCmdAddr;              /*FS: address to dispatch to*/
+  IOCompletionUPP     ioCompletion;           /*completion routine addr (0 for synch calls)*/
+  volatile OSErr      ioResult;               /*result code*/
+  FSIORefNum          forkRefNum;             /* fork to operate on */
+  UInt64              requestCount;           /*requested byte count*/
+  UInt16              positionMode;           /*initial file positioning*/
+  SInt64              positionOffset;         /*file position offset*/
+  UInt64              rangeStart;             /* byte number of first byte (un)locked */
+
+};
+typedef struct FSRangeLockParam         FSRangeLockParam;
+typedef FSRangeLockParam *              FSRangeLockParamPtr;
+typedef UInt32                          FSVolumeInfoBitmap;
+enum {
+  kFSVolInfoNone                = 0x0000,
+  kFSVolInfoCreateDate          = 0x0001,
+  kFSVolInfoModDate             = 0x0002,
+  kFSVolInfoBackupDate          = 0x0004,
+  kFSVolInfoCheckedDate         = 0x0008,
+  kFSVolInfoFileCount           = 0x0010,
+  kFSVolInfoDirCount            = 0x0020,
+  kFSVolInfoSizes               = 0x0040, /* totalBytes and freeBytes */
+  kFSVolInfoBlocks              = 0x0080, /* blockSize, totalBlocks, freeBlocks */
+  kFSVolInfoNextAlloc           = 0x0100,
+  kFSVolInfoRsrcClump           = 0x0200,
+  kFSVolInfoDataClump           = 0x0400,
+  kFSVolInfoNextID              = 0x0800,
+  kFSVolInfoFinderInfo          = 0x1000,
+  kFSVolInfoFlags               = 0x2000,
+  kFSVolInfoFSInfo              = 0x4000, /* filesystemID, signature */
+  kFSVolInfoDriveInfo           = 0x8000, /* driveNumber, driverRefNum */
+  kFSVolInfoGettableInfo        = 0xFFFF, /* This seems like it is here just for completeness */
+  kFSVolInfoSettableInfo        = 0x3004 /* backup date, Finder info, flags */
+};
+
+/* FSVolumeInfo.flags bits.  These are the same as for ioVAtrb, but with nicer names. */
+enum {
+  kFSVolFlagDefaultVolumeBit    = 5,    /* Set if the volume is the default volume */
+  kFSVolFlagDefaultVolumeMask   = 0x0020,
+  kFSVolFlagFilesOpenBit        = 6,    /* Set if there are open files or iterators */
+  kFSVolFlagFilesOpenMask       = 0x0040,
+  kFSVolFlagHardwareLockedBit   = 7,    /* Set if volume is locked by a hardware setting */
+  kFSVolFlagHardwareLockedMask  = 0x0080,
+  kFSVolFlagJournalingActiveBit = 14,   /* Set if journaling is active on volume */
+  kFSVolFlagJournalingActiveMask = 0x4000,
+  kFSVolFlagSoftwareLockedBit   = 15,   /* Set if volume is locked by software */
+  kFSVolFlagSoftwareLockedMask  = 0x8000
+};
+
+
+struct FSVolumeInfo {
+                                              /* Dates -- zero means "never" or "unknown" */
+  UTCDateTime         createDate;
+  UTCDateTime         modifyDate;
+  UTCDateTime         backupDate;
+  UTCDateTime         checkedDate;
+
+                                              /* File/Folder counts -- return zero if unknown */
+  UInt32              fileCount;              /* total files on volume */
+  UInt32              folderCount;            /* total folders on volume */
+                                              /* Note: no root directory counts */
+
+  UInt64              totalBytes;             /* total number of bytes on volume */
+  UInt64              freeBytes;              /* number of free bytes on volume */
+
+                                              /* HFS and HFS Plus specific.  Set fields to zero if not appropriate */
+  UInt32              blockSize;              /* size (in bytes) of allocation blocks */
+  UInt32              totalBlocks;            /* number of allocation blocks in volume */
+  UInt32              freeBlocks;             /* number of unused allocation blocks */
+  UInt32              nextAllocation;         /* start of next allocation search */
+  UInt32              rsrcClumpSize;          /* default resource fork clump size */
+  UInt32              dataClumpSize;          /* default data fork clump size */
+  UInt32              nextCatalogID;          /* next unused catalog node ID ¥¥¥ OYG ¥¥¥ need to make HFSVolumes.h work Should be HFSCatalogNodeID*/
+  UInt8               finderInfo[32];         /* information used by Finder */
+
+                                              /* Identifying information */
+  UInt16              flags;                  /* ioVAtrb */
+  UInt16              filesystemID;           /* ioVFSID */
+  UInt16              signature;              /* ioVSigWord, unique within an FSID */
+  UInt16              driveNumber;            /* ioVDrvInfo */
+  FSIORefNum          driverRefNum;           /* ioVDRefNum */
+};
+typedef struct FSVolumeInfo             FSVolumeInfo;
+typedef FSVolumeInfo *                  FSVolumeInfoPtr;
+struct FSVolumeInfoParam {
+  QElemPtr            qLink;                  /*queue link in header*/
+  SInt16              qType;                  /*type byte for safety check*/
+  SInt16              ioTrap;                 /*FS: the Trap*/
+  Ptr                 ioCmdAddr;              /*FS: address to dispatch to*/
+  IOCompletionUPP     ioCompletion;           /*completion routine addr (0 for synch calls)*/
+  volatile OSErr      ioResult;               /*result code*/
+  StringPtr           ioNamePtr;              /* unused */
+  FSVolumeRefNum      ioVRefNum;              /* volume refnum */
+
+  UInt32              volumeIndex;            /* index, or 0 to use ioVRefNum */
+  FSVolumeInfoBitmap  whichInfo;              /* which volumeInfo fields to get/set */
+  FSVolumeInfo *      volumeInfo;             /* information about the volume */
+  HFSUniStr255 *      volumeName;             /* output; pointer to volume name */
+  FSRef *             ref;                    /* volume's FSRef */
+};
+typedef struct FSVolumeInfoParam        FSVolumeInfoParam;
+typedef FSVolumeInfoParam *             FSVolumeInfoParamPtr;
+struct GetVolParmsInfoBuffer {
+  SInt16              vMVersion;              /*version number*/
+  SInt32              vMAttrib;               /*bit vector of attributes (see vMAttrib constants)*/
+  Handle              vMLocalHand;            /*handle to private data*/
+  SInt32              vMServerAdr;            /*AppleTalk server address or zero*/
+                                              /*       vMVersion 1 GetVolParmsInfoBuffer ends here */
+  SInt32              vMVolumeGrade;          /*approx. speed rating or zero if unrated*/
+  SInt16              vMForeignPrivID;        /*foreign privilege model supported or zero if none*/
+                                              /*       vMVersion 2 GetVolParmsInfoBuffer ends here */
+  SInt32              vMExtendedAttributes;   /*extended attribute bits (see vMExtendedAttributes constants)*/
+                                              /*       vMVersion 3 GetVolParmsInfoBuffer ends here */
+  void *              vMDeviceID;             /* device id name for interoperability with IOKit */
+                                              /*       vMVersion 4 GetVolParmsInfoBuffer ends here */
+  UniCharCount        vMMaxNameLength;
+                                              /*       vMVersion 5 GetVolParmsInfoBuffer ends here */
+};
+typedef struct GetVolParmsInfoBuffer    GetVolParmsInfoBuffer;
+/* 
+    The following are structures to be filled out with the _PBGetVolMountInfo call
+    and passed back into the _PBVolumeMount call for external file system mounts. 
+*/
+/* the "signature" of the file system */
+
+typedef OSType                          VolumeType;
+enum {
+                                        /* the signature for AppleShare */
+  AppleShareMediaType           = 'afpm'
+};
+
+/*
+    VolMount stuff was once in FSM.Å
+*/
+struct VolMountInfoHeader {
+  SInt16              length;                 /* length of location data (including self) */
+  VolumeType          media;                  /* type of media.  Variable length data follows */
+};
+typedef struct VolMountInfoHeader       VolMountInfoHeader;
+typedef VolMountInfoHeader *            VolMountInfoPtr;
+/* The new volume mount info record.  The old one is included for compatibility. 
+    the new record allows access by foriegn filesystems writers to the flags 
+    portion of the record. This portion is now public.  
+*/
+struct VolumeMountInfoHeader {
+  SInt16              length;                 /* length of location data (including self) */
+  VolumeType          media;                  /* type of media (must be registered with Apple) */
+  SInt16              flags;                  /* volume mount flags. Variable length data follows */
+};
+typedef struct VolumeMountInfoHeader    VolumeMountInfoHeader;
+typedef VolumeMountInfoHeader *         VolumeMountInfoHeaderPtr;
+/* volume mount flags */
+enum {
+  volMountNoLoginMsgFlagBit     = 0,    /* Input to VolumeMount: If set, the file system */
+  volMountNoLoginMsgFlagMask    = 0x0001, /*  should suppresss any log-in message/greeting dialog */
+  volMountExtendedFlagsBit      = 7,    /* Input to VolumeMount: If set, the mount info is a */
+  volMountExtendedFlagsMask     = 0x0080, /*  AFPXVolMountInfo record for 3.7 AppleShare Client */
+  volMountInteractBit           = 15,   /* Input to VolumeMount: If set, it's OK for the file system */
+  volMountInteractMask          = 0x8000, /*  to perform user interaction to mount the volume */
+  volMountChangedBit            = 14,   /* Output from VoumeMount: If set, the volume was mounted, but */
+  volMountChangedMask           = 0x4000, /*  the volume mounting information record needs to be updated. */
+  volMountFSReservedMask        = 0x00FF, /* bits 0-7 are defined by each file system for its own use */
+  volMountSysReservedMask       = 0xFF00 /* bits 8-15 are reserved for Apple system use */
+};
+
+
+
+struct AFPVolMountInfo {
+  SInt16              length;                 /* length of location data (including self) */
+  VolumeType          media;                  /* type of media */
+  SInt16              flags;                  /* bits for no messages, no reconnect */
+  SInt8               nbpInterval;            /* NBP Interval parameter (IM2, p.322) */
+  SInt8               nbpCount;               /* NBP Interval parameter (IM2, p.322) */
+  SInt16              uamType;                /* User Authentication Method */
+  SInt16              zoneNameOffset;         /* short positive offset from start of struct to Zone Name */
+  SInt16              serverNameOffset;       /* offset to pascal Server Name string */
+  SInt16              volNameOffset;          /* offset to pascal Volume Name string */
+  SInt16              userNameOffset;         /* offset to pascal User Name string */
+  SInt16              userPasswordOffset;     /* offset to pascal User Password string */
+  SInt16              volPasswordOffset;      /* offset to pascal Volume Password string */
+  char                AFPData[144];           /* variable length data may follow */
+};
+typedef struct AFPVolMountInfo          AFPVolMountInfo;
+typedef AFPVolMountInfo *               AFPVolMountInfoPtr;
+
+
+/* AFPXVolMountInfo is the new AFP volume mount info record, requires the 3.7 AppleShare Client */
+struct AFPXVolMountInfo {
+  SInt16              length;                 /* length of location data (including self) */
+  VolumeType          media;                  /* type of media */
+  SInt16              flags;                  /* bits for no messages, no reconnect */
+  SInt8               nbpInterval;            /* NBP Interval parameter (IM2, p.322) */
+  SInt8               nbpCount;               /* NBP Interval parameter (IM2, p.322) */
+  SInt16              uamType;                /* User Authentication Method type */
+  SInt16              zoneNameOffset;         /* short positive offset from start of struct to Zone Name */
+  SInt16              serverNameOffset;       /* offset to pascal Server Name string */
+  SInt16              volNameOffset;          /* offset to pascal Volume Name string */
+  SInt16              userNameOffset;         /* offset to pascal User Name string */
+  SInt16              userPasswordOffset;     /* offset to pascal User Password string */
+  SInt16              volPasswordOffset;      /* offset to pascal Volume Password string */
+  SInt16              extendedFlags;          /* extended flags word */
+  SInt16              uamNameOffset;          /* offset to a pascal UAM name string */
+  SInt16              alternateAddressOffset; /* offset to Alternate Addresses in tagged format */
+  char                AFPData[176];           /* variable length data may follow */
+};
+typedef struct AFPXVolMountInfo         AFPXVolMountInfo;
+typedef AFPXVolMountInfo *              AFPXVolMountInfoPtr;
+enum {
+  kAFPExtendedFlagsAlternateAddressMask = 1 /*  bit in AFPXVolMountInfo.extendedFlags that means alternateAddressOffset is used*/
+};
+
+
+enum {
+                                        /* constants for use in AFPTagData.fType field*/
+  kAFPTagTypeIP                 = 0x01, /* 4 byte IP address (MSB first)            */
+  kAFPTagTypeIPPort             = 0x02, /* 4 byte IP address, 2 byte port (MSB first)     */
+  kAFPTagTypeDDP                = 0x03, /* Net,Node,Socket Sent by the server, currently unused by the client */
+  kAFPTagTypeDNS                = 0x04  /* DNS name in  address:port format   (total length variable up to 254 chars of dns name)          */
+};
+
+
+enum {
+                                        /* constants for use in AFPTagData.fLength field*/
+  kAFPTagLengthIP               = 0x06,
+  kAFPTagLengthIPPort           = 0x08,
+  kAFPTagLengthDDP              = 0x06
+};
+
+struct AFPTagData {
+  UInt8               fLength;                /* length of this data tag including the fLength field */
+  UInt8               fType;
+  UInt8               fData[1];               /* variable length data */
+};
+typedef struct AFPTagData               AFPTagData;
+struct AFPAlternateAddress {
+                                              /* ¥¥¥ÊNOTE: fVersion was missing in 3.2 Universal Interfaces*/
+  UInt8               fVersion;               /* version of the structure (currently 0x00)*/
+  UInt8               fAddressCount;
+  UInt8               fAddressList[1];        /* actually variable length packed set of AFPTagData */
+};
+typedef struct AFPAlternateAddress      AFPAlternateAddress;
+enum {
+  kLargeIconSize                = 256,
+  kLarge4BitIconSize            = 512,
+  kLarge8BitIconSize            = 1024,
+  kSmallIconSize                = 64,
+  kSmall4BitIconSize            = 128,
+  kSmall8BitIconSize            = 256
+};
+
+/*
+ *  NewIOCompletionUPP()
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   available as macro/inline
+ */
+extern IOCompletionUPP
+NewIOCompletionUPP(IOCompletionProcPtr userRoutine)           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+/*
+ *  DisposeIOCompletionUPP()
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   available as macro/inline
+ */
+extern void
+DisposeIOCompletionUPP(IOCompletionUPP userUPP)               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+/*
+ *  InvokeIOCompletionUPP()
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   available as macro/inline
+ */
+extern void
+InvokeIOCompletionUPP(
+  ParmBlkPtr       paramBlock,
+  IOCompletionUPP  userUPP)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+#if __MACH__
+  #ifdef __cplusplus
+    inline IOCompletionUPP                                      NewIOCompletionUPP(IOCompletionProcPtr userRoutine) { return userRoutine; }
+    inline void                                                 DisposeIOCompletionUPP(IOCompletionUPP) { }
+    inline void                                                 InvokeIOCompletionUPP(ParmBlkPtr paramBlock, IOCompletionUPP userUPP) { (*userUPP)(paramBlock); }
+  #else
+    #define NewIOCompletionUPP(userRoutine)                     ((IOCompletionUPP)userRoutine)
+    #define DisposeIOCompletionUPP(userUPP)
+    #define InvokeIOCompletionUPP(paramBlock, userUPP)          (*userUPP)(paramBlock)
+  #endif
+#endif
+
+
+/*
+    MakeFSRefUnicode
+    Create an FSRef for an existing object specified by 
+    Parent FSRef and Unicode name.
+    ->  ioCompletion    A pointer to a completion routine
+    <-  ioResult        The result code of the function
+    ->  ref             A pointer to the parent directory FSRef
+    ->  name            A pointer to Unicode name
+    ->  nameLength      The length of the Unicode Name
+    ->  textEncodingHint A suggested text encoding to use for the name
+    <-  newRef          A pointer to an FSRef
+*/
+/*
+ *  FSMakeFSRefUnicode()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  FSMakeFSRefUnicode(const FSRef *parentRef, UniCharCount nameLength, const UniChar *name, TextEncoding textEncodingHint, FSRef *newRef) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBMakeFSRefUnicodeSync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  PBMakeFSRefUnicodeSync(FSRefParam * paramBlock) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBMakeFSRefUnicodeAsync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern void  PBMakeFSRefUnicodeAsync(FSRefParam * paramBlock) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+
+/*
+    CompareFSRefs
+    Test whether two FSRefs refer to the same file or directory.
+    If they do, noErr is returned.  Otherwise, an appropriate error
+    (such as errFSRefsDifferent) is returned.
+    ->  ioCompletion    A pointer to a completion routine
+    <-  ioResult        The result code of the function
+    ->  ref             A pointer to the first FSRef
+    ->  parentRef       A pointer to the second FSRef
+*/
+/*
+ *  FSCompareFSRefs()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  FSCompareFSRefs(const FSRef *ref1, const FSRef *ref2)                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBCompareFSRefsSync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  PBCompareFSRefsSync(FSRefParam * paramBlock)    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBCompareFSRefsAsync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern void  PBCompareFSRefsAsync(FSRefParam * paramBlock)    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+
+/*
+    CreateFileUnicode
+    Creates a new file.  The input filename is in Unicode.
+    You can optionally set catalog info for the file.
+    ->  ioCompletion    A pointer to a completion routine
+    <-  ioResult        The result code of the function
+    ->  ref             The directory where the file is to be created
+    ->  whichInfo       Which catalog info fields to set
+    ->  catInfo         The values for catalog info fields to set; may be NULL
+    ->  nameLength      Number of Unicode characters in the file's name
+    ->  name            A pointer to the Unicode name
+    <-  spec            A pointer to the FSSpec for the new directory; may be NULL.  Ignored on 64 bit.
+    <-  newRef          A pointer to the FSRef for the new file; may be NULL
+*/
+/*
+ *  FSCreateFileUnicode()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  FSCreateFileUnicode(const FSRef *parentRef, UniCharCount nameLength, const UniChar *name, FSCatalogInfoBitmap whichInfo, const FSCatalogInfo *catalogInfo, FSRef *newRef, FSSpecPtr newSpec) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBCreateFileUnicodeSync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  PBCreateFileUnicodeSync(FSRefParam * paramBlock) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBCreateFileUnicodeAsync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern void  PBCreateFileUnicodeAsync(FSRefParam * paramBlock) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+
+/*
+    CreateDirectoryUnicode
+    Creates a new directory.  The input directory name is in Unicode.
+    You can optionally set catalog info for the directory.
+    ->  ioCompletion    A pointer to a completion routine
+    <-  ioResult        The result code of the function
+    ->  ref             The parent directory where the directory is to be created
+    ->  whichInfo       Which catalog info fields to set
+    ->  catInfo         The values for catalog info fields to set; may be NULL
+    ->  nameLength      Number of Unicode characters in the directory's name
+    ->  name            A pointer to the Unicode name
+    <-  ioDirID         The DirID of the new directory
+    <-  newSpec         A pointer to the FSSpec for the new directory; may be NULL.  Ignored on 64 bit.
+    <-  newRef          A pointer to the FSRef for the new directory; may be NULL
+*/
+/*
+ *  FSCreateDirectoryUnicode()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  FSCreateDirectoryUnicode(const FSRef *parentRef, UniCharCount nameLength, const UniChar *name, FSCatalogInfoBitmap whichInfo, const FSCatalogInfo *catalogInfo, FSRef *newRef, FSSpecPtr newSpec, UInt32 *newDirID) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBCreateDirectoryUnicodeSync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  PBCreateDirectoryUnicodeSync(FSRefParam * paramBlock) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBCreateDirectoryUnicodeAsync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern void  PBCreateDirectoryUnicodeAsync(FSRefParam * paramBlock) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+
+/*
+    DeleteObject
+    Deletes an existing file or directory.
+    ->  ioCompletion    A pointer to a completion routine
+    <-  ioResult        The result code of the function
+    ->  ref             The file or directory to be deleted
+*/
+/*
+ *  FSDeleteObject()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  FSDeleteObject(const FSRef * ref)               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBDeleteObjectSync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  PBDeleteObjectSync(FSRefParam * paramBlock)     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBDeleteObjectAsync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern void  PBDeleteObjectAsync(FSRefParam * paramBlock)     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+
+/*
+    UnlinkObject
+    Unlinks an existing file or deletes an existing directory.  This call will succeed on an open file, unlike
+    DeleteObject.  This call will unlink an archive directory link (where DeleteObject will treat the ADL as a directory).
+    ->  ioCompletion    A pointer to a completion routine
+    <-  ioResult        The result code of the function
+    ->  ref             The file or directory to be deleted
+*/
+/*
+ *  FSUnlinkObject()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.5
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.5 and later in CoreServices.framework
+ *    CarbonLib:        not available
+ *    Non-Carbon CFM:   not available
+ */
+extern OSErr  FSUnlinkObject(const FSRef * ref)               AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
+
+
+/*
+ *  PBUnlinkObjectSync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.5
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.5 and later in CoreServices.framework
+ *    CarbonLib:        not available
+ *    Non-Carbon CFM:   not available
+ */
+extern OSErr  PBUnlinkObjectSync(FSRefParam * paramBlock)     AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
+
+
+/*
+ *  PBUnlinkObjectAsync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.5
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.5 and later in CoreServices.framework
+ *    CarbonLib:        not available
+ *    Non-Carbon CFM:   not available
+ */
+extern void  PBUnlinkObjectAsync(FSRefParam * paramBlock)     AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
+
+
+/*
+    MoveObject
+    Move an existing file or directory into a different directory.
+    ->  ioCompletion    A pointer to a completion routine
+    <-  ioResult        The result code of the function
+    ->  ref             The file or directory to be moved
+    ->  parentRef       The file or directory will be moved into this directory
+    <-  newRef          A new FSRef for the file or directory in its new location;
+                        optional, may be NULL
+    NOTE: Moving an object may change its FSRef.  If you want to continue to
+    refer to the object, you should pass a non-NULL pointer in newRef and use
+    that returned FSRef to access the object after the move.  The FSRef passed
+    in "ref" may or may not be usable to access the object after it is moved.
+    "newRef" may point to the same storage as "parentRef" or "ref".
+*/
+/*
+ *  FSMoveObject()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  FSMoveObject(const FSRef *ref, const FSRef *destDirectory, FSRef *newRef)        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBMoveObjectSync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  PBMoveObjectSync(FSRefParam * paramBlock)       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBMoveObjectAsync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern void  PBMoveObjectAsync(FSRefParam * paramBlock)       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+
+/*
+    ExchangeObjects
+    swap the contents of two files.
+    ->  ioCompletion    A pointer to a completion routine
+    <-  ioResult        The result code of the function
+    ->  ref             The first file 
+    ->  parentRef       The second file 
+*/
+/*
+ *  FSExchangeObjects()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  FSExchangeObjects(const FSRef *ref, const FSRef *destRef)                 AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBExchangeObjectsSync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  PBExchangeObjectsSync(FSRefParam * paramBlock)  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBExchangeObjectsAsync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern void  PBExchangeObjectsAsync(FSRefParam * paramBlock)  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+    FSReplaceObject and FSPathReplaceObject
+
+    You can use the FSReplaceObject and FSPathReplaceObject functions to replace
+    one object, the original object, with another, the replacement object.
+    FSReplaceObject and FSPathReplaceObject are provided to assist in properly
+    preserving metadata during safe save operations. These functions allow files
+    to replace files, directories to replace directories, directories to replace
+    files and files to replace directories (so a package can replace a file, or
+    a file can replace a package). Both objects must reside on the same volume.
+
+    If FSReplaceObject or FSPathReplaceObject are successful, the result object
+    will exist at the location of the original object. Nothing will exist at the
+    location of the replacement object.  By default FSReplaceObject and  FSPathReplaceObject
+    will test the object for write access, and fail if write access is not available.
+    Write access in this context is ACL_WRITE_DATA for files and ACL_ADD_FILE for directories.
+    This check can be bypassed by passing the kFSReplaceObjectDoNotCheckObjectWriteAccess flag.
+
+    FSReplaceObject and FSPathReplaceObject may need to create a temporary object
+    when one of the input objects is a directory, or when the
+    kFSReplaceObjectSaveOriginalAsABackup option is specified. The temporary object
+    is required since the rename system call does not handle non-empty directory
+    replacement or file <-> directory replacement. The file replacing file case
+    does not use a temporary object (unless the kFSReplaceObjectSaveOriginalAsABackup
+    option is specified). If no temporary name is provided and a temporary object
+    is required, then the functions will return an error. Providing a temporary
+    name will also allow an application to recover the original object should a
+    catastrophic failure (such as a power outage) occur during a replacement
+    involving a directory. The temporary object will be created with the temporary
+    name either in the temporary directory specified by the temporaryDirectory
+    parameter, or in the preferred temporary directory (the preferred temporary
+    directory can be obtained with the FSGetTemporaryDirectoryForReplaceObject
+    or FSPathGetTemporaryDirectoryForReplaceObject functions). 
+
+    If the kFSReplaceObjectSaveOriginalAsABackup option is specified, the original
+    object will be saved in one of two locations: If the temporaryName parameter
+    is provided, the original object will be saved with that temporary name in
+    the temporary directory. If the temporaryName parameter is not provided and
+    the newName parameter is provided, the original object will be saved with
+    its original name in the temporary directory.
+
+    The result object will have the data (or directory contents) from the
+    replacement object, but will have the original object's creation date and
+    backup date. By default, the result object will have extended attributes
+    merged from the original object and the replacement object, using the extended
+    attributes of the replacement object if the original object has extended
+    attributes with the same name. If the kFSReplaceObjectReplaceMetadata option
+    flag is passed, then the extended attributes of the original object will be
+    completely overwritten by the extended attributes of the replacement object.
+    
+    The kFSReplaceObjectReplaceMetadata also controls how the label, type, creator,
+    hidden extension bit, strong binding, custom icon and custom badge are handled.
+    For the custom icon, custom badge, label (where a value of 0 is considered not
+    present), and strong binding the replacement object's attributes will be
+    used if present, otherwise the original object's attributes will be retained.  For
+    the extension hidden bit, type, and creator the original object's attribute is
+    preserved.  Setting the kFSReplaceObjectReplaceMetadata flag will use the replacement
+    object's attributes for all cases.  Type and creator are only handled in the 
+    file to file case.  Strong bindings are not applicable to plain directories.
+    
+    The default handling of ACL and mode info depends on the types of objects
+    involved. If the original object and replacement object are of the same type
+    (both files or both directories) then the default behavior is to use the ACL
+    and mode of the original object. Setting the kFSReplaceObjectReplacePermissionInfo
+    flag will use the ACL and mode from the replacementObject.
+
+    If the objects are different types, then the ACL and mode will be based off
+    the original object and will translated as follows:
+
+        Mode:
+        file r -> dir rx
+        file w -> dir wx
+        file x -> dir nothing
+
+        dir r -> file r
+        dir w -> file w
+        dir x -> file nothing
+
+        ACLs:
+
+        ACL_SEARCH will be added to any allow ACE in the file to directory case.
+        ACL_EXECUTE will be removed from any ACE in the file to directory case.
+        
+        ACL_SEARCH and ACL_DELETE_CHILD will be removed from any ACE in the directory to file case.
+
+        File                Directory
+        ACL_READ_DATA   <-> ACL_LIST_DIRECTORY
+        ACL_WRITE_DATA  <-> ACL_ADD_FILE
+        ACL_APPEND_DATA <-> ACL_ADD_SUBDIRECTORY
+
+        ACL_DELETE , ACL_READ_ATTRIBUTES, ACL_WRITE_ATTRIBUTES, ACL_READ_EXTATTRIBUTES,
+        ACL_WRITE_EXTATTRIBUTES, ACL_READ_SECURITY, ACL_WRITE_SECURITY and ACL_CHANGE_OWNER
+        are the same for both types and will be left alone.
+                        
+    This translation behavior can be avoided by passing in either
+    kFSReplaceObjectPreservePermissionInfo to use the original object ACL and
+    mode info unchanged (except where the bits have different meanings for files
+    and directories) or kFSReplaceObjectReplacePermissionInfo to use the ACL and
+    mode info of the replacement object (except where the bits have different
+    meanings for files and directories). Setting both of these flags is an
+    error -- the call will fail with a paramErr. The permissions are only set on
+    the top-level object -- the permissions inside a directory are unaffected.
+    
+    FSReplaceObject may not be atomic -- it may issue multiple system calls to
+    accurately replace and preserve the metadata of a file system object.
+    
+    FSReplaceObject may fail if the source or destination files are open or
+    the source or destination objects are directories which contain open files.
+*/
+
+/*
+ *  FSReplaceObjectOptions
+ *  
+ *  Discussion:
+ *    Options that can be passed to the FSReplaceObject and
+ *    FSPathReplaceObject functions. These are mask values that can be
+ *    ORed together to set more than one option.
+ */
+enum {
+
+  /*
+   * Use the default behavior (see the discussion of the
+   * FSReplaceObject function)
+   */
+  kFSReplaceObjectDefaultOptions = 0,
+
+  /*
+   * The result object will only have the metadata from the replacement
+   * object. The result object will have no metadata from the original
+   * object.
+   */
+  kFSReplaceObjectReplaceMetadata = 0x01,
+
+  /*
+   * The original object will be saved with the temporary name in the
+   * temporaryDirectory, or will be saved with the original name (if no
+   * temporaryName is provided and a newName is provided) in the
+   * temporaryDirectory.
+   */
+  kFSReplaceObjectSaveOriginalAsABackup = 0x02,
+
+  /*
+   * ACL and mode info will come from the replacement object.
+   */
+  kFSReplaceObjectReplacePermissionInfo = 0x04,
+
+  /*
+   * ACL and mode info will come from the original object
+   */
+  kFSReplaceObjectPreservePermissionInfo = 0x08,
+
+  /*
+   * FSReplaceObject does not actually require write permission to
+   * perform the replace operation, since no actual writing is done to
+   * the original object.  By default ReplaceObject will test the
+   * object for write permissions and fail if they are not present
+   * (tested using accessx_np).  Write permission in this context is
+   * defined as ACL_WRITE_DATA for files and ACL_ADD_FILE for
+   * directories.  Pass this flag to skip this check (which will allow
+   * the replace to operate on "read only" objects).
+   */
+  kFSReplaceObjectDoNotCheckObjectWriteAccess = 0x10
+};
+
+/*
+ *  FSReplaceObject()
+ *  
+ *  Discussion:
+ *    This function will replace the object specified by originalObject
+ *    with the object specified by replacementObject. The result object
+ *    will be in the same parent directory as the original object.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.5
+ *  
+ *  Parameters:
+ *    
+ *    originalObject:
+ *      The original object to be replaced.
+ *    
+ *    replacementObject:
+ *      The object which will replace the original object.
+ *    
+ *    newName:
+ *      The new name for the result object. Pass NULL to use the
+ *      original object's name.
+ *    
+ *    temporaryName:
+ *      The name of a temporary object should the operation require a
+ *      temporary object. The temporary object will be created in the
+ *      preferred temporary directory or in the directory specified by
+ *      the temporaryDirectory parameter.
+ *    
+ *    temporaryDirectory:
+ *      The directory where the temporary object (if needed) will be
+ *      created. The temporary directory must be on the same volume as
+ *      the original object. If NULL is passed, then the preferred
+ *      temporary directory is used (as per
+ *      FSGetTemporaryDirectoryForReplaceObject).
+ *    
+ *    flags:
+ *      A set of options to specify non-default behavior.
+ *    
+ *    resultObject:
+ *      A new FSRef for the result object.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.5 and later in CoreServices.framework
+ *    CarbonLib:        not available
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSReplaceObject(const FSRef *originalObject, const FSRef *replacementObject, CFStringRef newName, CFStringRef temporaryName, const FSRef *temporaryDirectory, OptionBits flags, FSRef *resultObject) AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
+
+
+/*
+ *  FSPathReplaceObject()
+ *  
+ *  Discussion:
+ *    This function will replace the object specified by
+ *    originalObjectPath with the object specified by
+ *    replacementObjectPath. The result object will be in the same
+ *    parent directory as the original object.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.5
+ *  
+ *  Parameters:
+ *    
+ *    originalObjectPath:
+ *      The path to the original object to be replaced.
+ *    
+ *    replacementObjectPath:
+ *      The path to the object which will replace the original object.
+ *    
+ *    newName:
+ *      The new name for the result object. Pass NULL to use the
+ *      original object's name.
+ *    
+ *    temporaryName:
+ *      The name of a temporary object should the operation require a
+ *      temporary object. The temporary object will be created in the
+ *      preferred temporary directory or in the directory specified by
+ *      the temporaryDirectory parameter.
+ *    
+ *    temporaryDirectoryPath:
+ *      The path to the directory where the temporary object (if
+ *      needed) will be created. The temporary directory must be on the
+ *      same volume as the original object. If NULL is passed, then the
+ *      preferred temporary directory is used (as per
+ *      FSPathGetTemporaryDirectoryForReplaceObject).
+ *    
+ *    flags:
+ *      A set of options to specify non-default behavior.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.5 and later in CoreServices.framework
+ *    CarbonLib:        not available
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSPathReplaceObject(const char *originalObjectPath, const char *replacementObjectPath, CFStringRef newName, CFStringRef temporaryName, const char *temporaryDirectoryPath, OptionBits flags) AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
+
+
+/*
+ *  FSGetTemporaryDirectoryForReplaceObject()
+ *  
+ *  Discussion:
+ *    This function will return the preferred directory for use as the
+ *    temporaryDirectory by FSReplaceObject. It will return an
+ *    appropriate temporary location or the parent directory of the
+ *    original object.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.5
+ *  
+ *  Parameters:
+ *    
+ *    originalObject:
+ *      The original object to be replaced.
+ *    
+ *    temporaryDirectory:
+ *      The preferred temporary directory.
+ *    
+ *    flags:
+ *      A set of options to specify non-default behavior. Currently no
+ *      flags are defined - pass in 0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.5 and later in CoreServices.framework
+ *    CarbonLib:        not available
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSGetTemporaryDirectoryForReplaceObject(const FSRef *originalObject, FSRef *temporaryDirectory, OptionBits flags) AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
+
+
+/*
+ *  FSPathGetTemporaryDirectoryForReplaceObject()
+ *  
+ *  Discussion:
+ *    This function will return the preferred directory for use as the
+ *    temporaryDirectory by FSPathReplaceObject. It will return an
+ *    appropriate temporary location or the parent directory of the
+ *    original object.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.5
+ *  
+ *  Parameters:
+ *    
+ *    originalObjectPath:
+ *      The path to the original object to be replaced.
+ *    
+ *    temporaryDirectoryPath:
+ *      The path to the preferred temporary directory.
+ *    
+ *    maxPathSize:
+ *      The size of the buffer pointed to by the temporaryDirectoryPath
+ *      parameter.
+ *    
+ *    flags:
+ *      A set of options to specify non-default behavior. Currently no
+ *      flags are defined - pass in 0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.5 and later in CoreServices.framework
+ *    CarbonLib:        not available
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSPathGetTemporaryDirectoryForReplaceObject(const char *originalObjectPath, char *temporaryDirectoryPath, UInt32 maxPathSize, OptionBits flags) AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
+
+
+/*
+    RenameUnicode
+    Change the name of an existing file or directory.  The new name is in
+    Unicode.
+    ->  ioCompletion    A pointer to a completion routine
+    <-  ioResult        The result code of the function
+    ->  ref             The file or directory to be moved
+    ->  nameLength      Number of Unicode characters in the new name
+    ->  name            A pointer to the new Unicode name
+    ->  textEncodingHint A suggested text encoding to use for the name
+    <-  newRef          A new FSRef for the file or directory; may be NULL
+    NOTE: Renaming an object may change its FSRef.  If you want to continue to
+    refer to the object, you should pass a non-NULL pointer in newRef and use
+    that returned FSRef to access the object after the rename.  The FSRef passed
+    in "ref" may or may not be usable to access the object after it is renamed.
+    "newRef" may point to the same storage as "ref".
+*/
+/*
+ *  FSRenameUnicode()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  FSRenameUnicode(const FSRef *ref, UniCharCount nameLength, const UniChar *name, TextEncoding textEncodingHint, FSRef *newRef) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBRenameUnicodeSync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  PBRenameUnicodeSync(FSRefParam * paramBlock)    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBRenameUnicodeAsync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern void  PBRenameUnicodeAsync(FSRefParam * paramBlock)    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+
+/*
+    GetCatalogInfo
+    Returns various information about a given file or directory.
+    ->  ioCompletion    A pointer to a completion routine
+    <-  ioResult        The result code of the function
+    ->  ref             The file or directory whose information is to be returned
+    ->  whichInfo       Which catalog info fields to get
+    <-  catInfo         The returned values of catalog info fields; may be NULL
+    <-  spec            A pointer to the FSSpec for the object; may be NULL.  Ignored for 64 bit.
+    <-  parentRef       A pointer to the FSRef for the object's parent directory; may be NULL
+    <-  outName         The Unicode name is returned here.  This pointer may be NULL.
+    Note: All of the outputs are optional; if you don't want that particular output, just
+    set its pointer to NULL.  This is the call to use to map from an FSRef to an FSSpec.
+*/
+/*
+ *  FSGetCatalogInfo()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  FSGetCatalogInfo(const FSRef *ref, FSCatalogInfoBitmap whichInfo, FSCatalogInfo *catalogInfo, HFSUniStr255 *outName, FSSpecPtr fsSpec, FSRef *parentRef) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBGetCatalogInfoSync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  PBGetCatalogInfoSync(FSRefParam * paramBlock)   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBGetCatalogInfoAsync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern void  PBGetCatalogInfoAsync(FSRefParam * paramBlock)   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+
+/*
+ *  FSSetCatalogInfo()
+ *  
+ *  Summary:
+ *    Set catalog information about a given file or directory.
+ *  
+ *  Discussion:
+ *    Set the catalog information for the file or directory represented
+ *    by ref.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Parameters:
+ *    
+ *    ref:
+ *      A pointer to an FSRef specifying the file or directory whose
+ *      information is to be changed
+ *    
+ *    whichInfo:
+ *      A bitmap specifying which catalog information fields may be
+ *      set.  The settable fields are given by the constant
+ *      kFSCatInfoSettableInfo; no other bits may be set in whichInfo. 
+ *      The one exception to this is that processes running as eid 0 or
+ *      euid 0  can change the user ID and group ID of a file or
+ *      directory by setting kFSCatInfoSetOwnership in whichInfo and
+ *      setting the permissions field of catalogInfo.
+ *    
+ *    catalogInfo:
+ *      A pointer to the structure containing the new catalog
+ *      information. Only some of the catalog information fields may be
+ *      set.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  FSSetCatalogInfo(const FSRef *ref, FSCatalogInfoBitmap whichInfo, const FSCatalogInfo *catalogInfo)   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBSetCatalogInfoSync()
+ *  
+ *  Summary:
+ *    Set catalog information about a given file or directory.
+ *  
+ *  Discussion:
+ *    Set the catalog information for the file or directory represented
+ *    by ref.  See the description in FSSetCatalogInfo for which items
+ *    may be set.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  PBSetCatalogInfoSync(FSRefParam * paramBlock)   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBSetCatalogInfoAsync()
+ *  
+ *  Summary:
+ *    Set catalog information about a given file or directory.
+ *  
+ *  Discussion:
+ *    Set the catalog information for the file or directory represented
+ *    by ref.  See the description in FSSetCatalogInfo for which items
+ *    may be set.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern void  PBSetCatalogInfoAsync(FSRefParam * paramBlock)   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+
+/*
+    OpenIterator
+    Creates an FSIterator to iterate over a directory or subtree.  The
+    iterator can then be passed to GetCatalogInfoBulk or CatalogSearch.
+    ->  ioCompletion    A pointer to a completion routine
+    <-  ioResult        The result code of the function
+    <-  iterator        The returned FSIterator
+    ->  iteratorFlags   Controls whether the iterator iterates over subtrees
+                        or just the immediate children of the container.
+    ->  container       An FSRef for the directory to iterate (or root of
+                        the subtree to iterate).
+*/
+/*
+ *  FSOpenIterator()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  FSOpenIterator(const FSRef *container, FSIteratorFlags iteratorFlags, FSIterator *iterator) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBOpenIteratorSync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  PBOpenIteratorSync(FSCatalogBulkParam * paramBlock) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBOpenIteratorAsync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern void  PBOpenIteratorAsync(FSCatalogBulkParam * paramBlock) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+
+/*
+    CloseIterator
+    Invalidates and disposes an FSIterator.
+    ->  ioCompletion    A pointer to a completion routine
+    <-  ioResult        The result code of the function
+    ->  iterator        The returned FSIterator
+*/
+/*
+ *  FSCloseIterator()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  FSCloseIterator(FSIterator iterator)            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBCloseIteratorSync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  PBCloseIteratorSync(FSCatalogBulkParam * paramBlock) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBCloseIteratorAsync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern void  PBCloseIteratorAsync(FSCatalogBulkParam * paramBlock) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+
+/*
+    GetCatalogInfoBulk
+    Iterates over catalog objects and returns information about them.
+    For now, iterator must have been created with kFSIterateFlat option.
+    ->  ioCompletion    A pointer to a completion routine
+    <-  ioResult        The result code of the function
+    ->  iterator        The iterator
+    ->  maximumItems    The maximum number of items to return
+    <-  actualItems     The actual number of items returned
+    <-  containerChanged Set to true if the container's contents changed
+    ->  whichInfo       The catalog information fields to return for each item
+    <-  catalogInfo     An array of catalog information; one for each returned item
+    <-  refs            An array of FSRefs; one for each returned item
+    <-  specs           An array of FSSpecs; one for each returned item.  Ignored on 64 bit.
+    <-  names           An array of filenames; one for each returned item
+    Note: The catalogInfo, refs, specs, names, and containerChanged are all optional outputs;
+    if you don't want that particular output, set its pointer to NULL.
+*/
+/*
+ *  FSGetCatalogInfoBulk()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  FSGetCatalogInfoBulk(FSIterator iterator, ItemCount maximumObjects, ItemCount *actualObjects, Boolean *containerChanged, FSCatalogInfoBitmap whichInfo, FSCatalogInfo *catalogInfos, FSRef *refs, FSSpecPtr specs, HFSUniStr255 *names) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBGetCatalogInfoBulkSync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  PBGetCatalogInfoBulkSync(FSCatalogBulkParam * paramBlock) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBGetCatalogInfoBulkAsync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern void  PBGetCatalogInfoBulkAsync(FSCatalogBulkParam * paramBlock) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+    CatalogSearch
+    Iterates over catalog objects, searching for objects that match given
+    search criteria.  Returns various information about matching objects.
+    For now, iterator must have been created with kFSIterateSubtree option
+    and the container must have been the root directory of a volume.
+    ->  ioCompletion    A pointer to a completion routine
+    <-  ioResult        The result code of the function
+    ->  iterator        The iterator
+    ->  maximumItems    The maximum number of items to return
+    <-  actualItems     The actual number of items returned
+    <-  containerChanged Set to true if the container's contents changed
+    ->  whichInfo       The catalog information fields to return for each item
+    <-  catalogInfo     An array of catalog information; one for each returned item
+    <-  refs            An array of FSRefs; one for each returned item
+    <-  specs           An array of FSSpecs; one for each returned item.  Ignored on 64 bit.
+    <-  names           An array of filenames; one for each returned item
+    ->  searchParams    The criteria that controls the matching, including timeout, a bitmap
+                        controlling the fields to compare, and the (Unicode) name to compare.
+    Note: The catalogInfo, refs, specs, and names are all optional outputs; if you don't want
+    that particular output, set its pointer to NULL.
+*/
+/*
+ *  FSCatalogSearch()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  FSCatalogSearch(FSIterator iterator, const FSSearchParams *searchCriteria, ItemCount maximumObjects, ItemCount *actualObjects, Boolean *containerChanged, FSCatalogInfoBitmap whichInfo, FSCatalogInfo *catalogInfos, FSRef *refs, FSSpecPtr specs, HFSUniStr255 *names) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBCatalogSearchSync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  PBCatalogSearchSync(FSCatalogBulkParam * paramBlock) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBCatalogSearchAsync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern void  PBCatalogSearchAsync(FSCatalogBulkParam * paramBlock) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+
+/*
+    CreateFileAndOpenForkUnicode
+    Creates a new file and opens the specified fork.  The input filename is in Unicode.
+    You can optionally set catalog info for the file.
+    ->  ioCompletion    A pointer to a completion routine
+    <-  ioResult        The result code of the function
+    ->  parentRef       The directory where the file is to be created
+    ->  whichInfo       Which catalog info fields to set
+    ->  catalogInfo     The values for catalog info fields to set; may be NULL
+    ->  nameLength      Number of Unicode characters in the file's name
+    ->  name            A pointer to the Unicode name
+    ->  forkNameLength  The length of the fork name (in Unicode characters).
+    ->  forkName        The name of the fork to open (in Unicode).  Passing NULL will open the data fork.
+    ->  permissions     The access (read and/or write) you want
+    <-  forkRefNum      The reference number for accessing the open fork
+    <-  newRef          A pointer to the FSRef for the new file; may be NULL
+*/
+/*
+ *  FSCreateFileAndOpenForkUnicode()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.4 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSCreateFileAndOpenForkUnicode(const FSRef *parentRef, UniCharCount nameLength, const UniChar *name, FSCatalogInfoBitmap whichInfo, const FSCatalogInfo *catalogInfo, UniCharCount forkNameLength, const UniChar *forkName, SInt8 permissions, FSIORefNum *forkRefNum, FSRef *newRef) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/*
+ *  PBCreateFileAndOpenForkUnicodeSync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.4 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  PBCreateFileAndOpenForkUnicodeSync(FSRefForkIOParamPtr paramBlock) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/*
+ *  PBCreateFileAndOpenForkUnicodeAsync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.4 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern void  PBCreateFileAndOpenForkUnicodeAsync(FSRefForkIOParamPtr paramBlock) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/*
+    CreateFork
+    Create a named fork for a file or directory.
+    ->  ioCompletion    A pointer to a completion routine
+    <-  ioResult        The result code of the function
+    ->  ref             The file or directory
+    ->  forkNameLength  The length of the fork name (in Unicode characters)
+    ->  forkName        The name of the fork to open (in Unicode)
+*/
+/*
+ *  FSCreateFork()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  FSCreateFork(const FSRef *ref, UniCharCount forkNameLength, const UniChar *forkName)     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBCreateForkSync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  PBCreateForkSync(FSForkIOParam * paramBlock)    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBCreateForkAsync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern void  PBCreateForkAsync(FSForkIOParam * paramBlock)    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+
+/*
+    DeleteFork
+    Delete a named fork of a file or directory.
+    ->  ioCompletion    A pointer to a completion routine
+    <-  ioResult        The result code of the function
+    ->  ref             The file or directory
+    ->  forkNameLength  The length of the fork name (in Unicode characters)
+    ->  forkName        The name of the fork to open (in Unicode)
+*/
+/*
+ *  FSDeleteFork()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  FSDeleteFork(const FSRef *ref, UniCharCount forkNameLength, const UniChar *forkName)     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBDeleteForkSync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  PBDeleteForkSync(FSForkIOParam * paramBlock)    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBDeleteForkAsync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern void  PBDeleteForkAsync(FSForkIOParam * paramBlock)    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+
+/*
+    IterateForks
+    Return the names and sizes of the forks of a file or directory.
+    One fork is returned per call.
+    ->  ioCompletion    A pointer to a completion routine.
+    <-  ioResult        The result code of the function.
+    ->  ref             The file or directory containing the forks.
+    <-  positionOffset  The length of the fork, in bytes.
+    <-  allocationAmount The space allocated to the fork (physical length).
+    <-  outForkName     The name of the fork in Unicode.
+    <>  forkIterator    Maintains state between calls for a given FSRef.
+                        Before the first call, set the initialize field to zero.
+*/
+/*
+ *  FSIterateForks()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  FSIterateForks(const FSRef *ref, CatPositionRec *forkIterator, HFSUniStr255 *forkName, SInt64 *forkSize, UInt64 *forkPhysicalSize) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBIterateForksSync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  PBIterateForksSync(FSForkIOParam * paramBlock)  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBIterateForksAsync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern void  PBIterateForksAsync(FSForkIOParam * paramBlock)  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+
+/*
+    OpenFork
+    Open a fork for reading and/or writing.  Allows the opened fork
+    to grow beyond 2GB in size.  All volumes should support data and
+    resource forks.  Other named forks may be supported by some
+    volumes.
+    ->  ioCompletion    A pointer to a completion routine
+    <-  ioResult        The result code of the function
+    ->  ref             The file or directory containing the fork to open
+    ->  forkNameLength  The length of the fork name (in Unicode characters)
+    ->  forkName        The name of the fork to open (in Unicode)
+    ->  permissions     The access (read and/or write) you want
+    <-  forkRefNum      The reference number for accessing the open fork
+*/
+/*
+ *  FSOpenFork()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  FSOpenFork(const FSRef *ref, UniCharCount forkNameLength, const UniChar *forkName, SInt8 permissions, FSIORefNum *forkRefNum) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBOpenForkSync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  PBOpenForkSync(FSForkIOParam * paramBlock)      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBOpenForkAsync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern void  PBOpenForkAsync(FSForkIOParam * paramBlock)      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+
+/*
+    ReadFork
+    Read data from a fork opened via OpenFork.  The first byte to read is
+    indicated by a combination of positionMode and positionOffset.
+    ->  ioCompletion    A pointer to a completion routine
+    <-  ioResult        The result code of the function
+    ->  forkRefNum      The reference number of the fork to read from
+    <-  buffer          Pointer to buffer where data will be returned
+    ->  requestCount    The number of bytes to read
+    <-  actualCount     The number of bytes actually read
+    ->  positionMode    The base location for start of read
+    ->  positionOffset  The offset from base location for start of read
+*/
+/*
+ *  FSReadFork()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  FSReadFork(FSIORefNum forkRefNum, UInt16 positionMode, SInt64 positionOffset, ByteCount requestCount, void *buffer, ByteCount *actualCount) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBReadForkSync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  PBReadForkSync(FSForkIOParam * paramBlock)      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBReadForkAsync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern void  PBReadForkAsync(FSForkIOParam * paramBlock)      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+
+/*
+    WriteFork
+    Write data to a fork opened via OpenFork.  The first byte to write is
+    indicated by a combination of positionMode and positionOffset.
+    ->  ioCompletion    A pointer to a completion routine
+    <-  ioResult        The result code of the function
+    ->  forkRefNum      The reference number of the fork to write to
+    ->  buffer          Pointer to data to write
+    ->  requestCount    The number of bytes to write
+    <-  actualCount     The number of bytes actually written
+    ->  positionMode    The base location for start of write
+    ->  positionOffset  The offset from base location for start of write
+*/
+/*
+ *  FSWriteFork()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  FSWriteFork(FSIORefNum forkRefNum, UInt16 positionMode, SInt64 positionOffset, ByteCount requestCount, const void *buffer, ByteCount *actualCount) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBWriteForkSync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  PBWriteForkSync(FSForkIOParam * paramBlock)     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBWriteForkAsync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern void  PBWriteForkAsync(FSForkIOParam * paramBlock)     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+
+/*
+    GetForkPosition
+    Get the current (default) position of a fork that was
+    opened via OpenFork.
+    ->  ioCompletion    A pointer to a completion routine
+    <-  ioResult        The result code of the function
+    ->  forkRefNum      The reference number of the fork
+    <-  positionOffset  The current position of the fork
+*/
+/*
+ *  FSGetForkPosition()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  FSGetForkPosition(FSIORefNum forkRefNum, SInt64 *position)         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBGetForkPositionSync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  PBGetForkPositionSync(FSForkIOParam * paramBlock) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBGetForkPositionAsync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern void  PBGetForkPositionAsync(FSForkIOParam * paramBlock) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+
+/*
+    SetForkPosition
+    Set the current (default) position of a fork that was
+    opened via OpenFork.
+    ->  ioCompletion    A pointer to a completion routine
+    <-  ioResult        The result code of the function
+    ->  forkRefNum      The reference number of the fork
+    ->  positionMode    The base location for the new position
+    ->  positionOffset  The offset of the new position from the base
+*/
+/*
+ *  FSSetForkPosition()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  FSSetForkPosition(FSIORefNum forkRefNum, UInt16 positionMode, SInt64 positionOffset) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBSetForkPositionSync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  PBSetForkPositionSync(FSForkIOParam * paramBlock) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBSetForkPositionAsync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern void  PBSetForkPositionAsync(FSForkIOParam * paramBlock) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+
+/*
+    GetForkSize
+    Get the current logical size (end-of-file) of an open fork.
+    ->  ioCompletion    A pointer to a completion routine
+    <-  ioResult        The result code of the function
+    ->  forkRefNum      The reference number of the fork
+    <-  positionOffset  The logical size of the fork, in bytes
+*/
+/*
+ *  FSGetForkSize()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  FSGetForkSize(FSIORefNum forkRefNum, SInt64 *forkSize)             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBGetForkSizeSync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  PBGetForkSizeSync(FSForkIOParam * paramBlock)   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBGetForkSizeAsync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern void  PBGetForkSizeAsync(FSForkIOParam * paramBlock)   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+
+/*
+    SetForkSize
+    Set the logical size (end-of-file) of an open fork.  This
+    may cause space to be allocated or deallocated.
+    ->  ioCompletion    A pointer to a completion routine
+    <-  ioResult        The result code of the function
+    ->  forkRefNum      The reference number of the fork
+    ->  positionMode    The base location for the new size
+    ->  positionOffset  The offset of the new size from the base
+*/
+/*
+ *  FSSetForkSize()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  FSSetForkSize(FSIORefNum forkRefNum, UInt16 positionMode, SInt64 positionOffset) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBSetForkSizeSync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  PBSetForkSizeSync(FSForkIOParam * paramBlock)   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBSetForkSizeAsync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern void  PBSetForkSizeAsync(FSForkIOParam * paramBlock)   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+
+/*
+    AllocateFork
+    Allocate space to an open fork.  Typically, the space to be
+    allocated is beyond the current size of the fork, to reserve
+    space so the file will be able to grow later.  Some volume
+    formats are unable to allocate space beyond the logical size
+    of the fork.
+    ->  ioCompletion    A pointer to a completion routine
+    <-  ioResult        The result code of the function
+    ->  forkRefNum      The reference number of the fork
+    ->  positionMode    The base location for start of allocation
+    ->  positionOffset  The offset of the start of allocation
+    ->  allocationFlags Zero or more of the following flags:
+        kFSAllocContiguousMask
+                Any newly allocated space must be one contiguous piece.
+        kFSAllocAllOrNothingMask
+                All of the request space must be available, or the call
+                will fail.  (If not set, the call may succeed even though
+                some of the requested space wasn't allocated.)
+        kFSAllocNoRoundUpMask
+                Do not allocate additional space.  (If not set, a volume
+                may allocate additional space in order to reduce fragmentation.)
+    <>  allocationAmount    The number of bytes to allocate
+                            On output, the number of bytes actually added
+*/
+/*
+ *  FSAllocateFork()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  FSAllocateFork(FSIORefNum forkRefNum, FSAllocationFlags flags, UInt16 positionMode, SInt64 positionOffset, UInt64 requestCount, UInt64 *actualCount) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBAllocateForkSync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  PBAllocateForkSync(FSForkIOParam * paramBlock)  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBAllocateForkAsync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern void  PBAllocateForkAsync(FSForkIOParam * paramBlock)  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+
+/*
+    FlushFork
+    Flush a fork.  Any data written to this fork refnum is flushed to the device.
+    The volume's control structures are also flushed to the device.
+    ->  ioCompletion    A pointer to a completion routine
+    <-  ioResult        The result code of the function
+    ->  forkRefNum      The reference number of the fork to flush
+*/
+/*
+ *  FSFlushFork()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  FSFlushFork(FSIORefNum forkRefNum)              AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBFlushForkSync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  PBFlushForkSync(FSForkIOParam * paramBlock)     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBFlushForkAsync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern void  PBFlushForkAsync(FSForkIOParam * paramBlock)     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+
+/*
+    CloseFork
+    Flush and close a fork.  Any data written to this fork refnum is flushed
+    to the device.  The volume's control structures are also flushed to the device.
+    ->  ioCompletion    A pointer to a completion routine
+    <-  ioResult        The result code of the function
+    ->  forkRefNum      The reference number of the fork to close
+*/
+/*
+ *  FSCloseFork()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  FSCloseFork(FSIORefNum forkRefNum)              AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBCloseForkSync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  PBCloseForkSync(FSForkIOParam * paramBlock)     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBCloseForkAsync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern void  PBCloseForkAsync(FSForkIOParam * paramBlock)     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+
+/*
+    GetForkCBInfo
+    Return information about an open fork.
+    ->  ioCompletion    A pointer to a completion routine
+    <-  ioResult        The result code of the function
+    <>  desiredRefNum   If non-zero on input, then get information for this refnum;
+                        unchanged on output.  If zero on input, iterate over all open
+                        forks (possibly limited to a single volume); on output, contains
+                        the fork's refnum.
+    ->  volumeRefNum    Used when desiredRefNum is zero on input.  Set to 0 to iterate over all
+                        volumes, or set to a FSVolumeRefNum to limit iteration to that volume.
+    <>  iterator        Used when desiredRefNum is zero on input.  Set to 0 before iterating.
+                        Pass the iterator returned by the previous call to continue iterating.
+    <-  actualRefNum    The refnum of the open fork.
+    <-  ref             The FSRef for the file or directory that contains the fork.
+    <-  forkInfo        Various information about the open fork.
+    <-  outForkName     The name of the fork
+    Note: the foundRefNum, ref, forkInfo, and fork name outputs are all optional; if you don't want
+    a particular output, then set its pointer to NULL.  If forkName is NULL, then forkNameLength
+    will be undefined.
+    Note: Returning the forkInfo generally does not require a disk access.  Returning the
+    ref or forkName may cause disk access for some volume formats.
+*/
+/*
+ *  FSGetForkCBInfo()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  FSGetForkCBInfo(FSIORefNum desiredRefNum, FSVolumeRefNum volume, short *iterator, FSIORefNum *actualRefNum, FSForkInfo *forkInfo, FSRef *ref, HFSUniStr255 *outForkName) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBGetForkCBInfoSync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  PBGetForkCBInfoSync(FSForkCBInfoParam * paramBlock) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBGetForkCBInfoAsync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern void  PBGetForkCBInfoAsync(FSForkCBInfoParam * paramBlock) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+    PBXLockRange
+    Lock a range of bytes of the file fork specified by forkRefNum.
+    This is only supported on some volume formats. 
+    ->  ioCompletion    A pointer to a completion routine
+    <-  ioResult        The result code of the function
+    ->  forkRefNum      The reference number of the fork to read from
+    ->  requestCount    The number of bytes to lock
+    ->  positionMode    The base location for start of the range
+    ->  positionOffset  The offset from base location for start of the range
+    <-  rangeStart      Number of the first byte locked
+*/
+/*
+ *  FSLockRange()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.4 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSLockRange(FSIORefNum forkRefNum, UInt16 positionMode, SInt64 positionOffset, UInt64 requestCount, UInt64 *rangeStart) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/*
+ *  PBXLockRangeSync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.4 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  PBXLockRangeSync(FSRangeLockParamPtr paramBlock) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/*
+ *  PBXLockRangeAsync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.4 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  PBXLockRangeAsync(FSRangeLockParamPtr paramBlock) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/*
+    PBXUnlockRange
+    Unlock a range of bytes of the file fork specified by forkRefNum.
+    This is only supported on some volume formats. 
+    ->  ioCompletion    A pointer to a completion routine
+    <-  ioResult        The result code of the function
+    ->  forkRefNum      The reference number of the fork to read from
+    ->  requestCount    The number of bytes to lock
+    ->  positionMode    The base location for start of the range
+    ->  positionOffset  The offset from base location for start of the range
+    <-  rangeStart      Number of the first byte unlocked
+*/
+/*
+ *  FSUnlockRange()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.4 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSUnlockRange(FSIORefNum forkRefNum, UInt16 positionMode, SInt64 positionOffset, UInt64 requestCount, UInt64 *rangeStart) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/*
+ *  PBXUnlockRangeSync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.4 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  PBXUnlockRangeSync(FSRangeLockParamPtr paramBlock) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/*
+ *  PBXUnlockRangeAsync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.4 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  PBXUnlockRangeAsync(FSRangeLockParamPtr paramBlock) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/*
+    GetVolumeInfo
+    Returns various information about a given volume, or indexing over all volumes.
+    ->  ioCompletion    A pointer to a completion routine
+    <-  ioResult        The result code of the function
+    <>  ioVRefNum       On input, the volume reference number or drive number whose
+                        information is to be returned (if volumeIndex is 0); same
+                        as "volume" input to FSGetVolumeInfo.
+                        On output, the actual volume reference number; same as
+                        "actualVolume" output of FSGetVolumeInfo.
+    ->  volumeIndex     The index of the desired volume, or 0 to use ioVRefNum
+    ->  whichInfo       Which volInfo info fields to get
+    <-  volumeInfo      The returned values of Volume info fields; may be NULL
+    <-  name            The Unicode name is returned here.  This pointer may be NULL.
+    Note: All of the outputs are optional; if you don't want that particular output, just
+    set its pointer to NULL.
+*/
+/*
+ *  FSGetVolumeInfo()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  FSGetVolumeInfo(FSVolumeRefNum volume, ItemCount volumeIndex, FSVolumeRefNum *actualVolume, FSVolumeInfoBitmap whichInfo, FSVolumeInfo *info, HFSUniStr255 *volumeName, FSRef *rootDirectory) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBGetVolumeInfoSync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  PBGetVolumeInfoSync(FSVolumeInfoParam * paramBlock) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBGetVolumeInfoAsync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern void  PBGetVolumeInfoAsync(FSVolumeInfoParam * paramBlock) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+
+/*
+    SetVolumeInfo
+    Set information about a given volume.
+    ->  ioCompletion    A pointer to a completion routine
+    <-  ioResult        The result code of the function
+    ->  ioVRefNum       The volume whose information is to be changed
+    ->  whichInfo       Which catalog info fields to set
+    ->  volumeInfo      The new values of volume info fields
+    Note: Only some of the volume info fields may be set.  The settable fields
+    are given by the constant kFSVolInfoSettableInfo; no other bits may be set in
+    whichInfo.
+*/
+/*
+ *  FSSetVolumeInfo()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  FSSetVolumeInfo(FSVolumeRefNum volume, FSVolumeInfoBitmap whichInfo, const FSVolumeInfo *info)        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBSetVolumeInfoSync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  PBSetVolumeInfoSync(FSVolumeInfoParam * paramBlock) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PBSetVolumeInfoAsync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern void  PBSetVolumeInfoAsync(FSVolumeInfoParam * paramBlock) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+    FSGetDataForkName
+    Returns the constant for the name of the data fork (the empty string)
+*/
+/*
+ *  FSGetDataForkName()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  FSGetDataForkName(HFSUniStr255 * dataForkName)  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+    FSGetResourceForkName
+    Returns the constant for the name of the resource fork
+    (currently "RESOURCE_FORK").
+*/
+/*
+ *  FSGetResourceForkName()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  FSGetResourceForkName(HFSUniStr255 * resourceForkName) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  FSRefMakePath()
+ *  
+ *  Summary:
+ *    converts an FSRef to a POSIX path
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Parameters:
+ *    
+ *    ref:
+ *      the file/dir to get the POSIX path for
+ *    
+ *    path:
+ *      a pointer to a buffer which FSRefMakePath will fill with a UTF8
+ *      encoded C string representing the path the the specified FSRef
+ *    
+ *    pathBufferSize:
+ *      the size of the path buffer in bytes.  This size should include
+ *      the NULL terminator for the returned path string.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.1 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSRefMakePath(const FSRef *ref, UInt8 *path, UInt32 pathBufferSize)     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  FSPathMakeRef()
+ *  
+ *  Summary:
+ *    converts a POSIX path to an FSRef
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Parameters:
+ *    
+ *    path:
+ *      a pointer to a UTF8 encoded C String that is a POSIX path
+ *    
+ *    ref:
+ *      a pointer to an FSRef to fill in
+ *    
+ *    isDirectory:
+ *      an optional pointer to a Boolean that will be filled in with
+ *      whether the specified path is a directory (vs. a file)
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.1 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSPathMakeRef(const UInt8 *path, FSRef *ref, Boolean *isDirectory)        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+
+/*
+ *  FSPathMakeRefOptions
+ *  
+ *  Discussion:
+ *    Options that can be passed to the FSPathMakeRefWithOptions call.
+ */
+enum {
+  kFSPathMakeRefDefaultOptions  = 0,
+  kFSPathMakeRefDoNotFollowLeafSymlink = 0x01
+};
+
+/*
+ *  FSPathMakeRefWithOptions()
+ *  
+ *  Summary:
+ *    converts a POSIX path to an FSRef allowing for options other than
+ *    the default
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Parameters:
+ *    
+ *    path:
+ *      a pointer to a UTF8 encoded C String that is a POSIX path
+ *    
+ *    options:
+ *      a set of FSPathMakeRef options
+ *    
+ *    ref:
+ *      a pointer to an FSRef to fill in
+ *    
+ *    isDirectory:
+ *      an optional pointer to a Boolean that will be filled in with
+ *      whether the specified path is a directory (vs. a file)
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.4 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSPathMakeRefWithOptions(const UInt8 *path, OptionBits options, FSRef *ref, Boolean *isDirectory) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+
+/*
+ *  FSIsFSRefValid()
+ *  
+ *  Summary:
+ *    Returns true if ref refers to an existing valid file system
+ *    object, false otherwise.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Parameters:
+ *    
+ *    ref:
+ *      FSRef to test
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.4 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern Boolean  FSIsFSRefValid(const FSRef * ref)             AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+
+/*
+ *  FNMessage
+ *  
+ *  Discussion:
+ *    Messages broadcast about a directory.  If system clients (such as
+ *    the Finder) are interested in changes to a directory, they will
+ *    receive notifications when application code broadcasts change
+ *    messages about that directory.
+ */
+typedef UInt32 FNMessage;
+enum {
+  kFNDirectoryModifiedMessage   = 1
+};
+
+/*
+ *  FNNotify()
+ *  
+ *  Summary:
+ *    Broadcasts notification of changes to the specified directory.
+ *  
+ *  Discussion:
+ *    FNNotify is used to notify system clients (such as the Finder) of
+ *    modifications to the contents of a directory, specifically
+ *    addition or removal of files or folders from the directory. The
+ *    Finder and other system clients will refresh their views of the
+ *    specified directory when they receive the change notification.
+ *    FNNotify is not meant to notify the Finder of changes to a
+ *    specific file (for example, changes to a file's type or creator);
+ *    for that purpose, use a kAESync AppleEvent sent to the Finder.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Parameters:
+ *    
+ *    ref:
+ *      The directory for which to broadcast the notification
+ *    
+ *    message:
+ *      An indication of what happened to the target directory
+ *    
+ *    flags:
+ *      Options about delivery of the notification (specify kNilOptions
+ *      for default behaviour)
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.0 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FNNotify(const FSRef *ref, FNMessage message, OptionBits flags)                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  FNNotifyByPath()
+ *  
+ *  Summary:
+ *    Broadcasts notification of changes to the specified directory.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Parameters:
+ *    
+ *    path:
+ *      Path to the directory for which to broadcast the notification
+ *    
+ *    message:
+ *      An indication of what happened to the target directory
+ *    
+ *    flags:
+ *      Options about delivery of the notification (specify kNilOptions
+ *      for default behaviour)
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.0 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FNNotifyByPath(const UInt8 *path, FNMessage message, OptionBits flags)         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  FNNotifyAll()
+ *  
+ *  Discussion:
+ *    Broadcasts notification of changes to the filesystem (should only
+ *    be used by installers or programs which make lots of changes and
+ *    only send one broadcast).
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Parameters:
+ *    
+ *    message:
+ *      An indication of what happened
+ *    
+ *    flags:
+ *      Options about delivery of the notification (specify kNilOptions
+ *      for default behaviour)
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.0 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FNNotifyAll(FNMessage message, OptionBits flags)                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+
+
+/*
+ *  FNSubscriptionRef
+ *  
+ *  Discussion:
+ *    A token associated with a notification subscription.  The
+ *    subscriber gets one back when they subscribe to notifications for
+ *    a particular directory, and they supply it when the unsubscribe. 
+ *    It is also delivered along with the notifications for that
+ *    subscription.
+ */
+typedef struct OpaqueFNSubscriptionRef*  FNSubscriptionRef;
+
+/*
+ *  Discussion:
+ *    Options that can be specified at subscription time.
+ */
+enum {
+
+  /*
+   * Specify this option if you do not want to receive notifications on
+   * this subscription when FNNotifyAll is called; by default any
+   * subscription is also implicitly a subscription to wildcard
+   * notifications
+   */
+  kFNNoImplicitAllSubscription  = (1 << 0),
+
+  /*
+   * Specify this option if you want to receive notifications on this
+   * subscription when your application is in background.  By default
+   * notifications will be coalesced and and delivered when your
+   * application becomes foreground.
+   */
+  kFNNotifyInBackground         = (1 << 1)
+};
+
+
+/*
+ *  FNSubscriptionProcPtr
+ *  
+ *  Discussion:
+ *    Callback delivered for directory notifications.
+ *  
+ *  Parameters:
+ *    
+ *    message:
+ *      An indication of what happened
+ *    
+ *    flags:
+ *      Options about delivery of the notification (typically
+ *      kNilOptions)
+ *    
+ *    refcon:
+ *      User reference supplied with subscription
+ *    
+ *    subscription:
+ *      Subscription corresponding to this notification
+ */
+typedef CALLBACK_API_C( void , FNSubscriptionProcPtr )(FNMessage message, OptionBits flags, void *refcon, FNSubscriptionRef subscription);
+typedef STACK_UPP_TYPE(FNSubscriptionProcPtr)                   FNSubscriptionUPP;
+/*
+ *  NewFNSubscriptionUPP()
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.1 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.1 and later
+ *    Non-Carbon CFM:   available as macro/inline
+ */
+extern FNSubscriptionUPP
+NewFNSubscriptionUPP(FNSubscriptionProcPtr userRoutine)       AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER;
+
+/*
+ *  DisposeFNSubscriptionUPP()
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.1 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.1 and later
+ *    Non-Carbon CFM:   available as macro/inline
+ */
+extern void
+DisposeFNSubscriptionUPP(FNSubscriptionUPP userUPP)           AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER;
+
+/*
+ *  InvokeFNSubscriptionUPP()
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.1 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.1 and later
+ *    Non-Carbon CFM:   available as macro/inline
+ */
+extern void
+InvokeFNSubscriptionUPP(
+  FNMessage          message,
+  OptionBits         flags,
+  void *             refcon,
+  FNSubscriptionRef  subscription,
+  FNSubscriptionUPP  userUPP)                                 AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER;
+
+#if __MACH__
+  #ifdef __cplusplus
+    inline FNSubscriptionUPP                                    NewFNSubscriptionUPP(FNSubscriptionProcPtr userRoutine) { return userRoutine; }
+    inline void                                                 DisposeFNSubscriptionUPP(FNSubscriptionUPP) { }
+    inline void                                                 InvokeFNSubscriptionUPP(FNMessage message, OptionBits flags, void * refcon, FNSubscriptionRef subscription, FNSubscriptionUPP userUPP) { (*userUPP)(message, flags, refcon, subscription); }
+  #else
+    #define NewFNSubscriptionUPP(userRoutine)                   ((FNSubscriptionUPP)userRoutine)
+    #define DisposeFNSubscriptionUPP(userUPP)
+    #define InvokeFNSubscriptionUPP(message, flags, refcon, subscription, userUPP) (*userUPP)(message, flags, refcon, subscription)
+  #endif
+#endif
+
+/*
+ *  FNSubscribe()
+ *  
+ *  Summary:
+ *    Subscribe to change notifications for the specified directory.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.1
+ *  
+ *  Parameters:
+ *    
+ *    directoryRef:
+ *      Directory for which the caller wants notifications
+ *    
+ *    callback:
+ *      Function to call back when a notification arrives
+ *    
+ *    refcon:
+ *      User state carried with the subscription
+ *    
+ *    flags:
+ *      Options for future use (specify kNilOptions, or one of the
+ *      FNSubscriptionOptions)
+ *    
+ *    subscription:
+ *      Subscription token for subsequent query or unsubscription
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.1 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.1 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FNSubscribe(const FSRef *directoryRef, FNSubscriptionUPP callback, void *refcon, OptionBits flags, FNSubscriptionRef *subscription) AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER;
+
+
+/*
+ *  FNSubscribeByPath()
+ *  
+ *  Summary:
+ *    Subscribe to change notifications for the specified directory.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.1
+ *  
+ *  Parameters:
+ *    
+ *    directoryPath:
+ *      Directory for which the caller wants notifications
+ *    
+ *    callback:
+ *      Function to call back when a notification arrives
+ *    
+ *    refcon:
+ *      User state carried with the subscription
+ *    
+ *    flags:
+ *      Options for future use (specify kNilOptions, or one of the
+ *      FNSubscriptionOptions)
+ *    
+ *    subscription:
+ *      Subscription token for subsequent query or unsubscription
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.1 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.1 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FNSubscribeByPath(const UInt8 *directoryPath, FNSubscriptionUPP callback, void *refcon, OptionBits flags, FNSubscriptionRef *subscription) AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER;
+
+
+/*
+ *  FNUnsubscribe()
+ *  
+ *  Summary:
+ *    Release a subscription which is no longer needed.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.1
+ *  
+ *  Parameters:
+ *    
+ *    subscription:
+ *      Subscription previously returned from FNSubscribe or
+ *      FNSubscribeForPath
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.1 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.1 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FNUnsubscribe(FNSubscriptionRef subscription) AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER;
+
+
+/*
+ *  FNGetDirectoryForSubscription()
+ *  
+ *  Summary:
+ *    Fetch the directory for which this subscription was originally
+ *    entered. There is no path variant because paths are fragile, and
+ *    the path may have changed.  If the caller does not care about
+ *    this subtlety, she can call FSRefMakePath to get a path from the
+ *    returned ref.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.1
+ *  
+ *  Parameters:
+ *    
+ *    subscription:
+ *      Subscription previously returned from FNSubscribe or
+ *      FNSubscribeForPath
+ *    
+ *    ref:
+ *      Directory for which this subscription was created
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.1 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.1 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FNGetDirectoryForSubscription(FNSubscriptionRef subscription, FSRef *ref) AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER;
+
+
+
+/* Async Volume Operation Status return values*/
+enum {
+  kAsyncMountInProgress         = 1,
+  kAsyncMountComplete           = 2,
+  kAsyncUnmountInProgress       = 3,
+  kAsyncUnmountComplete         = 4,
+  kAsyncEjectInProgress         = 5,
+  kAsyncEjectComplete           = 6
+};
+
+
+typedef UInt32                          FSMountStatus;
+typedef UInt32                          FSEjectStatus;
+typedef UInt32                          FSUnmountStatus;
+typedef struct OpaqueFSVolumeOperation*  FSVolumeOperation;
+typedef CALLBACK_API_C( void , FSVolumeMountProcPtr )(FSVolumeOperation volumeOp, void *clientData, OSStatus err, FSVolumeRefNum mountedVolumeRefNum);
+typedef CALLBACK_API_C( void , FSVolumeUnmountProcPtr )(FSVolumeOperation volumeOp, void *clientData, OSStatus err, FSVolumeRefNum volumeRefNum, pid_t dissenter);
+typedef CALLBACK_API_C( void , FSVolumeEjectProcPtr )(FSVolumeOperation volumeOp, void *clientData, OSStatus err, FSVolumeRefNum volumeRefNum, pid_t dissenter);
+typedef STACK_UPP_TYPE(FSVolumeMountProcPtr)                    FSVolumeMountUPP;
+typedef STACK_UPP_TYPE(FSVolumeUnmountProcPtr)                  FSVolumeUnmountUPP;
+typedef STACK_UPP_TYPE(FSVolumeEjectProcPtr)                    FSVolumeEjectUPP;
+/*
+ *  NewFSVolumeMountUPP()
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.2 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.2 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern FSVolumeMountUPP
+NewFSVolumeMountUPP(FSVolumeMountProcPtr userRoutine)         AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;
+
+/*
+ *  NewFSVolumeUnmountUPP()
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.2 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.2 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern FSVolumeUnmountUPP
+NewFSVolumeUnmountUPP(FSVolumeUnmountProcPtr userRoutine)     AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;
+
+/*
+ *  NewFSVolumeEjectUPP()
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.2 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.2 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern FSVolumeEjectUPP
+NewFSVolumeEjectUPP(FSVolumeEjectProcPtr userRoutine)         AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;
+
+/*
+ *  DisposeFSVolumeMountUPP()
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.2 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.2 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern void
+DisposeFSVolumeMountUPP(FSVolumeMountUPP userUPP)             AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;
+
+/*
+ *  DisposeFSVolumeUnmountUPP()
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.2 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.2 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern void
+DisposeFSVolumeUnmountUPP(FSVolumeUnmountUPP userUPP)         AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;
+
+/*
+ *  DisposeFSVolumeEjectUPP()
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.2 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.2 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern void
+DisposeFSVolumeEjectUPP(FSVolumeEjectUPP userUPP)             AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;
+
+/*
+ *  InvokeFSVolumeMountUPP()
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.2 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.2 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern void
+InvokeFSVolumeMountUPP(
+  FSVolumeOperation  volumeOp,
+  void *             clientData,
+  OSStatus           err,
+  FSVolumeRefNum     mountedVolumeRefNum,
+  FSVolumeMountUPP   userUPP)                                 AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;
+
+/*
+ *  InvokeFSVolumeUnmountUPP()
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.2 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.2 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern void
+InvokeFSVolumeUnmountUPP(
+  FSVolumeOperation   volumeOp,
+  void *              clientData,
+  OSStatus            err,
+  FSVolumeRefNum      volumeRefNum,
+  pid_t               dissenter,
+  FSVolumeUnmountUPP  userUPP)                                AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;
+
+/*
+ *  InvokeFSVolumeEjectUPP()
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.2 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.2 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern void
+InvokeFSVolumeEjectUPP(
+  FSVolumeOperation  volumeOp,
+  void *             clientData,
+  OSStatus           err,
+  FSVolumeRefNum     volumeRefNum,
+  pid_t              dissenter,
+  FSVolumeEjectUPP   userUPP)                                 AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;
+
+#if __MACH__
+  #ifdef __cplusplus
+    inline FSVolumeMountUPP                                     NewFSVolumeMountUPP(FSVolumeMountProcPtr userRoutine) { return userRoutine; }
+    inline FSVolumeUnmountUPP                                   NewFSVolumeUnmountUPP(FSVolumeUnmountProcPtr userRoutine) { return userRoutine; }
+    inline FSVolumeEjectUPP                                     NewFSVolumeEjectUPP(FSVolumeEjectProcPtr userRoutine) { return userRoutine; }
+    inline void                                                 DisposeFSVolumeMountUPP(FSVolumeMountUPP) { }
+    inline void                                                 DisposeFSVolumeUnmountUPP(FSVolumeUnmountUPP) { }
+    inline void                                                 DisposeFSVolumeEjectUPP(FSVolumeEjectUPP) { }
+    inline void                                                 InvokeFSVolumeMountUPP(FSVolumeOperation volumeOp, void * clientData, OSStatus err, FSVolumeRefNum mountedVolumeRefNum, FSVolumeMountUPP userUPP) { (*userUPP)(volumeOp, clientData, err, mountedVolumeRefNum); }
+    inline void                                                 InvokeFSVolumeUnmountUPP(FSVolumeOperation volumeOp, void * clientData, OSStatus err, FSVolumeRefNum volumeRefNum, pid_t dissenter, FSVolumeUnmountUPP userUPP) { (*userUPP)(volumeOp, clientData, err, volumeRefNum, dissenter); }
+    inline void                                                 InvokeFSVolumeEjectUPP(FSVolumeOperation volumeOp, void * clientData, OSStatus err, FSVolumeRefNum volumeRefNum, pid_t dissenter, FSVolumeEjectUPP userUPP) { (*userUPP)(volumeOp, clientData, err, volumeRefNum, dissenter); }
+  #else
+    #define NewFSVolumeMountUPP(userRoutine)                    ((FSVolumeMountUPP)userRoutine)
+    #define NewFSVolumeUnmountUPP(userRoutine)                  ((FSVolumeUnmountUPP)userRoutine)
+    #define NewFSVolumeEjectUPP(userRoutine)                    ((FSVolumeEjectUPP)userRoutine)
+    #define DisposeFSVolumeMountUPP(userUPP)
+    #define DisposeFSVolumeUnmountUPP(userUPP)
+    #define DisposeFSVolumeEjectUPP(userUPP)
+    #define InvokeFSVolumeMountUPP(volumeOp, clientData, err, mountedVolumeRefNum, userUPP) (*userUPP)(volumeOp, clientData, err, mountedVolumeRefNum)
+    #define InvokeFSVolumeUnmountUPP(volumeOp, clientData, err, volumeRefNum, dissenter, userUPP) (*userUPP)(volumeOp, clientData, err, volumeRefNum, dissenter)
+    #define InvokeFSVolumeEjectUPP(volumeOp, clientData, err, volumeRefNum, dissenter, userUPP) (*userUPP)(volumeOp, clientData, err, volumeRefNum, dissenter)
+  #endif
+#endif
+
+
+/*
+ *  Discussion:
+ *    Options that can be passed to the FSMountServerVolumeCalls. These
+ *    options are not for use with the local volumes.
+ */
+enum {
+
+  /*
+   * Specify this option if you do want the volume displayed as a stand
+   * along volume in the UI.
+   */
+  kFSMountServerMarkDoNotDisplay = (1 << 0),
+
+  /*
+   * Specify this option if you want the volume mounted on the mountdir
+   * passed in instead of in it.
+   */
+  kFSMountServerMountOnMountDir = (1 << 2)
+};
+
+
+/*
+ *  Discussion:
+ *    Deprecated options that can be passed to
+ *    FSMountServerVolumeCalls.  The options will have no effect on the
+ *    OS version they are noted as deprecated on or later.
+ */
+enum {
+
+  /*
+   * Specify this option if you do not want other processes notified
+   * that this volume has been mounted.  Deprecated on Mac OS X 10.5. 
+   * Use kFSMountServerMarkDoNotDisplay instead.
+   */
+  kFSMountServerMountWithoutNotification = (1 << 1)
+};
+
+
+/*
+ *  Discussion:
+ *    Options that can be passed to the FSEjectVolume calls.
+ */
+enum {
+
+  /*
+   * Specify this option if you want the volume forcibly ejected. 
+   * Force ejecting a volume will very likely result in data loss since
+   * the volume will be ejected even if there are open files on it or
+   * other volumes that share the same device. This option should be
+   * reserved for situations such as the backing store for a volume is
+   * gone (so the data is lost regardless).
+   */
+  kFSEjectVolumeForceEject      = (1 << 0)
+};
+
+
+/*
+ *  Discussion:
+ *    Options that can be passed to the FSUnmountVolume calls.
+ */
+enum {
+
+  /*
+   * Specify this option if you want the volume forcibly unmounted. 
+   * Force unmounting a volume will very likely result in data loss
+   * since the volume will be ejected even if there are open files on
+   * it. This option should be reserved for situations such as the
+   * backing store for a volume is gone (so the data is lost
+   * regardless).
+   */
+  kFSUnmountVolumeForceUnmount  = (1 << 0)
+};
+
+/*
+ *  FSCreateVolumeOperation()
+ *  
+ *  Discussion:
+ *    This routine will return an FSVolumeOperation which can be used
+ *    for an async volume operation.  When the operation is completed
+ *    the volumeOp should be disposed of to free the memory associated
+ *    with the operation using FSDisposeVolumeOperation.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.2
+ *  
+ *  Parameters:
+ *    
+ *    volumeOp:
+ *      The new FSVolumeOperation.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.2 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSCreateVolumeOperation(FSVolumeOperation * volumeOp) AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;
+
+
+/*
+ *  FSDisposeVolumeOperation()
+ *  
+ *  Discussion:
+ *    This routine will release the memory associated with the passed
+ *    in volumeOp. It will return paramErr is the volumeOp is in use.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.2
+ *  
+ *  Parameters:
+ *    
+ *    volumeOp:
+ *      The FSVolumeOperation to release.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.2 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSDisposeVolumeOperation(FSVolumeOperation volumeOp) AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;
+
+
+/*
+ *  FSMountLocalVolumeSync()
+ *  
+ *  Discussion:
+ *    This routine will mount the disk specified by diskID at mountDir
+ *    (or the default location if mountDir is NULL).  This routine
+ *    returns after the mount is complete.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.2
+ *  
+ *  Parameters:
+ *    
+ *    diskID:
+ *      The disk to mount.
+ *    
+ *    mountDir:
+ *      Pass in NULL (currently only NULL is supported).
+ *    
+ *    mountedVolumeRefNum:
+ *      The volume ref num of the newly mounted volume.
+ *    
+ *    flags:
+ *      Options for future use.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.2 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSMountLocalVolumeSync(CFStringRef diskID, CFURLRef mountDir, FSVolumeRefNum *mountedVolumeRefNum, OptionBits flags) AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;
+
+
+/*
+ *  FSMountLocalVolumeAsync()
+ *  
+ *  Discussion:
+ *    This routine will start the process to disk specified by diskID
+ *    at mountDir (or the default location if mountDir is NULL).  If a
+ *    callback is provided the provided function will be called when
+ *    the mount operation is complete.  Once this routine returns noErr
+ *    the status of the operation can be found using
+ *    FSGetAsyncMountStatus.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.2
+ *  
+ *  Parameters:
+ *    
+ *    diskID:
+ *      The disk to mount.
+ *    
+ *    mountDir:
+ *      Pass in NULL (currently only NULL is supported).
+ *    
+ *    volumeOp:
+ *      An FSVolumeOperation returned by FSCreateVolumeOperation
+ *    
+ *    clientData:
+ *      client data associated with the operation.
+ *    
+ *    flags:
+ *      Options for future use.
+ *    
+ *    callback:
+ *      Function to call when mount is complete.
+ *    
+ *    runloop:
+ *      Runloop to run on.
+ *    
+ *    runloopMode:
+ *      Mode for runloop.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.2 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSMountLocalVolumeAsync(CFStringRef diskID, CFURLRef mountDir, FSVolumeOperation volumeOp, void *clientData, OptionBits flags, FSVolumeMountUPP callback, CFRunLoopRef runloop, CFStringRef runloopMode) AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;
+
+
+/*
+ *  FSMountServerVolumeSync()
+ *  
+ *  Discussion:
+ *    This routine will mount the server specified by url at mountDir
+ *    (or the default location if mountDir is NULL).  An optional user
+ *    and password can be passed in for authentication. If no user or
+ *    password is provided then the underlying file system will handle
+ *    authentication if required.  This routine returns after the mount
+ *    is complete.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.2
+ *  
+ *  Parameters:
+ *    
+ *    url:
+ *      The server to mount.
+ *    
+ *    mountDir:
+ *      The directory to mount the server to (default if NULL).
+ *    
+ *    user:
+ *      String to pass as user for authentication.
+ *    
+ *    password:
+ *      String to pass as password for authenticated log in.
+ *    
+ *    mountedVolumeRefNum:
+ *      The volume ref num of the newly mounted volume.
+ *    
+ *    flags:
+ *      Options for future use.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.2 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSMountServerVolumeSync(CFURLRef url, CFURLRef mountDir, CFStringRef user, CFStringRef password, FSVolumeRefNum *mountedVolumeRefNum, OptionBits flags) AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;
+
+
+/*
+ *  FSMountServerVolumeAsync()
+ *  
+ *  Discussion:
+ *    This routine will start the process to mount the server specified
+ *    by url at mountDir (or the default location if mountDir is NULL).
+ *     An optional user and password can be passed in for
+ *    authentication. If no user or password is provided then the
+ *    underlying file system will handle authentication if required. 
+ *    If a callback is provided the provided function will be called
+ *    when the mount operation is complete.  Once this routine returns
+ *    noErr the status of the operation can be found using
+ *    FSGetAsyncMountStatus.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.2
+ *  
+ *  Parameters:
+ *    
+ *    url:
+ *      The server to mount.
+ *    
+ *    mountDir:
+ *      The directory to mount the server to (default if NULL).
+ *    
+ *    user:
+ *      String to pass as user for authentication.
+ *    
+ *    password:
+ *      String to pass as password for authenticated log in.
+ *    
+ *    volumeOp:
+ *      An FSVolumeOperation returned by FSCreateVolumeOperation
+ *    
+ *    clientData:
+ *      client data associated with the operation.
+ *    
+ *    flags:
+ *      Options for future use.
+ *    
+ *    callback:
+ *      Function to call when mount is complete.
+ *    
+ *    runloop:
+ *      Runloop run on.
+ *    
+ *    runloopMode:
+ *      Mode for runloop.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.2 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSMountServerVolumeAsync(CFURLRef url, CFURLRef mountDir, CFStringRef user, CFStringRef password, FSVolumeOperation volumeOp, void *clientData, OptionBits flags, FSVolumeMountUPP callback, CFRunLoopRef runloop, CFStringRef runloopMode) AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;
+
+
+/*
+ *  FSGetAsyncMountStatus()
+ *  
+ *  Discussion:
+ *    This routine returns the current status of an asynchronous mount
+ *    operation. A return value of noErr signifies that the status
+ *    parameter has been filled with valid information.  If the status
+ *    is kAsyncMountComplete then the rest of data returned is valid. 
+ *    If the status is anything else then the volumeOpStatus and
+ *    mountedVolumeRefNum parameters are invalid (The clientData will
+ *    be ok).
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.2
+ *  
+ *  Parameters:
+ *    
+ *    volumeOp:
+ *      The async volume operation to get status about.
+ *    
+ *    status:
+ *      The status of the operation.
+ *    
+ *    volumeOpStatus:
+ *      If status is kAsyncMountComplete then this contains the
+ *      OSStatus for the operation.
+ *    
+ *    mountedVolumeRefNum:
+ *      If status is kAsyncMountComplete and volumeOpStatus is noErr
+ *      then this is the volume ref num for the newly mounted volume.
+ *    
+ *    clientData:
+ *      client data associated with the original
+ *      FSMountServerVolumeAsync operation.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.2 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSGetAsyncMountStatus(FSVolumeOperation volumeOp, FSMountStatus *status, OSStatus *volumeOpStatus, FSVolumeRefNum *mountedVolumeRefNum, void **clientData) AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;
+
+
+
+/*
+ *  FSUnmountVolumeSync()
+ *  
+ *  Discussion:
+ *    This routine unmounts the volume specified by vRefNum.  If the
+ *    volume cannot be unmounted the pid of the process which denied
+ *    the unmount will be returned in the dissenter parameter.  This
+ *    routine returns after the unmount is complete.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.2
+ *  
+ *  Parameters:
+ *    
+ *    vRefNum:
+ *      The volume reference number of the volume to unmount.
+ *    
+ *    flags:
+ *      Options for future use.
+ *    
+ *    dissenter:
+ *      pid of the process which denied the unmount if the unmount is
+ *      denied.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.2 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSUnmountVolumeSync(FSVolumeRefNum vRefNum, OptionBits flags, pid_t *dissenter) AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;
+
+
+/*
+ *  FSUnmountVolumeAsync()
+ *  
+ *  Discussion:
+ *    This routine starts the process of unmounting the volume
+ *    specified by vRefNum. If a callback is provided the provided
+ *    function will be called when the unmount operation is complete. 
+ *    Once this routine returns noErr the status of the operation can
+ *    be found using FSGetAsyncUnmountStatus.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.2
+ *  
+ *  Parameters:
+ *    
+ *    vRefNum:
+ *      The volume reference number of the volume to unmount.
+ *    
+ *    flags:
+ *      Options for future use.
+ *    
+ *    volumeOp:
+ *      An FSVolumeOperation returned by FSCreateVolumeOperation
+ *    
+ *    clientData:
+ *      client data associated with the operation.
+ *    
+ *    callback:
+ *      Function to call when unmount is complete.
+ *    
+ *    runloop:
+ *      Runloop to run on.
+ *    
+ *    runloopMode:
+ *      Mode for runloop.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.2 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSUnmountVolumeAsync(FSVolumeRefNum vRefNum, OptionBits flags, FSVolumeOperation volumeOp, void *clientData, FSVolumeUnmountUPP callback, CFRunLoopRef runloop, CFStringRef runloopMode) AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;
+
+
+/*
+ *  FSGetAsyncUnmountStatus()
+ *  
+ *  Discussion:
+ *    This routine returns the current status of an asynchronous
+ *    unmount operation. A return value of noErr signifies that the
+ *    status parameter has been filled with valid information.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.2
+ *  
+ *  Parameters:
+ *    
+ *    volumeOp:
+ *      The async volume operation to get status about.
+ *    
+ *    status:
+ *      The status of the operation.
+ *    
+ *    volumeOpStatus:
+ *      If status is kAsyncUnmountComplete then this contains the
+ *      OSStatus for the operation.
+ *    
+ *    volumeRefNum:
+ *      volume reference number of volume being unmounted.
+ *    
+ *    dissenter:
+ *      pid of the process which denied the unmount if the unmount is
+ *      denied.
+ *    
+ *    clientData:
+ *      client data associated with the original
+ *      FSMountServerVolumeAsync operation.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.2 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSGetAsyncUnmountStatus(FSVolumeOperation volumeOp, FSUnmountStatus *status, OSStatus *volumeOpStatus, FSVolumeRefNum *volumeRefNum, pid_t *dissenter, void **clientData) AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;
+
+
+/*
+ *  FSCancelVolumeOperation()
+ *  
+ *  Discussion:
+ *    This routine will cancel and outstanding asynchronous volume
+ *    mounting operation. It currently is only supported for server
+ *    mounts.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.2
+ *  
+ *  Parameters:
+ *    
+ *    volumeOp:
+ *      The async volume operation to cancel.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.2 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSCancelVolumeOperation(FSVolumeOperation volumeOp) AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;
+
+
+/*
+ *  FSEjectVolumeSync()
+ *  
+ *  Discussion:
+ *    This routine ejects the volume specified by vRefNum.  If the
+ *    volume cannot be ejected the pid of the process which denied the
+ *    unmount will be returned in the dissenter parameter.  This
+ *    routine returns after the eject is complete.  Ejecting a volume
+ *    will result in the unmounting of other volumes on the same device.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.2
+ *  
+ *  Parameters:
+ *    
+ *    vRefNum:
+ *      The volume reference number of the volume to eject.
+ *    
+ *    flags:
+ *      Options for future use.
+ *    
+ *    dissenter:
+ *      pid of the process which denied the unmount if the eject is
+ *      denied.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.2 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSEjectVolumeSync(FSVolumeRefNum vRefNum, OptionBits flags, pid_t *dissenter) AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;
+
+
+/*
+ *  FSEjectVolumeAsync()
+ *  
+ *  Discussion:
+ *    This routine starts the process of ejecting the volume specified
+ *    by vRefNum. If a callback is provided the provided function will
+ *    be called when the eject operation is complete.  Once this
+ *    routine returns noErr the status of the operation can be found
+ *    using FSGetAsyncEjectStatus.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.2
+ *  
+ *  Parameters:
+ *    
+ *    vRefNum:
+ *      The volume reference number of the volume to eject.
+ *    
+ *    flags:
+ *      Options for future use.
+ *    
+ *    volumeOp:
+ *      An FSVolumeOperation returned by FSCreateVolumeOperation
+ *    
+ *    clientData:
+ *      client data associated with the operation.
+ *    
+ *    callback:
+ *      Function to call when eject is complete.
+ *    
+ *    runloop:
+ *      Runloop to run on.
+ *    
+ *    runloopMode:
+ *      Mode for runloop.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.2 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSEjectVolumeAsync(FSVolumeRefNum vRefNum, OptionBits flags, FSVolumeOperation volumeOp, void *clientData, FSVolumeEjectUPP callback, CFRunLoopRef runloop, CFStringRef runloopMode) AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;
+
+
+/*
+ *  FSGetAsyncEjectStatus()
+ *  
+ *  Discussion:
+ *    This routine returns the current status of an asynchronous eject
+ *    operation. A return value of noErr signifies that the status
+ *    parameter has been filled with valid information.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.2
+ *  
+ *  Parameters:
+ *    
+ *    volumeOp:
+ *      The async volume operation to get status about.
+ *    
+ *    status:
+ *      The status of the operation.
+ *    
+ *    volumeOpStatus:
+ *      If status is kAsyncEjectComplete then this contains the
+ *      OSStatus for the operation.
+ *    
+ *    volumeRefNum:
+ *      volume reference number of volume being ejected.
+ *    
+ *    dissenter:
+ *      pid of the process which denied the unmount if the eject is
+ *      denied.
+ *    
+ *    clientData:
+ *      client data associated with the original
+ *      FSMountServerVolumeAsync operation.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.2 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSGetAsyncEjectStatus(FSVolumeOperation volumeOp, FSEjectStatus *status, OSStatus *volumeOpStatus, FSVolumeRefNum *volumeRefNum, pid_t *dissenter, void **clientData) AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;
+
+
+/*
+ *  FSCopyDiskIDForVolume()
+ *  
+ *  Discussion:
+ *    This routine returns a copy of the diskID for the passed in
+ *    volume.  The caller is responsible for releasing the CFString
+ *    later.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.2
+ *  
+ *  Parameters:
+ *    
+ *    vRefNum:
+ *      FSVolumeRefNum of the target volume.
+ *    
+ *    diskID:
+ *      The diskID string associated with the target volume.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.2 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSCopyDiskIDForVolume(FSVolumeRefNum vRefNum, CFStringRef *diskID)       AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;
+
+
+/*
+ *  FSCopyURLForVolume()
+ *  
+ *  Discussion:
+ *    This routine returns a copy of the url for the passed in volume. 
+ *    The caller is responsible for releasing the CFURL later.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Parameters:
+ *    
+ *    vRefNum:
+ *      FSVolumeRefNum of the target volume.
+ *    
+ *    url:
+ *      The url associated with the target volume.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.3 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSCopyURLForVolume(FSVolumeRefNum vRefNum, CFURLRef *url)             AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER;
+
+
+/*
+ *  FSGetVolumeForDiskID()
+ *  
+ *  Discussion:
+ *    This routine returnes the FSVolumeRefNum for a given diskID.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Parameters:
+ *    
+ *    diskID:
+ *      The diskID string associated with the target volume.
+ *    
+ *    vRefNum:
+ *      FSVolumeRefNum of the volume which corresponds to the diskID.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSGetVolumeForDiskID(CFStringRef diskID, FSVolumeRefNum *vRefNum)        AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/*
+ *  FSCopyDADiskForVolume()
+ *  
+ *  Discussion:
+ *    This routine returns a copy of the diskID for the passed in
+ *    volume.  The caller is responsible for releasing the CFString
+ *    later.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Parameters:
+ *    
+ *    vRefNum:
+ *      FSVolumeRefNum of the target volume.
+ *    
+ *    disk:
+ *      The DADisk associated with the target volume.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSCopyDADiskForVolume(FSVolumeRefNum vRefNum, DADiskRef *disk)         AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/*
+ *  FSGetVolumeForDADisk()
+ *  
+ *  Discussion:
+ *    This routine returns the FSVolumeRefNum associated with the
+ *    volume referenced by the passed in DADiskRef.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Parameters:
+ *    
+ *    disk:
+ *      The DADiskRef of the target volume.
+ *    
+ *    vRefNum:
+ *      FSVolumeRefNum of the volume which corresponds to the DADiskRef.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSGetVolumeForDADisk(DADiskRef disk, FSVolumeRefNum *vRefNum)          AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/* File Operation routines*/
+
+typedef struct __FSFileOperation*       FSFileOperationRef;
+typedef UInt32                          FSFileOperationStage;
+
+/*
+ *  FSFileOperationClientContext
+ *  
+ *  Discussion:
+ *    Structure containing the user-defined data and callbacks for
+ *    FSFileOperation client contextual data.
+ */
+struct FSFileOperationClientContext {
+
+  /*
+   * The version number of the structure type being passed in as a
+   * parameter to FSCopyObjectAsync or FSMoveObjectAsync function.
+   * Valid version number is currently 0.
+   */
+  CFIndex             version;
+
+  /*
+   * An arbitrary pointer to client-defined data, which can be
+   * associated with the operation and is passed to the callbacks.
+   */
+  void *              info;
+
+  /*
+   * The callback used to add a retain for the operation on the info
+   * pointer for the life of the operation, and may be used for
+   * temporary references the operation needs to take. This callback
+   * returns the actual info pointer to store in the operation, almost
+   * always just the pointer passed as the parameter.
+   */
+  CFAllocatorRetainCallBack  retain;
+
+  /*
+   * The callback used to remove a retain previously added for the
+   * operation on the info pointer.
+   */
+  CFAllocatorReleaseCallBack  release;
+
+  /*
+   * The callback used to create a descriptive string representation of
+   * the info pointer (or the data pointed to by the info pointer) for
+   * debugging purposes. This is used by the CFCopyDescription()
+   * function.
+   */
+  CFAllocatorCopyDescriptionCallBack  copyDescription;
+};
+typedef struct FSFileOperationClientContext FSFileOperationClientContext;
+
+/*
+ *  FSFileOperationStatusProcPtr
+ *  
+ *  Discussion:
+ *    Callback function which is called to return status of an
+ *    operation.  It will be called when an operation changes stages
+ *    (including failing due to an error) or as updated information is
+ *    available limited by the statusChangeInterval of the operation.
+ *  
+ *  Parameters:
+ *    
+ *    fileOp:
+ *      Operation receiving the callback.
+ *    
+ *    currentItem:
+ *      FSRef to item operation is currently processing.  If the
+ *      operation is complete then currentItem refers to the target
+ *      item (the new item corresponding to the source item in the
+ *      destination directory).
+ *    
+ *    stage:
+ *      Current stage of the operation.
+ *    
+ *    error:
+ *      Either noErr or an error value which caused the operation to
+ *      fail.
+ *    
+ *    statusDictionary:
+ *      A CFDictionary with more detailed status information.  The
+ *      caller should not release this item.  If the item is needed
+ *      beyond the scope of the callback then it needs to be copied.
+ *    
+ *    info:
+ *      The info pointer passed in by the client.
+ */
+typedef CALLBACK_API_C( void , FSFileOperationStatusProcPtr )(FSFileOperationRef fileOp, const FSRef *currentItem, FSFileOperationStage stage, OSStatus error, CFDictionaryRef statusDictionary, void *info);
+
+/*
+ *  FSPathFileOperationStatusProcPtr
+ *  
+ *  Discussion:
+ *    Callback function which is called to return status of an
+ *    operation.  It will be called when an operation changes stages
+ *    (including failing due to an error) or as updated information is
+ *    available limited by the statusChangeInterval of the operation.
+ *  
+ *  Parameters:
+ *    
+ *    fileOp:
+ *      Operation receiving the callback.
+ *    
+ *    currentItem:
+ *      The UTF-8 path for the item operation is currently processing. 
+ *      The caller should not release this item.  If the item is needed
+ *      beyond the scope of the callback then it needs to be copied. 
+ *      If the operation is complete then currentItem refers to the
+ *      target item (the new item corresponding to the source item in
+ *      the destination directory).
+ *    
+ *    stage:
+ *      Current stage of the operation.
+ *    
+ *    error:
+ *      Either noErr or an error value which caused the operation to
+ *      fail.
+ *    
+ *    statusDictionary:
+ *      A CFDictionary with more detailed status information.  The
+ *      caller should not release this item.  If the item is needed
+ *      beyond the scope of the callback then it needs to be copied.
+ *    
+ *    info:
+ *      The info pointer passed in by the client.
+ */
+typedef CALLBACK_API_C( void , FSPathFileOperationStatusProcPtr )(FSFileOperationRef fileOp, const char *currentItem, FSFileOperationStage stage, OSStatus error, CFDictionaryRef statusDictionary, void *info);
+
+/*
+ *  FSFileOperationOptions
+ *  
+ *  Discussion:
+ *    Set of flags that can be passed into an FSMoveObject(A)sync or
+ *    FSCopyObject(A)sync call.
+ */
+enum {
+
+  /*
+   * Use the default options - no overwrite, fail if any source item
+   * cannot be read, cross volume moves OK.
+   */
+  kFSFileOperationDefaultOptions = 0,
+
+  /*
+   * Replace an item in the destDir that has the same name as an item
+   * being moved/copied there.
+   */
+  kFSFileOperationOverwrite     = 0x01,
+
+  /*
+   * Skip items that cannot be read and continue copying/moving instead
+   * of failing the operation.
+   */
+  kFSFileOperationSkipSourcePermissionErrors = 0x02,
+
+  /*
+   * Do not perform a copy/delete to move an item across volume
+   * boundries - fail the operation instead.
+   */
+  kFSFileOperationDoNotMoveAcrossVolumes = 0x04,
+
+  /*
+   * Skip the preflight for a directory move/copy.  This will limit the
+   * status information that can be returned since the totals will not
+   * be calculated.
+   */
+  kFSFileOperationSkipPreflight = 0x08
+};
+
+
+/*
+ *  FSFileOperationStage
+ *  
+ *  Discussion:
+ *    The stage corresponds to the state of an asynchronous File
+ *    Operation.  The stage is reported in the operation's status
+ *    callback or as part of an FSFileOperationCopyStatus call.
+ */
+enum {
+
+  /*
+   * Operation has not started yet.
+   */
+  kFSOperationStageUndefined    = 0,
+
+  /*
+   * Operation is calulating sizes and number of items involved in the
+   * operation.
+   */
+  kFSOperationStagePreflighting = 1,
+
+  /*
+   * Operation is in progress.
+   */
+  kFSOperationStageRunning      = 2,
+
+  /*
+   * Operation is done.
+   */
+  kFSOperationStageComplete     = 3
+};
+
+/* FSFileOperation status dictionary keys*/
+/*
+ *  kFSOperationTotalBytesKey
+ *  
+ *  Discussion:
+ *    This value associated with this key in a status dictionary
+ *    returns the total number of bytes that will be moved/copied by
+ *    this operation as a CFNumber.  This value is not available for a
+ *    directory operation if kFSFileOperationSkipPreflight was
+ *    specified.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern const CFStringRef kFSOperationTotalBytesKey                   AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+/*
+ *  kFSOperationBytesCompleteKey
+ *  
+ *  Discussion:
+ *    This value associated with this key in a status dictionary
+ *    returns the number of bytes that have been moved/copied by this
+ *    operation at the time the status call was made as a CFNumber. 
+ *    During the preflight stage this value represents the currently
+ *    known number of bytes that will be copied/moved.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern const CFStringRef kFSOperationBytesCompleteKey                AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+/*
+ *  kFSOperationBytesRemainingKey
+ *  
+ *  Discussion:
+ *    This value associated with this key in a status dictionary
+ *    returns the number of bytes that remain to be moved/copied by
+ *    this operation at the time the status call was made as a
+ *    CFNumber.  This value is not available for a directory operation
+ *    if kFSFileOperationSkipPreflight was specified.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern const CFStringRef kFSOperationBytesRemainingKey               AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+/*
+ *  kFSOperationTotalObjectsKey
+ *  
+ *  Discussion:
+ *    This value associated with this key in a status dictionary
+ *    returns the total number of objects that will be moved/copied by
+ *    this operation as a CFNumber.  This value is not available for a
+ *    directory operation if kFSFileOperationSkipPreflight was
+ *    specified.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern const CFStringRef kFSOperationTotalObjectsKey                 AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+/*
+ *  kFSOperationObjectsCompleteKey
+ *  
+ *  Discussion:
+ *    This value associated with this key in a status dictionary
+ *    returns the number of objects that have been moved/copied by this
+ *    operation at the time the status call was made as a CFNumber. 
+ *    During the preflight stage this value represents the currently
+ *    known number of objects that will be copied/moved.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern const CFStringRef kFSOperationObjectsCompleteKey              AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+/*
+ *  kFSOperationObjectsRemainingKey
+ *  
+ *  Discussion:
+ *    This value associated with this key in a status dictionary
+ *    returns the number of objects that remain to be moved/copied by
+ *    this operation at the time the status call was made as a
+ *    CFNumber.  This value is not available for a directory operation
+ *    if kFSFileOperationSkipPreflight was specified.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern const CFStringRef kFSOperationObjectsRemainingKey             AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+/*
+ *  kFSOperationTotalUserVisibleObjectsKey
+ *  
+ *  Discussion:
+ *    This value associated with this key in a status dictionary
+ *    returns the total number of user visibleobjects that will be
+ *    moved/copied by this operation as a CFNumber.  This value is not
+ *    available for a directory operation if
+ *    kFSFileOperationSkipPreflight was specified.  A packaged
+ *    application is one user visible object even though it is made up
+ *    of multiple files and directories.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern const CFStringRef kFSOperationTotalUserVisibleObjectsKey      AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+/*
+ *  kFSOperationUserVisibleObjectsCompleteKey
+ *  
+ *  Discussion:
+ *    This value associated with this key in a status dictionary
+ *    returns the number of user visible objects that have been
+ *    moved/copied by this operation at the time the status call was
+ *    made as a CFNumber.  During the preflight stage this value
+ *    represents the currently known number of objects that will be
+ *    copied/moved.  A packaged application is one user visible object
+ *    even though it is made up of multiple files and directories.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern const CFStringRef kFSOperationUserVisibleObjectsCompleteKey   AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+/*
+ *  kFSOperationUserVisibleObjectsRemainingKey
+ *  
+ *  Discussion:
+ *    This value associated with this key in a status dictionary
+ *    returns the number of user visible objects that remain to be
+ *    moved/copied by this operation at the time the status call was
+ *    made as a CFNumber.  This value is not available for a directory
+ *    operation if kFSFileOperationSkipPreflight was specified.  A
+ *    packaged application is one user visible object even though it is
+ *    made up of multiple files and directories.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern const CFStringRef kFSOperationUserVisibleObjectsRemainingKey  AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+/*
+ *  kFSOperationThroughputKey
+ *  
+ *  Discussion:
+ *    This value associated with this key in a status dictionary
+ *    returns the current throughput for the operation in bytes per
+ *    second as a CFNumber.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern const CFStringRef kFSOperationThroughputKey                   AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+/*
+ *  FSCopyObjectSync()
+ *  
+ *  Discussion:
+ *    This routine will copy the source object into the destination
+ *    directory.  The source object can be a file or directory.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Parameters:
+ *    
+ *    source:
+ *      The source object to copy.
+ *    
+ *    destDir:
+ *      The destination directory for the copy.
+ *    
+ *    destName:
+ *      The name for the new object in the destination directory.  Pass
+ *      NULL to use the source object name.
+ *    
+ *    target:
+ *      Upon successful completion a ref to the newly created object. 
+ *      If source is a directory then target will be the corresponding
+ *      object in the destination directory.
+ *    
+ *    options:
+ *      One or more FSFileOperation flags
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSCopyObjectSync(const FSRef *source, const FSRef *destDir, CFStringRef destName, FSRef *target, OptionBits options) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/*
+ *  FSMoveObjectSync()
+ *  
+ *  Discussion:
+ *    This routine will move the source object into the destination
+ *    directory.  The source object can be a file or directory.  If a
+ *    destName is provided then the object will be renamed as well as
+ *    moved.  By default a move across volumes will result in a copy
+ *    and deletion of the original source.  The
+ *    kFSFileOperationDoNotMoveAcrossVolumes flag will cause cross
+ *    volume moves to do nothing and return an error.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Parameters:
+ *    
+ *    source:
+ *      The source object to move.
+ *    
+ *    destDir:
+ *      The destination directory for the move.
+ *    
+ *    destName:
+ *      The name for the object in the destination directory.  Pass
+ *      NULL to use the source object name.
+ *    
+ *    target:
+ *      Upon successful completion a ref to the object in its new
+ *      location.  If source is a directory then target will be the
+ *      corresponding object in the destination directory.
+ *    
+ *    options:
+ *      One or more FSFileOperation flags
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSMoveObjectSync(const FSRef *source, const FSRef *destDir, CFStringRef destName, FSRef *target, OptionBits options) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/*
+ *  FSMoveObjectToTrashSync()
+ *  
+ *  Discussion:
+ *    This routine will move the source object into the trash.  The
+ *    source object can be a file or directory.  If the volume the
+ *    source object resides on does not support a trash folder then
+ *    this call will return an error (this is the same circumstance
+ *    that triggers the delete immediately behavior in the Finder).
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.5
+ *  
+ *  Parameters:
+ *    
+ *    source:
+ *      The source object to move to the trash.
+ *    
+ *    target:
+ *      Upon successful completion a ref the object in the trash.  If
+ *      source is a directory then target will be the corresponding
+ *      object in the destination directory.
+ *    
+ *    options:
+ *      One or more FSFileOperation flags
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.5 and later in CoreServices.framework
+ *    CarbonLib:        not available
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSMoveObjectToTrashSync(const FSRef *source, FSRef *target, OptionBits options) AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
+
+
+/*
+ *  FSPathCopyObjectSync()
+ *  
+ *  Discussion:
+ *    This routine will copy the source object into the destination
+ *    directory.  The source object can be a file or directory.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Parameters:
+ *    
+ *    sourcePath:
+ *      The UTF-8 path string of the source object to copy.
+ *    
+ *    destDirPath:
+ *      The UTF-8 path of the destination directory for the copy.
+ *    
+ *    destName:
+ *      The name for the new object in the destination directory.  Pass
+ *      NULL to use the source object name.
+ *    
+ *    targetPath:
+ *      A pointer to a char * to allow returning the path to the newly
+ *      created object.  The path is allocated using malloc and it is
+ *      the caller's responsibility to free.  The pointer will be set
+ *      to NULL if the copy failed.
+ *    
+ *    options:
+ *      One or more FSFileOperation flags
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSPathCopyObjectSync(const char *sourcePath, const char *destDirPath, CFStringRef destName, char **targetPath, OptionBits options) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/*
+ *  FSPathMoveObjectSync()
+ *  
+ *  Discussion:
+ *    This routine will move the source object into the destination
+ *    directory.  The source object can be a file or directory.  If a
+ *    destName is provided then the object will be renamed as well as
+ *    moved.  By default a move across volumes will result in a copy
+ *    and deletion of the original source.  The
+ *    kFSFileOperationDoNotMoveAcrossVolumes flag will cause cross
+ *    volume moves to do nothing and return an error.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Parameters:
+ *    
+ *    sourcePath:
+ *      The UTF-8 path string of the source object to move.
+ *    
+ *    destDirPath:
+ *      The UTF-8 path of the destination directory for the move.
+ *    
+ *    destName:
+ *      The name for the moved object in the destination directory. 
+ *      Pass NULL to use the source object name.
+ *    
+ *    targetPath:
+ *      A pointer to a char * to allow returning the path to the newly
+ *      created object.  The path is allocated using malloc and it is
+ *      the caller's responsibility to free.  The pointer will be set
+ *      to NULL if the move failed.
+ *    
+ *    options:
+ *      One or more FSFileOperation flags
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSPathMoveObjectSync(const char *sourcePath, const char *destDirPath, CFStringRef destName, char **targetPath, OptionBits options) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/*
+ *  FSPathMoveObjectToTrashSync()
+ *  
+ *  Discussion:
+ *    This routine will move the source object into the trash.  The
+ *    source object can be a file or directory.  If the volume the
+ *    source object resides on does not support a trash folder then
+ *    this call will return an error (this is the same circumstance
+ *    that triggers the delete immediately behavior in the Finder).
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.5
+ *  
+ *  Parameters:
+ *    
+ *    sourcePath:
+ *      The UTF-8 path string of the source object to move.
+ *    
+ *    targetPath:
+ *      A pointer to a char * to allow returning the path to the newly
+ *      created object.  The path is allocated using malloc and it is
+ *      the caller's responsibility to free.  The pointer will be set
+ *      to NULL if the move failed.
+ *    
+ *    options:
+ *      One or more FSFileOperation flags
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.5 and later in CoreServices.framework
+ *    CarbonLib:        not available
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSPathMoveObjectToTrashSync(const char *sourcePath, char **targetPath, OptionBits options) AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
+
+
+/*
+ *  FSFileOperationGetTypeID()
+ *  
+ *  Discussion:
+ *    This routine will return the CFTypeID for the FSFileOpeation type.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Result:
+ *    the CFTypeID for the FSFileOperation type.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern CFTypeID  FSFileOperationGetTypeID(void)               AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/*
+ *  FSFileOperationCreate()
+ *  
+ *  Discussion:
+ *    This routine will create an FSFileOperation for use with either
+ *    FSCopyObjectAsync or FSMoveObjectAsync.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Parameters:
+ *    
+ *    alloc:
+ *      The CFAllocator to use.  Pass NULL for the default allocator.
+ *  
+ *  Result:
+ *    A reference to the newly created object or NULL if the creation
+ *    failed.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern FSFileOperationRef  FSFileOperationCreate(CFAllocatorRef alloc) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/*
+ *  FSFileOperationScheduleWithRunLoop()
+ *  
+ *  Discussion:
+ *    Schedule the given operation on the specified runloop and mode. A
+ *    FSFileOperation can be scheduled on multiple runloop/mode
+ *    combinations. An opertion must be scheduled on at least one
+ *    runloop.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Parameters:
+ *    
+ *    fileOp:
+ *      The FSFileOperation to schedule.
+ *    
+ *    runLoop:
+ *      The runLoop on which to schedule the operation.  Must be
+ *      non-NULL.
+ *    
+ *    runLoopMode:
+ *      The mode on which to schedule the operation.  Must be non-NULL.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSFileOperationScheduleWithRunLoop(FSFileOperationRef fileOp, CFRunLoopRef runLoop, CFStringRef runLoopMode) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/*
+ *  FSFileOperationUnscheduleFromRunLoop()
+ *  
+ *  Discussion:
+ *    Unschedule the given operation from the specified runloop and
+ *    mode.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Parameters:
+ *    
+ *    fileOp:
+ *      The FSFileOperation to unschedule.
+ *    
+ *    runLoop:
+ *      The runLoop from which to unschedule the operation.  Must be
+ *      non-NULL.
+ *    
+ *    runLoopMode:
+ *      The mode from which to unschedule the operation.  Must be
+ *      non-NULL.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSFileOperationUnscheduleFromRunLoop(FSFileOperationRef fileOp, CFRunLoopRef runLoop, CFStringRef runLoopMode) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/*
+ *  FSCopyObjectAsync()
+ *  
+ *  Discussion:
+ *    This routine will start an asynchronous copy of the object
+ *    specified by source to the directory specified by destDir.  If
+ *    destName is provided then the new object will be renamed to
+ *    destName.  If destName is not provided then the name of the
+ *    source object will be used.  Status callbacks will occur on one
+ *    of the runloop/mode combinations that the operation was scheduled
+ *    on (and is running).
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Parameters:
+ *    
+ *    fileOp:
+ *      The FSFileOperation object created for this operation.
+ *    
+ *    source:
+ *      The source object to copy.
+ *    
+ *    destDir:
+ *      The destination directory for the copy.
+ *    
+ *    destName:
+ *      The name for the new object in the destination directory.  Pass
+ *      NULL to use the source object name.
+ *    
+ *    flags:
+ *      One or more FSFileOperation flags
+ *    
+ *    callback:
+ *      An optional FSFileOperationStatusProcPtr which will be called
+ *      with status updates as the copy proceeds.
+ *    
+ *    statusChangeInterval:
+ *      The minimum time between callbacks within a single stage of an
+ *      operation.
+ *    
+ *    clientContext:
+ *      Client contextual information to associate with this operation.
+ *       The info pointer will be passed to status callbacks.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSCopyObjectAsync(FSFileOperationRef fileOp, const FSRef *source, const FSRef *destDir, CFStringRef destName, OptionBits flags, FSFileOperationStatusProcPtr callback, CFTimeInterval statusChangeInterval, FSFileOperationClientContext *clientContext) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/*
+ *  FSMoveObjectAsync()
+ *  
+ *  Discussion:
+ *    This routine will start an asynchronous move of the object
+ *    specified by source to the directory specified by destDir.  If
+ *    destName is provided then the new object will be renamed to
+ *    destName.  If destName is not provided then the name of the
+ *    source object will be used.  Status callbacks will occur on one
+ *    of the runloop/mode combinations that the operation was scheduled
+ *    on (and is running).  By default a move across volumes will
+ *    result in a copy and deletion of the original source. The
+ *    kFSFileOperationDoNotMoveAcrossVolumes flag will cause cross
+ *    volume moves to do nothing and return an error.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Parameters:
+ *    
+ *    fileOp:
+ *      The FSFileOperation object created for this operation.
+ *    
+ *    source:
+ *      The source object to move.
+ *    
+ *    destDir:
+ *      The destination directory for the move.
+ *    
+ *    destName:
+ *      The name for the object in the destination directory.  Pass
+ *      NULL to leave the name unchanged.
+ *    
+ *    flags:
+ *      One or more FSFileOperation flags
+ *    
+ *    callback:
+ *      An optional FSFileOperationStatusProcPtr which will be called
+ *      with status updates as the copy proceeds.
+ *    
+ *    statusChangeInterval:
+ *      The minimum time between callbacks within a single stage of an
+ *      operation.
+ *    
+ *    clientContext:
+ *      Client contextual information to associate with this operation.
+ *       The info pointer will be passed to status callbacks.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSMoveObjectAsync(FSFileOperationRef fileOp, const FSRef *source, const FSRef *destDir, CFStringRef destName, OptionBits flags, FSFileOperationStatusProcPtr callback, CFTimeInterval statusChangeInterval, FSFileOperationClientContext *clientContext) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/*
+ *  FSMoveObjectToTrashAsync()
+ *  
+ *  Discussion:
+ *    This routine will start an asynchronous move of the object
+ *    specified by source to the trash.  If the volume the source
+ *    object resides on does not support a trash folder then the
+ *    operation will return an error (this is the same circumstance
+ *    that triggers the delete immediately behavior in the Finder).
+ *    Status callbacks will occur on one of the runloop/mode
+ *    combinations that the operation was scheduled on (and is
+ *    running).   Upon successul complettion of the operation the last
+ *    currentItem (from either the last status callback or retrieved by
+ *    FSFileOperationCopyStatus) will be object in the trash.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.5
+ *  
+ *  Parameters:
+ *    
+ *    fileOp:
+ *      The FSFileOperation object created for this operation.
+ *    
+ *    source:
+ *      The source object to move.
+ *    
+ *    flags:
+ *      One or more FSFileOperation flags
+ *    
+ *    callback:
+ *      An optional FSFileOperationStatusProcPtr which will be called
+ *      with status updates as the move proceeds.
+ *    
+ *    statusChangeInterval:
+ *      The minimum time between callbacks within a single stage of an
+ *      operation.
+ *    
+ *    clientContext:
+ *      Client contextual information to associate with this operation.
+ *       The info pointer will be passed to status callbacks.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.5 and later in CoreServices.framework
+ *    CarbonLib:        not available
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSMoveObjectToTrashAsync(FSFileOperationRef fileOp, const FSRef *source, OptionBits flags, FSFileOperationStatusProcPtr callback, CFTimeInterval statusChangeInterval, FSFileOperationClientContext *clientContext) AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
+
+
+/*
+ *  FSPathCopyObjectAsync()
+ *  
+ *  Discussion:
+ *    This routine will start an asynchronous copy of the object
+ *    specified by source to the directory specified by destDir.  If
+ *    destName is provided then the new object will be renamed to
+ *    destName.  If destName is not provided then the name of the
+ *    source object will be used.  Status callbacks will occur on one
+ *    of the runloop/mode combinations that the operation was scheduled
+ *    on (and is running).
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Parameters:
+ *    
+ *    fileOp:
+ *      The FSFileOperation object created for this operation.
+ *    
+ *    sourcePath:
+ *      The UTF-8 path string of the source object to copy.
+ *    
+ *    destDirPath:
+ *      The UTF-8 path of the destination directory for the copy.
+ *    
+ *    destName:
+ *      The name for the new object in the destination directory.  Pass
+ *      NULL to use the source object name.
+ *    
+ *    flags:
+ *      One or more FSFileOperation flags
+ *    
+ *    callback:
+ *      An optional FSPathFileOperationStatusProcPtr which will be
+ *      called with status updates as the copy proceeds.
+ *    
+ *    statusChangeInterval:
+ *      The minimum time between callbacks within a single stage of an
+ *      operation.
+ *    
+ *    clientContext:
+ *      Client contextual information to associate with this operation.
+ *       The info pointer will be passed to status callbacks.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSPathCopyObjectAsync(FSFileOperationRef fileOp, const char *sourcePath, const char *destDirPath, CFStringRef destName, OptionBits flags, FSPathFileOperationStatusProcPtr callback, CFTimeInterval statusChangeInterval, FSFileOperationClientContext *clientContext) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/*
+ *  FSPathMoveObjectAsync()
+ *  
+ *  Discussion:
+ *    This routine will start an asynchronous move of the object
+ *    specified by source to the directory specified by destDir.  If
+ *    destName is provided then the new object will be renamed to
+ *    destName.  If destName is not provided then the name of the
+ *    source object will be used.  Status callbacks will occur on one
+ *    of the runloop/mode combinations that the operation was scheduled
+ *    on (and is running).  By default a move across volumes will
+ *    result in a copy and deletion of the original source. The
+ *    kFSFileOperationDoNotMoveAcrossVolumes flag will cause cross
+ *    volume moves to do nothing and return an error.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Parameters:
+ *    
+ *    fileOp:
+ *      The FSFileOperation object created for this operation.
+ *    
+ *    sourcePath:
+ *      The UTF-8 path string of the source object to move.
+ *    
+ *    destDirPath:
+ *      The UTF-8 path of the destination directory for the move.
+ *    
+ *    destName:
+ *      The name for the object in the destination directory.  Pass
+ *      NULL to leave the name unchanged.
+ *    
+ *    flags:
+ *      One or more FSFileOperation flags
+ *    
+ *    callback:
+ *      An optional FSPathFileOperationStatusProcPtr which will be
+ *      called with status updates as the move proceeds.
+ *    
+ *    statusChangeInterval:
+ *      The minimum time between callbacks within a single stage of an
+ *      operation.
+ *    
+ *    clientContext:
+ *      Client contextual information to associate with this operation.
+ *       The info pointer will be passed to status callbacks.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSPathMoveObjectAsync(FSFileOperationRef fileOp, const char *sourcePath, const char *destDirPath, CFStringRef destName, OptionBits flags, FSPathFileOperationStatusProcPtr callback, CFTimeInterval statusChangeInterval, FSFileOperationClientContext *clientContext) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/*
+ *  FSPathMoveObjectToTrashAsync()
+ *  
+ *  Discussion:
+ *    This routine will start an asynchronous move of the object
+ *    specified by source to the trash.  If the volume the source
+ *    object resides on does not support a trash folder then this call
+ *    will return an error (this is the same circumstance that triggers
+ *    the delete immediately behavior in the Finder). Status callbacks
+ *    will occur on one of the runloop/mode combinations that the
+ *    operation was scheduled on (and is running).  Note that the
+ *    object may be renamed when placed in the trash.  Upon successful
+ *    completion of the operation the last currentItem (from either the
+ *    last status callback or retrieved by
+ *    FSPathFileOperationCopyStatus) will be object in the trash.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.5
+ *  
+ *  Parameters:
+ *    
+ *    fileOp:
+ *      The FSFileOperation object created for this operation.
+ *    
+ *    sourcePath:
+ *      The UTF-8 path string of the source object to move.
+ *    
+ *    flags:
+ *      One or more FSFileOperation flags
+ *    
+ *    callback:
+ *      An optional FSPathFileOperationStatusProcPtr which will be
+ *      called with status updates as the move proceeds.
+ *    
+ *    statusChangeInterval:
+ *      The minimum time between callbacks within a single stage of an
+ *      operation.
+ *    
+ *    clientContext:
+ *      Client contextual information to associate with this operation.
+ *       The info pointer will be passed to status callbacks.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.5 and later in CoreServices.framework
+ *    CarbonLib:        not available
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSPathMoveObjectToTrashAsync(FSFileOperationRef fileOp, const char *sourcePath, OptionBits flags, FSPathFileOperationStatusProcPtr callback, CFTimeInterval statusChangeInterval, FSFileOperationClientContext *clientContext) AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
+
+
+/*
+ *  FSFileOperationCancel()
+ *  
+ *  Discussion:
+ *    Cancels the specified FSFileOperation. This makes the operation
+ *    ineligible to run on any runloop.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Parameters:
+ *    
+ *    fileOp:
+ *      The FSFileOperation to cancel.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSFileOperationCancel(FSFileOperationRef fileOp) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/*
+ *  FSFileOperationCopyStatus()
+ *  
+ *  Discussion:
+ *    This routine returns the current status of an FSFileOperation. 
+ *    The status dictionary must be released by the caller.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Parameters:
+ *    
+ *    fileOp:
+ *      The FSFileOperation from which to retrieve status information.
+ *    
+ *    currentItem:
+ *      FSRef to item operation is currently processing.  If the
+ *      operation is complete then currentItem refers to the target
+ *      item (the new item corresponding to the source item in the
+ *      destination directory).
+ *    
+ *    stage:
+ *      current stage of the operation.
+ *    
+ *    error:
+ *      Either noErr or an error value which caused the operation to
+ *      fail.
+ *    
+ *    statusDictionary:
+ *      A CFDictionary with more detailed status information. The
+ *      caller is responsible for releasing the object when done with
+ *      it.
+ *    
+ *    info:
+ *      The info pointer passed in by the client.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSFileOperationCopyStatus(FSFileOperationRef fileOp, FSRef *currentItem, FSFileOperationStage *stage, OSStatus *error, CFDictionaryRef *statusDictionary, void **info) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/*
+ *  FSPathFileOperationCopyStatus()
+ *  
+ *  Discussion:
+ *    This routine returns the current status of an FSFileOperation. 
+ *    The status dictionary must be released by the caller.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Parameters:
+ *    
+ *    fileOp:
+ *      The FSFileOperation from which to retrieve status information.
+ *    
+ *    currentItem:
+ *      A path to the item operation is currently processing.  The
+ *      caller is responsible for calling free to dispose of the path
+ *      string.  If the operation is complete then currentItem refers
+ *      to the target item (the new item corresponding to the source
+ *      item in the destination directory).
+ *    
+ *    stage:
+ *      current stage of the operation.
+ *    
+ *    error:
+ *      Either noErr or an error value which caused the operation to
+ *      fail.
+ *    
+ *    statusDictionary:
+ *      A CFDictionary with more detailed status information.  The
+ *      caller is responsible for releasing the object when done with
+ *      it.
+ *    
+ *    info:
+ *      The info pointer passed in by the client.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSPathFileOperationCopyStatus(FSFileOperationRef fileOp, char **currentItem, FSFileOperationStage *stage, OSStatus *error, CFDictionaryRef *statusDictionary, void **info) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/* String conversion functions*/
+/*
+ *  FSCreateStringFromHFSUniStr()
+ *  
+ *  Discussion:
+ *    Creates a CFString from a HFSUniStr255.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Parameters:
+ *    
+ *    alloc:
+ *      The CFAllocator to use.  Pass NULL for the default allocator.
+ *    
+ *    uniStr:
+ *      A HFSUniStr255 to use as the source value for the CFString.
+ *  
+ *  Result:
+ *    A CFStringRef created from the HFSUniStr255 or NULL.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern CFStringRef  FSCreateStringFromHFSUniStr(CFAllocatorRef alloc, const HFSUniStr255 *uniStr) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/*
+ *  FSGetHFSUniStrFromString()
+ *  
+ *  Discussion:
+ *    Convert a CFString into a HFSUniStr255.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Parameters:
+ *    
+ *    theString:
+ *      The CFString to convert to a HFSUniStr255.
+ *    
+ *    uniStr:
+ *      A pointer to a HFSUniStr255 which will be filled in using the
+ *      value of theString.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSGetHFSUniStrFromString(CFStringRef theString, HFSUniStr255 *uniStr)  AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/* ACL support*/
+
+/*
+ *  FSFileSecurityGetTypeID()
+ *  
+ *  Discussion:
+ *    This routine will return the CFTypeID for the FSFileSecurity type.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Result:
+ *    the CFTypeID for the FSFilSecurity type.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern CFTypeID  FSFileSecurityGetTypeID(void)                AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/*
+ *  FSFileSecurityCreate()
+ *  
+ *  Discussion:
+ *    This routine will create an FSFileSecurity object.  The object
+ *    should be released using CFRelease when it is no longer needed.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Parameters:
+ *    
+ *    alloc:
+ *      The CFAllocator to use.  Pass NULL for the default allocator.
+ *  
+ *  Result:
+ *    A reference to the newly created object or NULL if the creation
+ *    failed.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern FSFileSecurityRef  FSFileSecurityCreate(CFAllocatorRef alloc) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/*
+ *  FSFileSecurityCreateWithFSPermissionInfo()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern FSFileSecurityRef  FSFileSecurityCreateWithFSPermissionInfo(CFAllocatorRef alloc, const FSPermissionInfo *permissions) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/*
+ *  FSFileSecurityRefCreateCopy()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern FSFileSecurityRef  FSFileSecurityRefCreateCopy(CFAllocatorRef alloc, FSFileSecurityRef fileSec) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/* get and set properties*/
+
+/*
+ *  FSFileSecurityGetOwnerUUID()
+ *  
+ *  Discussion:
+ *    This routine will get the owner UUID associated with the passed
+ *    in FSFileSecurityRef.  In there is no owner UUID property
+ *    associated with the FSFileSecurity object then
+ *    errFSPropertyNotValid will be returned.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Parameters:
+ *    
+ *    fileSec:
+ *      A reference to the FSFileSecurity object to get the owner UUID
+ *      from.
+ *    
+ *    owner:
+ *      A pointer to storage for the owner UUID associated with fileSec.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSFileSecurityGetOwnerUUID(FSFileSecurityRef fileSec, CFUUIDBytes *owner)   AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/*
+ *  FSFileSecuritySetOwnerUUID()
+ *  
+ *  Discussion:
+ *    This routine will set the owner UUID associated with the passed
+ *    in FSFileSecurityRef.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Parameters:
+ *    
+ *    fileSec:
+ *      A reference to the FSFileSecurity object to set the owner UUID
+ *      for.
+ *    
+ *    owner:
+ *      The UUID to set as the owner UUID associated with fileSec.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSFileSecuritySetOwnerUUID(FSFileSecurityRef fileSec, const CFUUIDBytes *owner)   AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/*
+ *  FSFileSecurityGetGroupUUID()
+ *  
+ *  Discussion:
+ *    This routine will get the group UUID associated with the passed
+ *    in FSFileSecurityRef.  In there is no group UUID property
+ *    associated with the FSFileSecurity object then
+ *    errFSPropertyNotValid will be returned.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Parameters:
+ *    
+ *    fileSec:
+ *      A reference to the FSFileSecurity object to get the group UUID
+ *      from.
+ *    
+ *    group:
+ *      A pointer to storage for the owner UUID associated with fileSec.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSFileSecurityGetGroupUUID(FSFileSecurityRef fileSec, CFUUIDBytes *group)   AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/*
+ *  FSFileSecuritySetGroupUUID()
+ *  
+ *  Discussion:
+ *    This routine will set the group UUID associated with the passed
+ *    in FSFileSecurityRef.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Parameters:
+ *    
+ *    fileSec:
+ *      A reference to the FSFileSecurity object to set the group UUID
+ *      for.
+ *    
+ *    group:
+ *      The UUID to set as the group UUID associated with fileSec.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSFileSecuritySetGroupUUID(FSFileSecurityRef fileSec, const CFUUIDBytes *group)   AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/*
+ *  FSFileSecurityCopyAccessControlList()
+ *  
+ *  Discussion:
+ *    This routine will copy the acl_t associated with the passed in
+ *    FSFileSecurityRef.  The accessControlList returned by this
+ *    routine is a copy and must be released using acl_free.  The
+ *    accessControlList is an acl_t and is meant to be manipulated
+ *    using the acl calls defined in <sys/acl.h>.   If there is no acl
+ *    property associated with the FSFileSecurity object then
+ *    errFSPropertyNotValid will be returned.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Parameters:
+ *    
+ *    fileSec:
+ *      A reference to the FSFileSecurity object to set the group for.
+ *    
+ *    accessControlList:
+ *      A pointer to storage for the acl_t associated with fileSec.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSFileSecurityCopyAccessControlList(FSFileSecurityRef fileSec, acl_t *accessControlList) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/*
+ *  FSFileSecuritySetAccessControlList()
+ *  
+ *  Discussion:
+ *    This routine will set the acl associated with the passed in
+ *    FSFileSecurityRef. To request removal of an ACL from a filesystem
+ *    object pass in kFSFileSecurityRemoveACL as the accessControlList
+ *    and set the fileSec on the target object using FSSetCatalogInfo. 
+ *    Setting the accessControlList to NULL will result in the property
+ *    being unset.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Parameters:
+ *    
+ *    fileSec:
+ *      A reference to the FSFileSecurity object to set the group for.
+ *    
+ *    accessControlList:
+ *      The acl_t to set as the acl associated with fileSec.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSFileSecuritySetAccessControlList(FSFileSecurityRef fileSec, acl_t accessControlList) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/*
+ *  FSFileSecurityGetOwner()
+ *  
+ *  Discussion:
+ *    This routine will get the owner uid associated with the passed in
+ *    FSFileSecurityRef.  In there is no owner property associated with
+ *    the FSFileSecurity object then errFSPropertyNotValid will be
+ *    returned.  Note that this value is not the owner UUID which is
+ *    returned by FSFileSecurityGetOwnerUUID.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Parameters:
+ *    
+ *    fileSec:
+ *      A reference to the FSFileSecurity object to get the owner from.
+ *    
+ *    owner:
+ *      A pointer to storage for the owner uid associated with fileSec.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSFileSecurityGetOwner(FSFileSecurityRef fileSec, UInt32 *owner)       AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/*
+ *  FSFileSecuritySetOwner()
+ *  
+ *  Discussion:
+ *    This routine will set the owner uid associated with the passed in
+ *    FSFileSecurityRef.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Parameters:
+ *    
+ *    fileSec:
+ *      A reference to the FSFileSecurity object to set the owner for.
+ *    
+ *    owner:
+ *      The uid to set as the owner associated with fileSec.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSFileSecuritySetOwner(FSFileSecurityRef fileSec, UInt32 owner)       AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/*
+ *  FSFileSecurityGetGroup()
+ *  
+ *  Discussion:
+ *    This routine will get the group gid associated with the passed in
+ *    FSFileSecurityRef.  In there is no group property associated with
+ *    the FSFileSecurity object then errFSPropertyNotValid will be
+ *    returned.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Parameters:
+ *    
+ *    fileSec:
+ *      A reference to the FSFileSecurity object to get the owner from.
+ *    
+ *    group:
+ *      A pointer to storage for the group gid associated with fileSec.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSFileSecurityGetGroup(FSFileSecurityRef fileSec, UInt32 *group)       AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/*
+ *  FSFileSecuritySetGroup()
+ *  
+ *  Discussion:
+ *    This routine will set the group gid associated with the passed in
+ *    FSFileSecurityRef.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Parameters:
+ *    
+ *    fileSec:
+ *      A reference to the FSFileSecurity object to set the group for.
+ *    
+ *    group:
+ *      The gid to set as the group associated with fileSec.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSFileSecuritySetGroup(FSFileSecurityRef fileSec, UInt32 group)       AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/*
+ *  FSFileSecurityGetMode()
+ *  
+ *  Discussion:
+ *    This routine will get the mode associated with the passed in
+ *    FSFileSecurityRef.  In there is no mode property associated with
+ *    the FSFileSecurity object then errFSPropertyNotValid will be
+ *    returned.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Parameters:
+ *    
+ *    fileSec:
+ *      A reference to the FSFileSecurity object to set the group for.
+ *    
+ *    mode:
+ *      A pointer to storage for the mode associated with fileSec.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSFileSecurityGetMode(FSFileSecurityRef fileSec, UInt16 *mode)         AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+/*
+ *  FSFileSecuritySetMode()
+ *  
+ *  Discussion:
+ *    This routine will set the mode associated with the passed in
+ *    FSFileSecurityRef.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Parameters:
+ *    
+ *    fileSec:
+ *      A reference to the FSFileSecurity object to set the group for.
+ *    
+ *    mode:
+ *      The mode to set as the mode associated with fileSec.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.4 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSFileSecuritySetMode(FSFileSecurityRef fileSec, UInt16 mode)         AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;
+
+
+
+enum {
+                                        /* old names for ioPosMode flags */
+  pleaseCacheBit                = 4,    /* old name of kFSPleaseCacheBit */
+  pleaseCacheMask               = 0x0010,
+  noCacheBit                    = 5,    /* old name of kFSNoCacheBit  */
+  noCacheMask                   = 0x0020,
+  rdVerifyBit                   = 6,    /* old name of kFSRdVerifyBit */
+  rdVerifyMask                  = 0x0040,
+  rdVerify                      = 64,   /* old name of rdVerifyMask */
+  forceReadBit                  = 6,    /* old name of kFSForceReadBit */
+  forceReadMask                 = 0x0040,
+  newLineBit                    = 7,    /* old name of kFSNewLineBit */
+  newLineMask                   = 0x0080,
+  newLineCharMask               = 0xFF00 /* old name of kFSNewLineCharMask */
+};
+
+
+/* mapping codes (ioObjType) for MapName & MapID */
+enum {
+  kOwnerID2Name                 = 1,
+  kGroupID2Name                 = 2,
+  kOwnerName2ID                 = 3,
+  kGroupName2ID                 = 4,    /* types of oj object to be returned (ioObjType) for _GetUGEntry */
+  kReturnNextUser               = 1,
+  kReturnNextGroup              = 2,
+  kReturnNextUG                 = 3
+};
+
+/* vcbFlags bits */
+enum {
+  kVCBFlagsIdleFlushBit         = 3,    /* Set if volume should be flushed at idle time */
+  kVCBFlagsIdleFlushMask        = 0x0008,
+  kVCBFlagsHFSPlusAPIsBit       = 4,    /* Set if volume implements HFS Plus APIs itself (not via emulation) */
+  kVCBFlagsHFSPlusAPIsMask      = 0x0010,
+  kVCBFlagsHardwareGoneBit      = 5,    /* Set if disk driver returned a hardwareGoneErr to Read or Write */
+  kVCBFlagsHardwareGoneMask     = 0x0020,
+  kVCBFlagsVolumeDirtyBit       = 15,   /* Set if volume information has changed since the last FlushVol */
+  kVCBFlagsVolumeDirtyMask      = 0x8000
+};
+
+/* ioVAtrb bits returned by PBHGetVInfo and PBXGetVolInfo */
+enum {
+  kioVAtrbDefaultVolumeBit      = 5,    /* Set if the volume is the default volume */
+  kioVAtrbDefaultVolumeMask     = 0x0020,
+  kioVAtrbFilesOpenBit          = 6,    /* Set if there are open files or iterators */
+  kioVAtrbFilesOpenMask         = 0x0040,
+  kioVAtrbHardwareLockedBit     = 7,    /* Set if volume is locked by a hardware setting */
+  kioVAtrbHardwareLockedMask    = 0x0080,
+  kioVAtrbSoftwareLockedBit     = 15,   /* Set if volume is locked by software */
+  kioVAtrbSoftwareLockedMask    = 0x8000
+};
+
+/* ioFlAttrib bits returned by PBGetCatInfo */
+enum {
+                                        /* file and directory attributes in ioFlAttrib */
+  kioFlAttribLockedBit          = 0,    /* Set if file or directory is locked */
+  kioFlAttribLockedMask         = 0x01,
+  kioFlAttribResOpenBit         = 2,    /* Set if resource fork is open */
+  kioFlAttribResOpenMask        = 0x04,
+  kioFlAttribDataOpenBit        = 3,    /* Set if data fork is open */
+  kioFlAttribDataOpenMask       = 0x08,
+  kioFlAttribDirBit             = 4,    /* Set if this is a directory */
+  kioFlAttribDirMask            = 0x10,
+  ioDirFlg                      = 4,    /* Set if this is a directory (old name) */
+  ioDirMask                     = 0x10,
+  kioFlAttribCopyProtBit        = 6,    /* Set if AppleShare server "copy-protects" the file */
+  kioFlAttribCopyProtMask       = 0x40,
+  kioFlAttribFileOpenBit        = 7,    /* Set if file (either fork) is open */
+  kioFlAttribFileOpenMask       = 0x80, /* ioFlAttrib for directories only */
+  kioFlAttribInSharedBit        = 2,    /* Set if the directory is within a shared area of the directory hierarchy */
+  kioFlAttribInSharedMask       = 0x04,
+  kioFlAttribMountedBit         = 3,    /* Set if the directory is a share point that is mounted by some user */
+  kioFlAttribMountedMask        = 0x08,
+  kioFlAttribSharePointBit      = 5,    /* Set if the directory is a share point */
+  kioFlAttribSharePointMask     = 0x20
+};
+
+/* ioFCBFlags bits returned by PBGetFCBInfo */
+/* IMPORTANT: These ioFCBFlags bit constants are for the SInt16 FCBPBRec.ioFCBFlags field returned */
+/* by PBGetFCBInfoSync and PBGetFCBInfoAsync. Do not use them with the FSForkInfo.flags */
+/* field returned by the FSGetForkCBInfo, PBGetForkCBInfoSync and PBGetForkCBInfoAsyn functions. */
+enum {
+  kioFCBWriteBit                = 8,    /* Data can be written to this file */
+  kioFCBWriteMask               = 0x0100,
+  kioFCBResourceBit             = 9,    /* This file is a resource fork */
+  kioFCBResourceMask            = 0x0200,
+  kioFCBWriteLockedBit          = 10,   /* File has a locked byte range */
+  kioFCBWriteLockedMask         = 0x0400,
+  kioFCBLargeFileBit            = 11,   /* File may grow beyond 2GB; cache uses file blocks, not bytes */
+  kioFCBLargeFileMask           = 0x0800,
+  kioFCBSharedWriteBit          = 12,   /* File is open for shared write access */
+  kioFCBSharedWriteMask         = 0x1000,
+  kioFCBFileLockedBit           = 13,   /* File is locked (write-protected) */
+  kioFCBFileLockedMask          = 0x2000,
+  kioFCBOwnClumpBit             = 14,   /* File has clump size specified in FCB */
+  kioFCBOwnClumpMask            = 0x4000,
+  kioFCBModifiedBit             = 15,   /* File has changed since it was last flushed */
+  kioFCBModifiedMask            = 0x8000
+};
+
+/* IMPORTANT: These FSForkInfoFlags constants are for use with the FSForkInfo.flags */
+/* field returned by the FSGetForkCBInfo, PBGetForkCBInfoSync and PBGetForkCBInfoAsyn functions. */
+/* Do not use them with the FCBPBRec.ioFCBFlags field returned by PBGetFCBInfoSync and PBGetFCBInfoAsync. */
+enum {
+  kForkInfoFlagsWriteBit        = (kioFCBWriteBit - 8), /* Data can be written to this file */
+  kForkInfoFlagsWriteMask       = (1 << kForkInfoFlagsWriteBit),
+  kForkInfoFlagsResourceBit     = (kioFCBResourceBit - 8), /* This file is a resource fork */
+  kForkInfoFlagsResourceMask    = (1 << kForkInfoFlagsResourceBit),
+  kForkInfoFlagsWriteLockedBit  = (kioFCBWriteLockedBit - 8), /* File has a locked byte range */
+  kForkInfoFlagsWriteLockedMask = (1 << kForkInfoFlagsWriteLockedBit),
+  kForkInfoFlagsLargeFileBit    = (kioFCBLargeFileBit - 8), /* File may grow beyond 2GB; cache uses file blocks, not bytes */
+  kForkInfoFlagsLargeFileMask   = (1 << kForkInfoFlagsLargeFileBit),
+  kForkInfoFlagsSharedWriteBit  = (kioFCBSharedWriteBit - 8), /* File is open for shared write access */
+  kForkInfoFlagsSharedWriteMask = (1 << kForkInfoFlagsSharedWriteBit),
+  kForkInfoFlagsFileLockedBit   = (kioFCBFileLockedBit - 8), /* File is locked (write-protected) */
+  kForkInfoFlagsFileLockedMask  = (1 << kForkInfoFlagsFileLockedBit),
+  kForkInfoFlagsOwnClumpBit     = (kioFCBOwnClumpBit - 8), /* File has clump size specified in FCB */
+  kForkInfoFlagsOwnClumpMask    = (1 << kForkInfoFlagsOwnClumpBit),
+  kForkInfoFlagsModifiedBit     = (kioFCBModifiedBit - 8), /* File has changed since it was last flushed */
+  kForkInfoFlagsModifiedMask    = (1 << kForkInfoFlagsModifiedBit)
+};
+
+/* ioACUser bits returned by PBGetCatInfo */
+/* Note: you must clear ioACUser before calling PBGetCatInfo because some file systems do not use this field */
+enum {
+  kioACUserNoSeeFolderBit       = 0,    /* Set if user does not have See Folder privileges */
+  kioACUserNoSeeFolderMask      = 0x01,
+  kioACUserNoSeeFilesBit        = 1,    /* Set if user does not have See Files privileges */
+  kioACUserNoSeeFilesMask       = 0x02,
+  kioACUserNoMakeChangesBit     = 2,    /* Set if user does not have Make Changes privileges */
+  kioACUserNoMakeChangesMask    = 0x04,
+  kioACUserNotOwnerBit          = 7,    /* Set if user is not owner of the directory */
+  kioACUserNotOwnerMask         = 0x80
+};
+
+/* Folder and File values of access privileges in ioACAccess */
+enum {
+  kioACAccessOwnerBit           = 31,   /* User is owner of directory */
+  kioACAccessOwnerMask          = (int)0x80000000,
+  kioACAccessBlankAccessBit     = 28,   /* Directory has blank access privileges */
+  kioACAccessBlankAccessMask    = 0x10000000,
+  kioACAccessUserWriteBit       = 26,   /* User has write privileges */
+  kioACAccessUserWriteMask      = 0x04000000,
+  kioACAccessUserReadBit        = 25,   /* User has read privileges */
+  kioACAccessUserReadMask       = 0x02000000,
+  kioACAccessUserSearchBit      = 24,   /* User has search privileges */
+  kioACAccessUserSearchMask     = 0x01000000,
+  kioACAccessEveryoneWriteBit   = 18,   /* Everyone has write privileges */
+  kioACAccessEveryoneWriteMask  = 0x00040000,
+  kioACAccessEveryoneReadBit    = 17,   /* Everyone has read privileges */
+  kioACAccessEveryoneReadMask   = 0x00020000,
+  kioACAccessEveryoneSearchBit  = 16,   /* Everyone has search privileges */
+  kioACAccessEveryoneSearchMask = 0x00010000,
+  kioACAccessGroupWriteBit      = 10,   /* Group has write privileges */
+  kioACAccessGroupWriteMask     = 0x00000400,
+  kioACAccessGroupReadBit       = 9,    /* Group has read privileges */
+  kioACAccessGroupReadMask      = 0x00000200,
+  kioACAccessGroupSearchBit     = 8,    /* Group has search privileges */
+  kioACAccessGroupSearchMask    = 0x00000100,
+  kioACAccessOwnerWriteBit      = 2,    /* Owner has write privileges */
+  kioACAccessOwnerWriteMask     = 0x00000004,
+  kioACAccessOwnerReadBit       = 1,    /* Owner has read privileges */
+  kioACAccessOwnerReadMask      = 0x00000002,
+  kioACAccessOwnerSearchBit     = 0,    /* Owner has search privileges */
+  kioACAccessOwnerSearchMask    = 0x00000001,
+  kfullPrivileges               = 0x00070007, /* all privileges for everybody and owner*/
+  kownerPrivileges              = 0x00000007 /* all privileges for owner only*/
+};
+
+
+/*  Volume Characteristics */
+/*
+ *  FSGetVolumeParms()
+ *  
+ *  Discussion:
+ *    Returns information about the specified volume in the passed in
+ *    GetVolParmsInfoBuffer.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.5
+ *  
+ *  Parameters:
+ *    
+ *    volume:
+ *      The volume to get the information about.
+ *    
+ *    buffer:
+ *      A GetVolParmsInfoBuffer to fill out
+ *    
+ *    bufferSize:
+ *      the size of the passed in buffer
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.5 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSGetVolumeParms(FSVolumeRefNum volume, GetVolParmsInfoBuffer *buffer, ByteCount bufferSize) AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
+
+
+/*  VolumeMount */
+/*
+ *  FSGetVolumeMountInfoSize()
+ *  
+ *  Discussion:
+ *    Returns the size of the MountInfo block associated with the
+ *    specified volume.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.5
+ *  
+ *  Parameters:
+ *    
+ *    volume:
+ *      The volume to get the MountInfo size for.
+ *    
+ *    size:
+ *      The size of the buffer required to store the MountInfo data
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.5 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSGetVolumeMountInfoSize(FSVolumeRefNum volume, ByteCount *size)       AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
+
+
+/*
+ *  FSGetVolumeMountInfo()
+ *  
+ *  Discussion:
+ *    Returns the MountInfo data for the specified volume.  If the
+ *    buffer passed in is too small then errFSBadBuffer is returned and
+ *    actualSize will contain the required buffer size to hold the
+ *    MountInfo data.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.5
+ *  
+ *  Parameters:
+ *    
+ *    volume:
+ *      The volume to get the MountInfo for.
+ *    
+ *    buffer:
+ *      A pointer to the buffer to copy the MountInfo data into
+ *    
+ *    bufferSize:
+ *      The size of the buffer passed in
+ *    
+ *    actualSize:
+ *      The actual size of the MountInfo data
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.5 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSGetVolumeMountInfo(FSVolumeRefNum volume, BytePtr buffer, ByteCount bufferSize, ByteCount *actualSize) AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
+
+
+/*
+ *  FSVolumeMount()
+ *  
+ *  Discussion:
+ *    Will attempt to remount a volume using the passed in MountInfo
+ *    buffer
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.5
+ *  
+ *  Parameters:
+ *    
+ *    buffer:
+ *      A pointer to the buffer with the MountInfo data.
+ *    
+ *    mountedVolume:
+ *      the FSVolumeRefNum of the volume that was mounted
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.5 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSVolumeMount(BytePtr buffer, FSVolumeRefNum *mountedVolume)         AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
+
+
+/*  Volume flushing */
+/*
+ *  FSFlushVolume()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.5
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.5 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSFlushVolume(FSVolumeRefNum vRefNum)        AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
+
+
+/*
+ *  PBFlushVolumeSync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.5
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.5 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  PBFlushVolumeSync(FSRefParamPtr paramBlock)  AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
+
+
+/*
+ *  PBFlushVolumeAsync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.5
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.5 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  PBFlushVolumeAsync(FSRefParamPtr paramBlock) AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
+
+
+/* CopyFile */
+/*
+    PBFSCopyFile
+    Copies a file on a volume that supports the CopyFile system call (which can be
+    determined from the bHasCopyFile GetVolParms bit).
+    ->  ioCompletion    A pointer to a completion routine
+    <-  ioResult        The result code of the function
+    ->  ref             The source item to copy
+    ->  parentRef       The destination to copy to
+    ->  nameLength      Number of Unicode characters in the optional new name.  Pass in 0 to use the source name
+    ->  name            A pointer to the optional new Unicode name; Pass in NULL to use the source name
+    <-  newRef          A pointer to the FSRef for the new object; may be NULL
+*/
+/*
+ *  PBFSCopyFileSync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.5
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.5 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  PBFSCopyFileSync(FSRefParamPtr paramBlock)   AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
+
+
+/*
+ *  PBFSCopyFileAsync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.5
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.5 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  PBFSCopyFileAsync(FSRefParamPtr paramBlock)  AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
+
+
+/* Node ID Resolution */
+/*
+ *  FSResolveNodeID()
+ *  
+ *  Discussion:
+ *    Returns an FSRef to the item on volume with the specified node id.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.5
+ *  
+ *  Parameters:
+ *    
+ *    volume:
+ *      The FSVolumeRefNum of the volume the item is on
+ *    
+ *    nodeID:
+ *      The node id to resolve
+ *    
+ *    newRef:
+ *      A pointer to storage for the FSRef of the item with the
+ *      corresponding node id
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.5 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  FSResolveNodeID(FSVolumeRefNum volume, UInt32 nodeID, FSRefPtr newRef)      AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
+
+
+/*
+    ->  ioCompletion    A pointer to a completion routine
+    <-  ioResult        The result code of the function
+    ->  ioVRefNum       The FSVolumeRefNum of the volume the item is on
+    ->  ioDirID         The node id to resolve (can be file as well as a directory node id)
+    <-  newRef          A pointer to storage for the FSRef of the item with the corresponding node id
+*/
+/*
+ *  PBFSResolveNodeIDSync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.5
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.5 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  PBFSResolveNodeIDSync(FSRefParamPtr paramBlock) AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
+
+
+/*
+ *  PBFSResolveNodeIDAsync()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.5
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.5 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus  PBFSResolveNodeIDAsync(FSRefParamPtr paramBlock) AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
+
+
+/* Calls beyond this point are deprecated*/
+
+/*
+    MakeFSRef
+    Create an FSRef for an existing object specified by a combination
+    of volume refnum, parent directory, and pathname.
+    ->  ioCompletion    A pointer to a completion routine
+    <-  ioResult        The result code of the function
+    ->  ioNamePtr       A pointer to a pathname
+    ->  ioVRefNum       A volume specification
+    ->  ioDirID         A directory ID
+    <-  newRef          A pointer to an FSRef
+   This function is deprecated in Mac OS X 10.5. Use FSMakeFSRefUnicode instead.
+*/
+#if !__LP64__
+/*
+ *  FSpMakeFSRef()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  FSpMakeFSRef(const FSSpec *source, FSRef *newRef)                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/* This function is deprecated in Mac OS X 10.5. Use PBMakeFSRefUnicodeSync instead.*/
+/*
+ *  PBMakeFSRefSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  PBMakeFSRefSync(FSRefParam * paramBlock)        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/* This function is deprecated in Mac OS X 10.5. Use PBMakeFSRefUnicodeAsync instead.*/
+/*
+ *  PBMakeFSRefAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern void  PBMakeFSRefAsync(FSRefParam * paramBlock)        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/* This function is deprecated in Mac OS X 10.5. Use PBCloseForkSync instead.*/
+/*
+ *  PBCloseSync()   *** DEPRECATED ***
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBCloseSync(ParmBlkPtr paramBlock)              AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/* This function is deprecated in Mac OS X 10.5. Use PBCloseForkAsync instead.*/
+/*
+ *  PBCloseAsync()   *** DEPRECATED ***
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBCloseAsync(ParmBlkPtr paramBlock)             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/* This function is deprecated in Mac OS X 10.5. Use PBReadForkSync instead.*/
+/*
+ *  PBReadSync()   *** DEPRECATED ***
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBReadSync(ParmBlkPtr paramBlock)               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/* This function is deprecated in Mac OS X 10.5. Use PBReadForkAsync instead.*/
+/*
+ *  PBReadAsync()   *** DEPRECATED ***
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBReadAsync(ParmBlkPtr paramBlock)              AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/* This function is deprecated in Mac OS X 10.5. Use PBWriteForkSync instead.*/
+/*
+ *  PBWriteSync()   *** DEPRECATED ***
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBWriteSync(ParmBlkPtr paramBlock)              AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/* This function is deprecated in Mac OS X 10.5. Use PBWriteForkAsync instead.*/
+/*
+ *  PBWriteAsync()   *** DEPRECATED ***
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBWriteAsync(ParmBlkPtr paramBlock)             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/* This function is deprecated in Mac OS X 10.5. It was never implemented on OS X.*/
+/*
+ *  PBWaitIOComplete()   *** DEPRECATED ***
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
+ */
+extern OSErr  PBWaitIOComplete(ParmBlkPtr paramBlock, Duration timeout)           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/*  Volume Characteristics */
+/* This function is deprecated in Mac OS X 10.5. Use FSGetVolumeParms instead.*/
+/*
+ *  PBHGetVolParmsSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHGetVolParmsSync(HParmBlkPtr paramBlock)      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/* This function is deprecated in Mac OS X 10.5. Use FSGetVolumeParms instead.*/
+/*
+ *  PBHGetVolParmsAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHGetVolParmsAsync(HParmBlkPtr paramBlock)     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/*  VolumeMount */
+/* This function is deprecated in Mac OS X 10.5. Use FSGetVolumeMountInfoSize instead.*/
+/*
+ *  PBGetVolMountInfoSize()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBGetVolMountInfoSize(ParmBlkPtr paramBlock)    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/* This function is deprecated in Mac OS X 10.5. Use FSGetVolumeMountInfo instead.*/
+/*
+ *  PBGetVolMountInfo()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBGetVolMountInfo(ParmBlkPtr paramBlock)        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/* This function is deprecated in Mac OS X 10.5. Use FSVolumeMount instead.*/
+/*
+ *  PBVolumeMount()   *** DEPRECATED ***
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBVolumeMount(ParmBlkPtr paramBlock)            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/*  Volume flushing */
+/* This function is deprecated in Mac OS X 10.5. Use FSFlushVolume instead.*/
+/*
+ *  FlushVol()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  FlushVol(ConstStr63Param volName, FSVolumeRefNum vRefNum)                      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/* This function is deprecated in Mac OS X 10.5. Use PBFlushVolumeSync instead.*/
+/*
+ *  PBFlushVolSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBFlushVolSync(ParmBlkPtr paramBlock)           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/* This function is deprecated in Mac OS X 10.5. Use PBFlushVolumeAsync instead.*/
+/*
+ *  PBFlushVolAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBFlushVolAsync(ParmBlkPtr paramBlock)          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/* This function is deprecated in Mac OS X 10.5. Use PBOpenForkSync with deny pos modes instead.*/
+/*
+ *  PBHOpenDenySync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHOpenDenySync(HParmBlkPtr paramBlock)         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/* This function is deprecated in Mac OS X 10.5. Use PBOpenForkAsync with deny pos modes instead.*/
+/*
+ *  PBHOpenDenyAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHOpenDenyAsync(HParmBlkPtr paramBlock)        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/* This function is deprecated in Mac OS X 10.5. Use PBOpenForkSync with deny pos modes instead.*/
+/*
+ *  PBHOpenRFDenySync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHOpenRFDenySync(HParmBlkPtr paramBlock)       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/* This function is deprecated in Mac OS X 10.5. Use PBOpenForkAsync with deny pos modes instead.*/
+/*
+ *  PBHOpenRFDenyAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHOpenRFDenyAsync(HParmBlkPtr paramBlock)      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/* This function is deprecated in Mac OS X 10.5. Use FSGetCatalogInfo instead.*/
+/*
+ *  PBHGetDirAccessSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHGetDirAccessSync(HParmBlkPtr paramBlock)     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/* This function is deprecated in Mac OS X 10.5. Use FSGetCatalogInfo instead.*/
+/*
+ *  PBHGetDirAccessAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHGetDirAccessAsync(HParmBlkPtr paramBlock)    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/* This function is deprecated in Mac OS X 10.5. Use FSSetCatalogInfo instead.*/
+/*
+ *  PBHSetDirAccessSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHSetDirAccessSync(HParmBlkPtr paramBlock)     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/* This function is deprecated in Mac OS X 10.5. Use FSSetCatalogInfo instead.*/
+/*
+ *  PBHSetDirAccessAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHSetDirAccessAsync(HParmBlkPtr paramBlock)    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/* This function is deprecated in Mac OS X 10.5. See getpwnam() and getpwuid().*/
+/*
+ *  PBHMapIDSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHMapIDSync(HParmBlkPtr paramBlock)            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/* This function is deprecated in Mac OS X 10.5. See getpwnam() and getpwuid().*/
+/*
+ *  PBHMapIDAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHMapIDAsync(HParmBlkPtr paramBlock)           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/* This function is deprecated in Mac OS X 10.5. See getpwnam() and getpwuid().*/
+/*
+ *  PBHMapNameSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHMapNameSync(HParmBlkPtr paramBlock)          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/* This function is deprecated in Mac OS X 10.5. See getpwnam() and getpwuid().*/
+/*
+ *  PBHMapNameAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHMapNameAsync(HParmBlkPtr paramBlock)         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/* This function is deprecated in Mac OS X 10.5. Use PBFSCopyFileSync instead.*/
+/*
+ *  PBHCopyFileSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHCopyFileSync(HParmBlkPtr paramBlock)         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/* This function is deprecated in Mac OS X 10.5. Use PBFSCopyFileAsync instead.*/
+/*
+ *  PBHCopyFileAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHCopyFileAsync(HParmBlkPtr paramBlock)        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/* This function is deprecated in Mac OS X 10.5. Use FSGetCatalogInfo to get the node id.*/
+/*
+ *  PBCreateFileIDRefSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBCreateFileIDRefSync(HParmBlkPtr paramBlock)   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/* This function is deprecated in Mac OS X 10.5. Use FSGetCatalogInfo to get the node id.*/
+/*
+ *  PBCreateFileIDRefAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBCreateFileIDRefAsync(HParmBlkPtr paramBlock)  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/* This function is deprecated in Mac OS X 10.5. Use FSGetCatalogInfo to get the node id.*/
+/*
+ *  PBResolveFileIDRefSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBResolveFileIDRefSync(HParmBlkPtr paramBlock)  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/* This function is deprecated in Mac OS X 10.5. Use FSGetCatalogInfo to get the node id.*/
+/*
+ *  PBResolveFileIDRefAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBResolveFileIDRefAsync(HParmBlkPtr paramBlock) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/* This function is deprecated in Mac OS X 10.5. It is obsolete and has no replacement.*/
+/*
+ *  PBDeleteFileIDRefSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBDeleteFileIDRefSync(HParmBlkPtr paramBlock)   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/* This function is deprecated in Mac OS X 10.5. It is obsolete and has no replacement.*/
+/*
+ *  PBDeleteFileIDRefAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBDeleteFileIDRefAsync(HParmBlkPtr paramBlock)  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use FSGetVolumeInfo instead.*/
+/*
+ *  PBXGetVolInfoSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
+ */
+extern OSErr  PBXGetVolInfoSync(XVolumeParamPtr paramBlock)   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use FSGetVolumeInfo instead.*/
+/*
+ *  PBXGetVolInfoAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
+ */
+extern OSErr  PBXGetVolInfoAsync(XVolumeParamPtr paramBlock)  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBAllocateForkSync instead.*/
+/*
+ *  PBAllocateSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBAllocateSync(ParmBlkPtr paramBlock)           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBAllocateForkAsync instead.*/
+/*
+ *  PBAllocateAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBAllocateAsync(ParmBlkPtr paramBlock)          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBGetForkSizeSync instead.*/
+/*
+ *  PBGetEOFSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBGetEOFSync(ParmBlkPtr paramBlock)             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBGetForkSizeAsync instead.*/
+/*
+ *  PBGetEOFAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBGetEOFAsync(ParmBlkPtr paramBlock)            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBSetForkSizeSync instead.*/
+/*
+ *  PBSetEOFSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBSetEOFSync(ParmBlkPtr paramBlock)             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBSetForkSizeAsync instead.*/
+/*
+ *  PBSetEOFAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBSetEOFAsync(ParmBlkPtr paramBlock)            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBGetForkPositionSync instead.*/
+/*
+ *  PBGetFPosSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBGetFPosSync(ParmBlkPtr paramBlock)            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBGetForkPositionAsync instead.*/
+/*
+ *  PBGetFPosAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBGetFPosAsync(ParmBlkPtr paramBlock)           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBSetForkPositionSync instead.*/
+/*
+ *  PBSetFPosSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBSetFPosSync(ParmBlkPtr paramBlock)            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBSetForkPositionAsync instead.*/
+/*
+ *  PBSetFPosAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBSetFPosAsync(ParmBlkPtr paramBlock)           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBFlushForkSync instead.*/
+/*
+ *  PBFlushFileSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBFlushFileSync(ParmBlkPtr paramBlock)          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBFlushForkAsync instead.*/
+/*
+ *  PBFlushFileAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBFlushFileAsync(ParmBlkPtr paramBlock)         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use FSEjectVolumeSync instead.*/
+/*
+ *  PBUnmountVol()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBUnmountVol(ParmBlkPtr paramBlock)             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBCatalogSearchSync instead.*/
+/*
+ *  PBCatSearchSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBCatSearchSync(CSParamPtr paramBlock)          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBCatalogSearchAsync instead.*/
+/*
+ *  PBCatSearchAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBCatSearchAsync(CSParamPtr paramBlock)         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use FSEjectVolumeSync instead.*/
+/*
+ *  UnmountVol()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+UnmountVol(
+  ConstStr63Param   volName,       /* can be NULL */
+  FSVolumeRefNum    vRefNum)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. The routines which use the default volume concept have been deprecated.*/
+/*
+ *  HSetVol()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+HSetVol(
+  ConstStr63Param   volName,       /* can be NULL */
+  FSVolumeRefNum    vRefNum,
+  SInt32            dirID)                                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* AddDrive() was moved to Devices.h*/
+
+/* This function is deprecated in Mac OS X 10.4. Use FSCloseFork instead.*/
+/*
+ *  FSClose()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+FSClose(FSIORefNum refNum)                                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use FSReadFork instead.*/
+/*
+ *  FSRead()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+FSRead(
+  FSIORefNum   refNum,
+  SInt32 *     count,
+  void *       buffPtr)                                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use FSWriteFork instead.*/
+/*
+ *  FSWrite()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+FSWrite(
+  FSIORefNum    refNum,
+  SInt32 *      count,
+  const void *  buffPtr)                                      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use FSAllocateFork instead.*/
+/*
+ *  Allocate()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+Allocate(
+  FSIORefNum   refNum,
+  SInt32 *     count)                                         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use FSGetForkSize instead.*/
+/*
+ *  GetEOF()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+GetEOF(
+  FSIORefNum   refNum,
+  SInt32 *     logEOF)                                        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use FSSetForkSize instead.*/
+/*
+ *  SetEOF()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+SetEOF(
+  FSIORefNum   refNum,
+  SInt32       logEOF)                                        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use FSGetForkPosition instead.*/
+/*
+ *  GetFPos()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+GetFPos(
+  FSIORefNum   refNum,
+  SInt32 *     filePos)                                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use FSSetForkPosition instead.*/
+/*
+ *  SetFPos()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+SetFPos(
+  FSIORefNum   refNum,
+  SInt16       posMode,
+  SInt32       posOff)                                        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use FSGetCatalogInfo instead.*/
+/*
+ *  GetVRefNum()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+GetVRefNum(
+  FSIORefNum        fileRefNum,
+  FSVolumeRefNum *  vRefNum)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBXLockRangeSync or FSLockRange instead.*/
+/*
+ *  PBLockRangeSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+PBLockRangeSync(ParmBlkPtr paramBlock)                        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBXLockRangeAsync instead.*/
+/*
+ *  PBLockRangeAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+PBLockRangeAsync(ParmBlkPtr paramBlock)                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBXUnlockRangeSync or FSUnlockRange instead.*/
+/*
+ *  PBUnlockRangeSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+PBUnlockRangeSync(ParmBlkPtr paramBlock)                      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBXUnlockRangeAsync instead.*/
+/*
+ *  PBUnlockRangeAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+PBUnlockRangeAsync(ParmBlkPtr paramBlock)                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. The routines which use the default volume concept have been deprecated.*/
+/*
+ *  PBHSetVolSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHSetVolSync(WDPBPtr paramBlock)               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. The routines which use the default volume concept have been deprecated.*/
+/*
+ *  PBHSetVolAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHSetVolAsync(WDPBPtr paramBlock)              AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. The routines which use the default volume concept have been deprecated.*/
+/*
+ *  PBHGetVolSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHGetVolSync(WDPBPtr paramBlock)               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. The routines which use the default volume concept have been deprecated.*/
+/*
+ *  PBHGetVolAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHGetVolAsync(WDPBPtr paramBlock)              AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBMoveObjectSync instead.*/
+/*
+ *  PBCatMoveSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBCatMoveSync(CMovePBPtr paramBlock)            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBMoveObjectAsync instead.*/
+/*
+ *  PBCatMoveAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBCatMoveAsync(CMovePBPtr paramBlock)           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBCreateDirectoryUnicodeSync instead.*/
+/*
+ *  PBDirCreateSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBDirCreateSync(HParmBlkPtr paramBlock)         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBCreateDirectoryUnicodeAsync instead.*/
+/*
+ *  PBDirCreateAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBDirCreateAsync(HParmBlkPtr paramBlock)        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBGetForkCBInfoSync instead.*/
+/*
+ *  PBGetFCBInfoSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBGetFCBInfoSync(FCBPBPtr paramBlock)           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBGetForkCBInfoAsync instead.*/
+/*
+ *  PBGetFCBInfoAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBGetFCBInfoAsync(FCBPBPtr paramBlock)          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBGetCatalogInfoSync instead.*/
+/*
+ *  PBGetCatInfoSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBGetCatInfoSync(CInfoPBPtr paramBlock)         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBGetCatalogInfoAsync instead.*/
+/*
+ *  PBGetCatInfoAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBGetCatInfoAsync(CInfoPBPtr paramBlock)        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBSetCatalogInfoSync instead.*/
+/*
+ *  PBSetCatInfoSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBSetCatInfoSync(CInfoPBPtr paramBlock)         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBSetCatalogInfoAsync instead.*/
+/*
+ *  PBSetCatInfoAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBSetCatInfoAsync(CInfoPBPtr paramBlock)        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBAllocateForkSync instead.*/
+/*
+ *  PBAllocContigSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBAllocContigSync(ParmBlkPtr paramBlock)        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBAllocateForkAsync instead.*/
+/*
+ *  PBAllocContigAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBAllocContigAsync(ParmBlkPtr paramBlock)       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBSetVolumeInfoSync instead.*/
+/*
+ *  PBSetVInfoSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBSetVInfoSync(HParmBlkPtr paramBlock)          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBSetVolumeInfoAsync instead.*/
+/*
+ *  PBSetVInfoAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBSetVInfoAsync(HParmBlkPtr paramBlock)         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBGetVolumeInfoSync instead.*/
+/*
+ *  PBHGetVInfoSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHGetVInfoSync(HParmBlkPtr paramBlock)         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBGetVolumeInfoAsync instead.*/
+/*
+ *  PBHGetVInfoAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHGetVInfoAsync(HParmBlkPtr paramBlock)        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBOpenForkSync instead.*/
+/*
+ *  PBHOpenSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHOpenSync(HParmBlkPtr paramBlock)             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBOpenForkAsync instead.*/
+/*
+ *  PBHOpenAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHOpenAsync(HParmBlkPtr paramBlock)            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBOpenForkSync instead.*/
+/*
+ *  PBHOpenRFSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHOpenRFSync(HParmBlkPtr paramBlock)           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBOpenForkAsync instead.*/
+/*
+ *  PBHOpenRFAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHOpenRFAsync(HParmBlkPtr paramBlock)          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBOpenForkSync instead.*/
+/*
+ *  PBHOpenDFSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHOpenDFSync(HParmBlkPtr paramBlock)           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBOpenForkAsync instead.*/
+/*
+ *  PBHOpenDFAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHOpenDFAsync(HParmBlkPtr paramBlock)          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBCreateFileUnicodeSync instead.*/
+/*
+ *  PBHCreateSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHCreateSync(HParmBlkPtr paramBlock)           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBCreateFileUnicodeAsync instead.*/
+/*
+ *  PBHCreateAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHCreateAsync(HParmBlkPtr paramBlock)          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBDeleteObjectSync instead.*/
+/*
+ *  PBHDeleteSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHDeleteSync(HParmBlkPtr paramBlock)           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBDeleteObjectAsync instead.*/
+/*
+ *  PBHDeleteAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHDeleteAsync(HParmBlkPtr paramBlock)          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBRenameUnicodeSync instead.*/
+/*
+ *  PBHRenameSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHRenameSync(HParmBlkPtr paramBlock)           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBRenameUnicodeAsync instead.*/
+/*
+ *  PBHRenameAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHRenameAsync(HParmBlkPtr paramBlock)          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBSetCatalogInfoSync instead.*/
+/*
+ *  PBHRstFLockSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHRstFLockSync(HParmBlkPtr paramBlock)         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBSetCatalogInfoAsync instead.*/
+/*
+ *  PBHRstFLockAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHRstFLockAsync(HParmBlkPtr paramBlock)        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBSetCatalogInfoSync instead.*/
+/*
+ *  PBHSetFLockSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHSetFLockSync(HParmBlkPtr paramBlock)         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBSetCatalogInfoAsync instead.*/
+/*
+ *  PBHSetFLockAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHSetFLockAsync(HParmBlkPtr paramBlock)        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBGetCatalogInfoSync instead.*/
+/*
+ *  PBHGetFInfoSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHGetFInfoSync(HParmBlkPtr paramBlock)         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBGetCatalogInfoAsync instead.*/
+/*
+ *  PBHGetFInfoAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHGetFInfoAsync(HParmBlkPtr paramBlock)        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBSetCatalogInfoSync instead.*/
+/*
+ *  PBHSetFInfoSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHSetFInfoSync(HParmBlkPtr paramBlock)         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBSetCatalogInfoAsync instead.*/
+/*
+ *  PBHSetFInfoAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHSetFInfoAsync(HParmBlkPtr paramBlock)        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBMakeFSRefUnicodeSync instead.*/
+/*
+ *  PBMakeFSSpecSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBMakeFSSpecSync(HParmBlkPtr paramBlock)        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBMakeFSRefUnicodeAsync instead.*/
+/*
+ *  PBMakeFSSpecAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBMakeFSSpecAsync(HParmBlkPtr paramBlock)       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. The routines which use the default volume concept have been deprecated.*/
+/*
+ *  HGetVol()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+HGetVol(
+  StringPtr         volName,
+  FSVolumeRefNum *  vRefNum,
+  SInt32 *          dirID)                                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use FSOpenFork instead.*/
+/*
+ *  HOpen()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+HOpen(
+  FSVolumeRefNum     vRefNum,
+  SInt32             dirID,
+  ConstStr255Param   fileName,
+  SInt8              permission,
+  FSIORefNum *       refNum)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use FSOpenFork instead.*/
+/*
+ *  HOpenDF()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+HOpenDF(
+  FSVolumeRefNum     vRefNum,
+  SInt32             dirID,
+  ConstStr255Param   fileName,
+  SInt8              permission,
+  FSIORefNum *       refNum)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use FSOpenFork instead.*/
+/*
+ *  HOpenRF()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+HOpenRF(
+  FSVolumeRefNum     vRefNum,
+  SInt32             dirID,
+  ConstStr255Param   fileName,
+  SInt8              permission,
+  FSIORefNum *       refNum)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use FSAllocateFork instead.*/
+/*
+ *  AllocContig()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+AllocContig(
+  FSVolumeRefNum   refNum,
+  SInt32 *         count)                                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use FSCreateFileUnicode instead.*/
+/*
+ *  HCreate()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+HCreate(
+  FSVolumeRefNum     vRefNum,
+  SInt32             dirID,
+  ConstStr255Param   fileName,
+  OSType             creator,
+  OSType             fileType)                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use FSCreateDirectoryUnicode instead.*/
+/*
+ *  DirCreate()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+DirCreate(
+  FSVolumeRefNum     vRefNum,
+  SInt32             parentDirID,
+  ConstStr255Param   directoryName,
+  SInt32 *           createdDirID)                            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use FSDeleteObject instead.*/
+/*
+ *  HDelete()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+HDelete(
+  FSVolumeRefNum     vRefNum,
+  SInt32             dirID,
+  ConstStr255Param   fileName)                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use FSGetCatalogInfo instead.*/
+/*
+ *  HGetFInfo()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+HGetFInfo(
+  FSVolumeRefNum     vRefNum,
+  SInt32             dirID,
+  ConstStr255Param   fileName,
+  FInfo *            fndrInfo)                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use FSSetCatalogInfo instead.*/
+/*
+ *  HSetFInfo()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+HSetFInfo(
+  FSVolumeRefNum     vRefNum,
+  SInt32             dirID,
+  ConstStr255Param   fileName,
+  const FInfo *      fndrInfo)                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use FSSetCatalogInfo instead.*/
+/*
+ *  HSetFLock()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+HSetFLock(
+  FSVolumeRefNum     vRefNum,
+  SInt32             dirID,
+  ConstStr255Param   fileName)                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use FSSetCatalogInfo instead.*/
+/*
+ *  HRstFLock()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+HRstFLock(
+  FSVolumeRefNum     vRefNum,
+  SInt32             dirID,
+  ConstStr255Param   fileName)                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use FSRenameUnicode instead.*/
+/*
+ *  HRename()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+HRename(
+  FSVolumeRefNum     vRefNum,
+  SInt32             dirID,
+  ConstStr255Param   oldName,
+  ConstStr255Param   newName)                                 AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use FSMoveObject instead.*/
+/*
+ *  CatMove()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+CatMove(
+  FSVolumeRefNum     vRefNum,
+  SInt32             dirID,
+  ConstStr255Param   oldName,
+  SInt32             newDirID,
+  ConstStr255Param   newName)                                 AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. It was never implemented on OS X.*/
+/*
+ *  PBHGetLogInInfoSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHGetLogInInfoSync(HParmBlkPtr paramBlock)     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. It was never implemented on OS X.*/
+/*
+ *  PBHGetLogInInfoAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHGetLogInInfoAsync(HParmBlkPtr paramBlock)    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+   This function is deprecated in Mac OS X 10.4. It was never implemented on OS X.
+   Use FSMoveObjectSync instead.
+*/
+/*
+ *  PBHMoveRenameSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHMoveRenameSync(HParmBlkPtr paramBlock)       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+   This function is deprecated in Mac OS X 10.4. It was never implemented on OS X.
+   Use FSMoveObjectAsync instead.
+*/
+/*
+ *  PBHMoveRenameAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBHMoveRenameAsync(HParmBlkPtr paramBlock)      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. It was never implemented on OS X.*/
+/*
+ *  PBGetXCatInfoSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
+ */
+extern OSErr  PBGetXCatInfoSync(XCInfoPBPtr paramBlock)       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. It was never implemented on OS X.*/
+/*
+ *  PBGetXCatInfoAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
+ */
+extern OSErr  PBGetXCatInfoAsync(XCInfoPBPtr paramBlock)      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBExchangeObjectsSync instead.*/
+/*
+ *  PBExchangeFilesSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBExchangeFilesSync(HParmBlkPtr paramBlock)     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use PBExchangeObjectsAsync instead.*/
+/*
+ *  PBExchangeFilesAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBExchangeFilesAsync(HParmBlkPtr paramBlock)    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. It was never implemented on OS X.*/
+/*
+ *  PBGetForeignPrivsSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBGetForeignPrivsSync(HParmBlkPtr paramBlock)   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. It was never implemented on OS X.*/
+/*
+ *  PBGetForeignPrivsAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBGetForeignPrivsAsync(HParmBlkPtr paramBlock)  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. It was never implemented on OS X.*/
+/*
+ *  PBSetForeignPrivsSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBSetForeignPrivsSync(HParmBlkPtr paramBlock)   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. It was never implemented on OS X.*/
+/*
+ *  PBSetForeignPrivsAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBSetForeignPrivsAsync(HParmBlkPtr paramBlock)  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*  Desktop Manager  */
+#endif  /* !__LP64__ */
+
+#if !__LP64__
+enum {
+                                        /* Desktop Database, ffsGetIconMessage and fsmGetFSIconMessage icon type and size Constants */
+  kLargeIcon                    = 1,
+  kLarge4BitIcon                = 2,
+  kLarge8BitIcon                = 3,
+  kSmallIcon                    = 4,
+  kSmall4BitIcon                = 5,
+  kSmall8BitIcon                = 6,
+  kicnsIconFamily               = 239   /* Note: The 'icns' icon family record is variable sized. */
+};
+
+#endif  /* !__LP64__ */
+
+#if !__LP64__
+/*
+ *  PBDTGetPath()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.2
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBDTGetPath(DTPBPtr paramBlock)                 AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  PBDTCloseDown()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.2
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBDTCloseDown(DTPBPtr paramBlock)               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  PBDTAddIconSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.2
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBDTAddIconSync(DTPBPtr paramBlock)             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  PBDTAddIconAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.2
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBDTAddIconAsync(DTPBPtr paramBlock)            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  PBDTGetIconSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.2
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBDTGetIconSync(DTPBPtr paramBlock)             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  PBDTGetIconAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.2
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBDTGetIconAsync(DTPBPtr paramBlock)            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  PBDTGetIconInfoSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.2
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBDTGetIconInfoSync(DTPBPtr paramBlock)         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  PBDTGetIconInfoAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.2
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBDTGetIconInfoAsync(DTPBPtr paramBlock)        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  PBDTAddAPPLSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.2
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBDTAddAPPLSync(DTPBPtr paramBlock)             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  PBDTAddAPPLAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.2
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBDTAddAPPLAsync(DTPBPtr paramBlock)            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  PBDTRemoveAPPLSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.2
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBDTRemoveAPPLSync(DTPBPtr paramBlock)          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  PBDTRemoveAPPLAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.2
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBDTRemoveAPPLAsync(DTPBPtr paramBlock)         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  PBDTGetAPPLSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.2
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBDTGetAPPLSync(DTPBPtr paramBlock)             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  PBDTGetAPPLAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.2
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBDTGetAPPLAsync(DTPBPtr paramBlock)            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  PBDTSetCommentSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.2
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBDTSetCommentSync(DTPBPtr paramBlock)          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  PBDTSetCommentAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.2
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBDTSetCommentAsync(DTPBPtr paramBlock)         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  PBDTRemoveCommentSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.2
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBDTRemoveCommentSync(DTPBPtr paramBlock)       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  PBDTRemoveCommentAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.2
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBDTRemoveCommentAsync(DTPBPtr paramBlock)      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  PBDTGetCommentSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.2
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBDTGetCommentSync(DTPBPtr paramBlock)          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  PBDTGetCommentAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.2
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBDTGetCommentAsync(DTPBPtr paramBlock)         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  PBDTFlushSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.2
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBDTFlushSync(DTPBPtr paramBlock)               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  PBDTFlushAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.2
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBDTFlushAsync(DTPBPtr paramBlock)              AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  PBDTResetSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.2
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBDTResetSync(DTPBPtr paramBlock)               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  PBDTResetAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.2
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBDTResetAsync(DTPBPtr paramBlock)              AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  PBDTGetInfoSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.2
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBDTGetInfoSync(DTPBPtr paramBlock)             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  PBDTGetInfoAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.2
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBDTGetInfoAsync(DTPBPtr paramBlock)            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  PBDTOpenInform()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.2
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBDTOpenInform(DTPBPtr paramBlock)              AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  PBDTDeleteSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.2
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBDTDeleteSync(DTPBPtr paramBlock)              AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  PBDTDeleteAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.2
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBDTDeleteAsync(DTPBPtr paramBlock)             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*  FSp traps  */
+/* This function is deprecated in Mac OS X 10.4. Use FSMakeFSRefUnicode instead.*/
+/*
+ *  FSMakeFSSpec()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+FSMakeFSSpec(
+  FSVolumeRefNum     vRefNum,
+  SInt32             dirID,
+  ConstStr255Param   fileName,
+  FSSpec *           spec)                                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use FSOpenFork instead.*/
+/*
+ *  FSpOpenDF()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+FSpOpenDF(
+  const FSSpec *  spec,
+  SInt8           permission,
+  FSIORefNum *    refNum)                                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use FSOpenFork instead.*/
+/*
+ *  FSpOpenRF()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+FSpOpenRF(
+  const FSSpec *  spec,
+  SInt8           permission,
+  FSIORefNum *    refNum)                                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use FSCreateFileUnicode instead.*/
+/*
+ *  FSpCreate()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+FSpCreate(
+  const FSSpec *  spec,
+  OSType          creator,
+  OSType          fileType,
+  ScriptCode      scriptTag)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use FSCreateDirectoryUnicode instead.*/
+/*
+ *  FSpDirCreate()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+FSpDirCreate(
+  const FSSpec *  spec,
+  ScriptCode      scriptTag,
+  SInt32 *        createdDirID)                               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use FSDeleteObject instead.*/
+/*
+ *  FSpDelete()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+FSpDelete(const FSSpec * spec)                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use FSGetCatalogInfo instead.*/
+/*
+ *  FSpGetFInfo()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+FSpGetFInfo(
+  const FSSpec *  spec,
+  FInfo *         fndrInfo)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use FSSetCatalogInfo instead.*/
+/*
+ *  FSpSetFInfo()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+FSpSetFInfo(
+  const FSSpec *  spec,
+  const FInfo *   fndrInfo)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use FSSetCatalogInfo instead.*/
+/*
+ *  FSpSetFLock()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+FSpSetFLock(const FSSpec * spec)                              AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use FSSetCatalogInfo instead.*/
+/*
+ *  FSpRstFLock()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+FSpRstFLock(const FSSpec * spec)                              AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use FSRenameUnicode instead.*/
+/*
+ *  FSpRename()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+FSpRename(
+  const FSSpec *     spec,
+  ConstStr255Param   newName)                                 AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use FSMoveObject instead.*/
+/*
+ *  FSpCatMove()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+FSpCatMove(
+  const FSSpec *  source,
+  const FSSpec *  dest)                                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. Use FSExchangeObjects instead.*/
+/*
+ *  FSpExchangeFiles()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+FSpExchangeFiles(
+  const FSSpec *  source,
+  const FSSpec *  dest)                                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+
+/* This function is deprecated in Mac OS X 10.4. It was never implemented on OS X.*/
+/*
+ *  PBShareSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBShareSync(HParmBlkPtr paramBlock)             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. It was never implemented on OS X.*/
+/*
+ *  PBShareAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBShareAsync(HParmBlkPtr paramBlock)            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. It was never implemented on OS X.*/
+/*
+ *  PBUnshareSync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBUnshareSync(HParmBlkPtr paramBlock)           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. It was never implemented on OS X.*/
+/*
+ *  PBUnshareAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBUnshareAsync(HParmBlkPtr paramBlock)          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. It was never implemented on OS X.*/
+/*
+ *  PBGetUGEntrySync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBGetUGEntrySync(HParmBlkPtr paramBlock)        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* This function is deprecated in Mac OS X 10.4. It was never implemented on OS X.*/
+/*
+ *  PBGetUGEntryAsync()   *** DEPRECATED ***
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.0
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr  PBGetUGEntryAsync(HParmBlkPtr paramBlock)       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+#endif  /* !__LP64__ */
+
+#if !__LP64__
+/*
+    The PBxxx() routines are obsolete.  
+    
+    Use the PBxxxSync() or PBxxxAsync() version instead.
+*/
+#define PBGetVInfo(pb, async) ((async) ? PBGetVInfoAsync(pb) : PBGetVInfoSync(pb))
+#define PBXGetVolInfo(pb, async) ((async) ? PBXGetVolInfoAsync(pb) : PBXGetVolInfoSync(pb))
+#define PBGetVol(pb, async) ((async) ? PBGetVolAsync(pb) : PBGetVolSync(pb))
+#define PBSetVol(pb, async) ((async) ? PBSetVolAsync(pb) : PBSetVolSync(pb))
+#define PBFlushVol(pb, async) ((async) ? PBFlushVolAsync(pb) : PBFlushVolSync(pb))
+#define PBCreate(pb, async) ((async) ? PBCreateAsync(pb) : PBCreateSync(pb))
+#define PBDelete(pb, async) ((async) ? PBDeleteAsync(pb) : PBDeleteSync(pb))
+#define PBOpenDF(pb, async) ((async) ? PBOpenDFAsync(pb) : PBOpenDFSync(pb))
+#define PBOpenRF(pb, async) ((async) ? PBOpenRFAsync(pb) : PBOpenRFSync(pb))
+#define PBRename(pb, async) ((async) ? PBRenameAsync(pb) : PBRenameSync(pb))
+#define PBGetFInfo(pb, async) ((async) ? PBGetFInfoAsync(pb) : PBGetFInfoSync(pb))
+#define PBSetFInfo(pb, async) ((async) ? PBSetFInfoAsync(pb) : PBSetFInfoSync(pb))
+#define PBSetFLock(pb, async) ((async) ? PBSetFLockAsync(pb) : PBSetFLockSync(pb))
+#define PBRstFLock(pb, async) ((async) ? PBRstFLockAsync(pb) : PBRstFLockSync(pb))
+#define PBSetFVers(pb, async) ((async) ? PBSetFVersAsync(pb) : PBSetFVersSync(pb))
+#define PBAllocate(pb, async) ((async) ? PBAllocateAsync(pb) : PBAllocateSync(pb))
+#define PBGetEOF(pb, async) ((async) ? PBGetEOFAsync(pb) : PBGetEOFSync(pb))
+#define PBSetEOF(pb, async) ((async) ? PBSetEOFAsync(pb) : PBSetEOFSync(pb))
+#define PBGetFPos(pb, async) ((async) ? PBGetFPosAsync(pb) : PBGetFPosSync(pb))
+#define PBSetFPos(pb, async) ((async) ? PBSetFPosAsync(pb) : PBSetFPosSync(pb))
+#define PBFlushFile(pb, async) ((async) ? PBFlushFileAsync(pb) : PBFlushFileSync(pb))
+#define PBCatSearch(pb, async) ((async) ? PBCatSearchAsync(pb) : PBCatSearchSync(pb))
+#define PBOpenWD(pb, async) ((async) ? PBOpenWDAsync(pb) : PBOpenWDSync(pb))
+#define PBCloseWD(pb, async) ((async) ? PBCloseWDAsync(pb) : PBCloseWDSync(pb))
+#define PBHSetVol(pb, async) ((async) ? PBHSetVolAsync(pb) : PBHSetVolSync(pb))
+#define PBHGetVol(pb, async) ((async) ? PBHGetVolAsync(pb) : PBHGetVolSync(pb))
+#define PBCatMove(pb, async) ((async) ? PBCatMoveAsync(pb) : PBCatMoveSync(pb))
+#define PBDirCreate(pb, async) ((async) ? PBDirCreateAsync(pb) : PBDirCreateSync(pb))
+#define PBGetWDInfo(pb, async) ((async) ? PBGetWDInfoAsync(pb) : PBGetWDInfoSync(pb))
+#define PBGetFCBInfo(pb, async) ((async) ? PBGetFCBInfoAsync(pb) : PBGetFCBInfoSync(pb))
+#define PBGetCatInfo(pb, async) ((async) ? PBGetCatInfoAsync(pb) : PBGetCatInfoSync(pb))
+#define PBSetCatInfo(pb, async) ((async) ? PBSetCatInfoAsync(pb) : PBSetCatInfoSync(pb))
+#define PBAllocContig(pb, async) ((async) ? PBAllocContigAsync(pb) : PBAllocContigSync(pb))
+#define PBLockRange(pb, async) ((async) ? PBLockRangeAsync(pb) : PBLockRangeSync(pb))
+#define PBUnlockRange(pb, async) ((async) ? PBUnlockRangeAsync(pb) : PBUnlockRangeSync(pb))
+#define PBSetVInfo(pb, async) ((async) ? PBSetVInfoAsync(pb) : PBSetVInfoSync(pb))
+#define PBHGetVInfo(pb, async) ((async) ? PBHGetVInfoAsync(pb) : PBHGetVInfoSync(pb))
+#define PBHOpen(pb, async) ((async) ? PBHOpenAsync(pb) : PBHOpenSync(pb))
+#define PBHOpenRF(pb, async) ((async) ? PBHOpenRFAsync(pb) : PBHOpenRFSync(pb))
+#define PBHOpenDF(pb, async) ((async) ? PBHOpenDFAsync(pb) : PBHOpenDFSync(pb))
+#define PBHCreate(pb, async) ((async) ? PBHCreateAsync(pb) : PBHCreateSync(pb))
+#define PBHDelete(pb, async) ((async) ? PBHDeleteAsync(pb) : PBHDeleteSync(pb))
+#define PBHRename(pb, async) ((async) ? PBHRenameAsync(pb) : PBHRenameSync(pb))
+#define PBHRstFLock(pb, async) ((async) ? PBHRstFLockAsync(pb) : PBHRstFLockSync(pb))
+#define PBHSetFLock(pb, async) ((async) ? PBHSetFLockAsync(pb) : PBHSetFLockSync(pb))
+#define PBHGetFInfo(pb, async) ((async) ? PBHGetFInfoAsync(pb) : PBHGetFInfoSync(pb))
+#define PBHSetFInfo(pb, async) ((async) ? PBHSetFInfoAsync(pb) : PBHSetFInfoSync(pb))
+#define PBMakeFSSpec(pb, async) ((async) ? PBMakeFSSpecAsync(pb) : PBMakeFSSpecSync(pb))
+#define PBHGetVolParms(pb, async) ((async) ? PBHGetVolParmsAsync(pb) : PBHGetVolParmsSync(pb))
+#define PBHGetLogInInfo(pb, async) ((async) ? PBHGetLogInInfoAsync(pb) : PBHGetLogInInfoSync(pb))
+#define PBHGetDirAccess(pb, async) ((async) ? PBHGetDirAccessAsync(pb) : PBHGetDirAccessSync(pb))
+#define PBHSetDirAccess(pb, async) ((async) ? PBHSetDirAccessAsync(pb) : PBHSetDirAccessSync(pb))
+#define PBHMapID(pb, async) ((async) ? PBHMapIDAsync(pb) : PBHMapIDSync(pb))
+#define PBHMapName(pb, async) ((async) ? PBHMapNameAsync(pb) : PBHMapNameSync(pb))
+#define PBHCopyFile(pb, async) ((async) ? PBHCopyFileAsync(pb) : PBHCopyFileSync(pb))
+#define PBHMoveRename(pb, async) ((async) ? PBHMoveRenameAsync(pb) : PBHMoveRenameSync(pb))
+#define PBHOpenDeny(pb, async) ((async) ? PBHOpenDenyAsync(pb) : PBHOpenDenySync(pb))
+#define PBHOpenRFDeny(pb, async) ((async) ? PBHOpenRFDenyAsync(pb) : PBHOpenRFDenySync(pb))
+#define PBExchangeFiles(pb, async) ((async) ? PBExchangeFilesAsync(pb) : PBExchangeFilesSync(pb))
+#define PBCreateFileIDRef(pb, async) ((async) ? PBCreateFileIDRefAsync(pb) : PBCreateFileIDRefSync(pb))
+#define PBResolveFileIDRef(pb, async) ((async) ? PBResolveFileIDRefAsync(pb) : PBResolveFileIDRefSync(pb))
+#define PBDeleteFileIDRef(pb, async) ((async) ? PBDeleteFileIDRefAsync(pb) : PBDeleteFileIDRefSync(pb))
+#define PBGetForeignPrivs(pb, async) ((async) ? PBGetForeignPrivsAsync(pb) : PBGetForeignPrivsSync(pb))
+#define PBSetForeignPrivs(pb, async) ((async) ? PBSetForeignPrivsAsync(pb) : PBSetForeignPrivsSync(pb))
+#define PBDTAddIcon(pb, async) ((async) ? PBDTAddIconAsync(pb) : PBDTAddIconSync(pb))
+#define PBDTGetIcon(pb, async) ((async) ? PBDTGetIconAsync(pb) : PBDTGetIconSync(pb))
+#define PBDTGetIconInfo(pb, async) ((async) ? PBDTGetIconInfoAsync(pb) : PBDTGetIconInfoSync(pb))
+#define PBDTAddAPPL(pb, async) ((async) ? PBDTAddAPPLAsync(pb) : PBDTAddAPPLSync(pb))
+#define PBDTRemoveAPPL(pb, async) ((async) ? PBDTRemoveAPPLAsync(pb) : PBDTRemoveAPPLSync(pb))
+#define PBDTGetAPPL(pb, async) ((async) ? PBDTGetAPPLAsync(pb) : PBDTGetAPPLSync(pb))
+#define PBDTSetComment(pb, async) ((async) ? PBDTSetCommentAsync(pb) : PBDTSetCommentSync(pb))
+#define PBDTRemoveComment(pb, async) ((async) ? PBDTRemoveCommentAsync(pb) : PBDTRemoveCommentSync(pb))
+#define PBDTGetComment(pb, async) ((async) ? PBDTGetCommentAsync(pb) : PBDTGetCommentSync(pb))
+#define PBDTFlush(pb, async) ((async) ? PBDTFlushAsync(pb) : PBDTFlushSync(pb))
+#define PBDTReset(pb, async) ((async) ? PBDTResetAsync(pb) : PBDTResetSync(pb))
+#define PBDTGetInfo(pb, async) ((async) ? PBDTGetInfoAsync(pb) : PBDTGetInfoSync(pb))
+#define PBDTDelete(pb, async) ((async) ? PBDTDeleteAsync(pb) : PBDTDeleteSync(pb))
+#endif  /* !__LP64__ */
+
+
+#pragma pack(pop)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __FILES__ */
+
diff -Nru ../CarbonHeaders-18.1.orig/Finder.h ./Finder.h
--- ../CarbonHeaders-18.1.orig/Finder.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Finder.h	2009-09-29 14:00:48.000000000 -0700
@@ -0,0 +1,370 @@
+/*
+ * Copyright (c) 2007-2009 by Apple Inc.. All rights reserved.
+ *
+ * @APPLE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this
+ * file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_LICENSE_HEADER_END@
+ */
+/*
+     File:       CarbonCore/Finder.h
+ 
+     Contains:   Finder flags and container types.
+ 
+     Version:    CarbonCore-859.2~1
+ 
+     Copyright:  © 1990-2008 by Apple Computer, Inc., all rights reserved
+ 
+     Bugs?:      For bug reports, consult the following page on
+                 the World Wide Web:
+ 
+                     http://developer.apple.com/bugreporter/
+ 
+*/
+#ifndef __FINDER__
+#define __FINDER__
+
+#ifndef __MACTYPES__
+#include <CarbonCore/MacTypes.h>
+#endif
+
+
+
+#include <AvailabilityMacros.h>
+
+#if PRAGMA_ONCE
+#pragma once
+#endif
+
+#pragma pack(push, 2)
+
+/* Creator and type of clipping files */
+enum {
+  kClippingCreator              = 'drag',
+  kClippingPictureType          = 'clpp',
+  kClippingTextType             = 'clpt',
+  kClippingSoundType            = 'clps',
+  kClippingUnknownType          = 'clpu'
+};
+
+
+/* Creator and type of Internet Location files */
+enum {
+  kInternetLocationCreator      = 'drag',
+  kInternetLocationHTTP         = 'ilht',
+  kInternetLocationFTP          = 'ilft',
+  kInternetLocationFile         = 'ilfi',
+  kInternetLocationMail         = 'ilma',
+  kInternetLocationNNTP         = 'ilnw',
+  kInternetLocationAFP          = 'ilaf',
+  kInternetLocationAppleTalk    = 'ilat',
+  kInternetLocationNSL          = 'ilns',
+  kInternetLocationGeneric      = 'ilge'
+};
+
+
+
+enum {
+  kCustomIconResource           = -16455 /* Custom icon family resource ID */
+};
+
+/* In order to specify any of the information described in the */
+/* CustomBadgeResource data structure you must clear the kExtendedFlagsAreInvalid */
+/* and set kExtendedFlagHasCustomBadge of the FXInfo.fdXFlags or DXInfo.frXFlags field, */
+/* and add a resource of type kCustomBadgeResourceType and ID kCustomBadgeResourceID to */
+/* the file or to the "Icon/n" file for a folder */
+enum {
+  kCustomBadgeResourceType      = 'badg',
+  kCustomBadgeResourceID        = kCustomIconResource,
+  kCustomBadgeResourceVersion   = 0
+};
+
+struct CustomBadgeResource {
+  SInt16              version;                /* This is version kCustomBadgeResourceVersion*/
+  SInt16              customBadgeResourceID;  /* If not 0, the ID of a resource to use on top*/
+                                              /* of the icon for this file or folder*/
+  OSType              customBadgeType;        /* If not 0, the type and creator of an icon*/
+  OSType              customBadgeCreator;     /* to use on top of the icon*/
+  OSType              windowBadgeType;        /* If not 0, the type and creator of an icon*/
+  OSType              windowBadgeCreator;     /* to display in the header of the window for this */
+                                              /* file or folder*/
+  OSType              overrideType;           /* If not 0, the type and creator of an icon to*/
+  OSType              overrideCreator;        /* use INSTEAD of the icon for this file or folder*/
+};
+typedef struct CustomBadgeResource      CustomBadgeResource;
+typedef CustomBadgeResource *           CustomBadgeResourcePtr;
+typedef CustomBadgeResourcePtr *        CustomBadgeResourceHandle;
+/* You can specify routing information for a file by including a 'rout' 0 
+    resource in it and setting the kExtendedFlagHasRoutingInfo bit in the extended 
+    Finder flags. 
+    The 'rout' resource is an array of RoutingResourceEntry. Each entry is considered
+    in turn. The first matching entry is used.
+    If the creator and fileType match the file being dropped and targetFolder match
+    the folder ID of the folder being dropped onto, then the file is rerouted 
+    into the specified destination folder.
+    The only target folder currently supported is the system folder, 
+    kSystemFolderType = 'macs'.
+*/
+enum {
+  kRoutingResourceType          = 'rout',
+  kRoutingResourceID            = 0
+};
+
+struct RoutingResourceEntry {
+  OSType              creator;                /* Use '****' or 0 to match any creator */
+  OSType              fileType;               /* Use '****' or 0 to match any file type */
+  OSType              targetFolder;           /* Folder ID of the folder this file was dropped onto */
+  OSType              destinationFolder;      /* Folder that the source will be routed to */
+  OSType              reservedField;          /* Set to 0 */
+};
+typedef struct RoutingResourceEntry     RoutingResourceEntry;
+typedef RoutingResourceEntry *          RoutingResourcePtr;
+typedef RoutingResourcePtr *            RoutingResourceHandle;
+
+/* Types for special container aliases */
+enum {
+  kContainerFolderAliasType     = 'fdrp', /* type for folder aliases */
+  kContainerTrashAliasType      = 'trsh', /* type for trash folder aliases */
+  kContainerHardDiskAliasType   = 'hdsk', /* type for hard disk aliases */
+  kContainerFloppyAliasType     = 'flpy', /* type for floppy aliases */
+  kContainerServerAliasType     = 'srvr', /* type for server aliases */
+  kApplicationAliasType         = 'adrp', /* type for application aliases */
+  kContainerAliasType           = 'drop', /* type for all other containers */
+  kDesktopPrinterAliasType      = 'dtpa', /* type for Desktop Printer alias */
+  kContainerCDROMAliasType      = 'cddr', /* type for CD-ROM alias */
+  kApplicationCPAliasType       = 'acdp', /* type for application control panel alias */
+  kApplicationDAAliasType       = 'addp', /* type for application DA alias */
+  kPackageAliasType             = 'fpka', /* type for plain package alias */
+  kAppPackageAliasType          = 'fapa' /* type for application package alias */
+};
+
+/* Types for Special folder aliases */
+enum {
+  kSystemFolderAliasType        = 'fasy',
+  kAppleMenuFolderAliasType     = 'faam',
+  kStartupFolderAliasType       = 'fast',
+  kPrintMonitorDocsFolderAliasType = 'fapn',
+  kPreferencesFolderAliasType   = 'fapf',
+  kControlPanelFolderAliasType  = 'fact',
+  kExtensionFolderAliasType     = 'faex'
+};
+
+/* Types for AppleShare folder aliases */
+enum {
+  kExportedFolderAliasType      = 'faet',
+  kDropFolderAliasType          = 'fadr',
+  kSharedFolderAliasType        = 'fash',
+  kMountedFolderAliasType       = 'famn'
+};
+
+/* Finder flags (finderFlags, fdFlags and frFlags) */
+/* Any flag reserved or not specified should be set to 0. */
+/* If a flag applies to a file, but not to a folder, make sure to check */
+/* that the item is not a folder by checking ((ParamBlockRec.ioFlAttrib & ioDirMask) == 0) */
+enum {
+  kIsOnDesk                     = 0x0001, /* Files and folders (System 6) */
+  kColor                        = 0x000E, /* Files and folders */
+                                        /* bit 0x0020 was kRequireSwitchLaunch, but is now reserved for future use*/
+  kIsShared                     = 0x0040, /* Files only (Applications only) */
+                                        /* If clear, the application needs to write to */
+                                        /* its resource fork, and therefore cannot be */
+                                        /* shared on a server */
+  kHasNoINITs                   = 0x0080, /* Files only (Extensions/Control Panels only) */
+                                        /* This file contains no INIT resource */
+  kHasBeenInited                = 0x0100, /* Files only */
+                                        /* Clear if the file contains desktop database */
+                                        /* resources ('BNDL', 'FREF', 'open', 'kind'...) */
+                                        /* that have not been added yet. Set only by the Finder */
+                                        /* Reserved for folders - make sure this bit is cleared for folders */
+                                        /* bit 0x0200 was the letter bit for AOCE, but is now reserved for future use */
+  kHasCustomIcon                = 0x0400, /* Files and folders */
+  kIsStationery                 = 0x0800, /* Files only */
+  kNameLocked                   = 0x1000, /* Files and folders */
+  kHasBundle                    = 0x2000, /* Files and folders */
+                                        /* Indicates that a file has a BNDL resource */
+                                        /* Indicates that a folder is displayed as a package */
+  kIsInvisible                  = 0x4000, /* Files and folders */
+  kIsAlias                      = 0x8000 /* Files only */
+};
+
+/* Obsolete. Use names defined above. */
+enum {
+  fOnDesk                       = kIsOnDesk,
+  fHasBundle                    = kHasBundle,
+  fInvisible                    = kIsInvisible
+};
+
+/* Obsolete */
+enum {
+  fTrash                        = -3,
+  fDesktop                      = -2,
+  fDisk                         = 0
+};
+
+#if OLDROUTINENAMES
+enum {
+  kIsStationary                 = kIsStationery
+};
+
+#endif  /* OLDROUTINENAMES */
+
+/* Extended flags (extendedFinderFlags, fdXFlags and frXFlags) */
+/* Any flag not specified should be set to 0. */
+enum {
+  kExtendedFlagsAreInvalid      = 0x8000, /* If set the other extended flags are ignored */
+  kExtendedFlagHasCustomBadge   = 0x0100, /* Set if the file or folder has a badge resource */
+  kExtendedFlagObjectIsBusy     = 0x0080, /* Set if the object is marked as busy/incomplete */
+  kExtendedFlagHasRoutingInfo   = 0x0004 /* Set if the file contains routing info resource */
+};
+
+
+
+/* Use a filetype in this range to indicate that a file is temporarily busy */
+/* (while it is being downloaded or installed, for example).  This prevents */
+/* Finder 8.5 and later from trying to change the item's attributes before it */
+/* is fully created. -- If you provide a series of 'BNDL' icons for your creator */
+/* and some of these filetypes, you can achieve limited icon animation while */
+/* the file creation progresses. */
+enum {
+  kFirstMagicBusyFiletype       = 'bzy ',
+  kLastMagicBusyFiletype        = 'bzy?'
+};
+
+/* Use this date as a file's or folder's creation date to indicate that it is */
+/* temporarily busy (while it is being downloaded or installed, for example). */
+/* This prevents Finder from trying to change the item's attributes before it */
+/* is fully created (Finder 8.5 and 8.6 check file creation dates; later Finders */
+/* may check folder creation dates as well). */
+enum {
+  kMagicBusyCreationDate        = 0x4F3AFDB0
+};
+
+
+/*------------------------------------------------------------------------*/
+/*
+   The following data structures are binary compatible with FInfo, DInfo,
+   FXInfo and DXInfo but represent the Mac OS 8 semantic of the fields.
+   Use these data structures preferably to FInfo, etc...
+*/
+/*------------------------------------------------------------------------*/
+
+struct FileInfo {
+  OSType              fileType;               /* The type of the file */
+  OSType              fileCreator;            /* The file's creator */
+  UInt16              finderFlags;            /* ex: kHasBundle, kIsInvisible... */
+  Point               location;               /* File's location in the folder */
+                                              /* If set to {0, 0}, the Finder will place the item automatically */
+  UInt16              reservedField;          /* (set to 0) */
+};
+typedef struct FileInfo                 FileInfo;
+struct FolderInfo {
+  Rect                windowBounds;           /* The position and dimension of the folder's window */
+  UInt16              finderFlags;            /* ex. kIsInvisible, kNameLocked, etc.*/
+  Point               location;               /* Folder's location in the parent folder */
+                                              /* If set to {0, 0}, the Finder will place the item automatically */
+  UInt16              reservedField;          /* (set to 0) */
+};
+typedef struct FolderInfo               FolderInfo;
+struct ExtendedFileInfo {
+  SInt16              reserved1[4];           /* Reserved (set to 0) */
+  UInt16              extendedFinderFlags;    /* Extended flags (custom badge, routing info...) */
+  SInt16              reserved2;              /* Reserved (set to 0). Comment ID if high-bit is clear */
+  SInt32              putAwayFolderID;        /* Put away folder ID */
+};
+typedef struct ExtendedFileInfo         ExtendedFileInfo;
+struct ExtendedFolderInfo {
+  Point               scrollPosition;         /* Scroll position (for icon views) */
+  SInt32              reserved1;              /* Reserved (set to 0) */
+  UInt16              extendedFinderFlags;    /* Extended flags (custom badge, routing info...) */
+  SInt16              reserved2;              /* Reserved (set to 0). Comment ID if high-bit is clear */
+  SInt32              putAwayFolderID;        /* Put away folder ID */
+};
+typedef struct ExtendedFolderInfo       ExtendedFolderInfo;
+/*------------------------------------------------------------------------*/
+/*
+   The following data structures are here for compatibility.
+   Use the new data structures replacing them if possible (i.e. FileInfo 
+   instead of FInfo, etc...)
+*/
+/*------------------------------------------------------------------------*/
+/* File info */
+/*
+     IMPORTANT:
+     In MacOS 8, the fdFldr field has become reserved for the Finder.
+*/
+struct FInfo {
+  OSType              fdType;                 /* The type of the file */
+  OSType              fdCreator;              /* The file's creator */
+  UInt16              fdFlags;                /* Flags ex. kHasBundle, kIsInvisible, etc. */
+  Point               fdLocation;             /* File's location in folder. */
+                                              /* If set to {0, 0}, the Finder will place the item automatically */
+  SInt16              fdFldr;                 /* Reserved (set to 0) */
+};
+typedef struct FInfo                    FInfo;
+/* Extended file info */
+/*
+     IMPORTANT:
+     In MacOS 8, the fdIconID and fdComment fields were changed
+     to become reserved fields for the Finder.
+     The fdScript has become an extended flag.
+*/
+struct FXInfo {
+  SInt16              fdIconID;               /* Reserved (set to 0) */
+  SInt16              fdReserved[3];          /* Reserved (set to 0) */
+  SInt8               fdScript;               /* Extended flags. Script code if high-bit is set */
+  SInt8               fdXFlags;               /* Extended flags */
+  SInt16              fdComment;              /* Reserved (set to 0). Comment ID if high-bit is clear */
+  SInt32              fdPutAway;              /* Put away folder ID */
+};
+typedef struct FXInfo                   FXInfo;
+/* Folder info */
+/*
+     IMPORTANT:
+     In MacOS 8, the frView field was changed to become reserved 
+     field for the Finder.
+*/
+struct DInfo {
+  Rect                frRect;                 /* Folder's window bounds */
+  UInt16              frFlags;                /* Flags ex. kIsInvisible, kNameLocked, etc.*/
+  Point               frLocation;             /* Folder's location in parent folder */
+                                              /* If set to {0, 0}, the Finder will place the item automatically */
+  SInt16              frView;                 /* Reserved (set to 0) */
+};
+typedef struct DInfo                    DInfo;
+/* Extended folder info */
+/*
+     IMPORTANT:
+     In MacOS 8, the frOpenChain and frComment fields were changed
+     to become reserved fields for the Finder.
+     The frScript has become an extended flag.
+*/
+struct DXInfo {
+  Point               frScroll;               /* Scroll position */
+  SInt32              frOpenChain;            /* Reserved (set to 0) */
+  SInt8               frScript;               /* Extended flags. Script code if high-bit is set */
+  SInt8               frXFlags;               /* Extended flags */
+  SInt16              frComment;              /* Reserved (set to 0). Comment ID if high-bit is clear */
+  SInt32              frPutAway;              /* Put away folder ID */
+};
+typedef struct DXInfo                   DXInfo;
+/* ControlPanelDefProcPtr and cdev constants have all been moved to Processes.i*/
+
+#pragma pack(pop)
+
+
+#endif /* __FINDER__ */
+
diff -Nru ../CarbonHeaders-18.1.orig/MacErrors.h ./MacErrors.h
--- ../CarbonHeaders-18.1.orig/MacErrors.h	2009-09-29 13:46:25.000000000 -0700
+++ ./MacErrors.h	2009-09-29 14:00:55.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1985-2008 by Apple Inc.. All rights reserved.
+ * Copyright (c) 2007-2009 by Apple Inc.. All rights reserved.
  *
  * @APPLE_LICENSE_HEADER_START@
  * 
@@ -20,14 +20,15 @@
  * 
  * @APPLE_LICENSE_HEADER_END@
  */
- 
 /*
-     File:       MacErrors.h
+     File:       CarbonCore/MacErrors.h
  
      Contains:   OSErr codes.
  
-     Version:    CarbonCore-769~1
-  
+     Version:    CarbonCore-859.2~1
+ 
+     Copyright:  © 1985-2008 by Apple Computer, Inc., all rights reserved
+ 
      Bugs?:      For bug reports, consult the following page on
                  the World Wide Web:
  
@@ -38,7 +39,7 @@
 #define __MACERRORS__
 
 #ifndef __CONDITIONALMACROS__
-#include <ConditionalMacros.h>
+#include <CarbonCore/ConditionalMacros.h>
 #endif
 
 
@@ -2962,8 +2963,8 @@
 
 /* ComponentError codes*/
 enum {
-  badComponentInstance          = (long)0x80008001, /* when cast to an OSErr this is -32767*/
-  badComponentSelector          = (long)0x80008002 /* when cast to an OSErr this is -32766*/
+  badComponentInstance          = (int)0x80008001, /* when cast to an OSErr this is -32767*/
+  badComponentSelector          = (int)0x80008002 /* when cast to an OSErr this is -32766*/
 };
 
 
@@ -3097,109 +3098,109 @@
     larger than the highest OSErr value.
 */
 enum {
-  kPOSIXErrorBase               = 100000L,
-  kPOSIXErrorEPERM              = 100001L, /* Operation not permitted */
-  kPOSIXErrorENOENT             = 100002L, /* No such file or directory */
-  kPOSIXErrorESRCH              = 100003L, /* No such process */
-  kPOSIXErrorEINTR              = 100004L, /* Interrupted system call */
-  kPOSIXErrorEIO                = 100005L, /* Input/output error */
-  kPOSIXErrorENXIO              = 100006L, /* Device not configured */
-  kPOSIXErrorE2BIG              = 100007L, /* Argument list too long */
-  kPOSIXErrorENOEXEC            = 100008L, /* Exec format error */
-  kPOSIXErrorEBADF              = 100009L, /* Bad file descriptor */
-  kPOSIXErrorECHILD             = 100010L, /* No child processes */
-  kPOSIXErrorEDEADLK            = 100011L, /* Resource deadlock avoided */
-  kPOSIXErrorENOMEM             = 100012L, /* Cannot allocate memory */
-  kPOSIXErrorEACCES             = 100013L, /* Permission denied */
-  kPOSIXErrorEFAULT             = 100014L, /* Bad address */
-  kPOSIXErrorENOTBLK            = 100015L, /* Block device required */
-  kPOSIXErrorEBUSY              = 100016L, /* Device busy */
-  kPOSIXErrorEEXIST             = 100017L, /* File exists */
-  kPOSIXErrorEXDEV              = 100018L, /* Cross-device link */
-  kPOSIXErrorENODEV             = 100019L, /* Operation not supported by device */
-  kPOSIXErrorENOTDIR            = 100020L, /* Not a directory */
-  kPOSIXErrorEISDIR             = 100021L, /* Is a directory */
-  kPOSIXErrorEINVAL             = 100022L, /* Invalid argument */
-  kPOSIXErrorENFILE             = 100023L, /* Too many open files in system */
-  kPOSIXErrorEMFILE             = 100024L, /* Too many open files */
-  kPOSIXErrorENOTTY             = 100025L, /* Inappropriate ioctl for device */
-  kPOSIXErrorETXTBSY            = 100026L, /* Text file busy */
-  kPOSIXErrorEFBIG              = 100027L, /* File too large */
-  kPOSIXErrorENOSPC             = 100028L, /* No space left on device */
-  kPOSIXErrorESPIPE             = 100029L, /* Illegal seek */
-  kPOSIXErrorEROFS              = 100030L, /* Read-only file system */
-  kPOSIXErrorEMLINK             = 100031L, /* Too many links */
-  kPOSIXErrorEPIPE              = 100032L, /* Broken pipe */
-  kPOSIXErrorEDOM               = 100033L, /* Numerical argument out of domain */
-  kPOSIXErrorERANGE             = 100034L, /* Result too large */
-  kPOSIXErrorEAGAIN             = 100035L, /* Resource temporarily unavailable */
-  kPOSIXErrorEINPROGRESS        = 100036L, /* Operation now in progress */
-  kPOSIXErrorEALREADY           = 100037L, /* Operation already in progress */
-  kPOSIXErrorENOTSOCK           = 100038L, /* Socket operation on non-socket */
-  kPOSIXErrorEDESTADDRREQ       = 100039L, /* Destination address required */
-  kPOSIXErrorEMSGSIZE           = 100040L, /* Message too long */
-  kPOSIXErrorEPROTOTYPE         = 100041L, /* Protocol wrong type for socket */
-  kPOSIXErrorENOPROTOOPT        = 100042L, /* Protocol not available */
-  kPOSIXErrorEPROTONOSUPPORT    = 100043L, /* Protocol not supported */
-  kPOSIXErrorESOCKTNOSUPPORT    = 100044L, /* Socket type not supported */
-  kPOSIXErrorENOTSUP            = 100045L, /* Operation not supported */
-  kPOSIXErrorEPFNOSUPPORT       = 100046L, /* Protocol family not supported */
-  kPOSIXErrorEAFNOSUPPORT       = 100047L, /* Address family not supported by protocol family */
-  kPOSIXErrorEADDRINUSE         = 100048L, /* Address already in use */
-  kPOSIXErrorEADDRNOTAVAIL      = 100049L, /* Can't assign requested address */
-  kPOSIXErrorENETDOWN           = 100050L, /* Network is down */
-  kPOSIXErrorENETUNREACH        = 100051L, /* Network is unreachable */
-  kPOSIXErrorENETRESET          = 100052L, /* Network dropped connection on reset */
-  kPOSIXErrorECONNABORTED       = 100053L, /* Software caused connection abort */
-  kPOSIXErrorECONNRESET         = 100054L, /* Connection reset by peer */
-  kPOSIXErrorENOBUFS            = 100055L, /* No buffer space available */
-  kPOSIXErrorEISCONN            = 100056L, /* Socket is already connected */
-  kPOSIXErrorENOTCONN           = 100057L, /* Socket is not connected */
-  kPOSIXErrorESHUTDOWN          = 100058L, /* Can't send after socket shutdown */
-  kPOSIXErrorETOOMANYREFS       = 100059L, /* Too many references: can't splice */
-  kPOSIXErrorETIMEDOUT          = 100060L, /* Operation timed out */
-  kPOSIXErrorECONNREFUSED       = 100061L, /* Connection refused */
-  kPOSIXErrorELOOP              = 100062L, /* Too many levels of symbolic links */
-  kPOSIXErrorENAMETOOLONG       = 100063L, /* File name too long */
-  kPOSIXErrorEHOSTDOWN          = 100064L, /* Host is down */
-  kPOSIXErrorEHOSTUNREACH       = 100065L, /* No route to host */
-  kPOSIXErrorENOTEMPTY          = 100066L, /* Directory not empty */
-  kPOSIXErrorEPROCLIM           = 100067L, /* Too many processes */
-  kPOSIXErrorEUSERS             = 100068L, /* Too many users */
-  kPOSIXErrorEDQUOT             = 100069L, /* Disc quota exceeded */
-  kPOSIXErrorESTALE             = 100070L, /* Stale NFS file handle */
-  kPOSIXErrorEREMOTE            = 100071L, /* Too many levels of remote in path */
-  kPOSIXErrorEBADRPC            = 100072L, /* RPC struct is bad */
-  kPOSIXErrorERPCMISMATCH       = 100073L, /* RPC version wrong */
-  kPOSIXErrorEPROGUNAVAIL       = 100074L, /* RPC prog. not avail */
-  kPOSIXErrorEPROGMISMATCH      = 100075L, /* Program version wrong */
-  kPOSIXErrorEPROCUNAVAIL       = 100076L, /* Bad procedure for program */
-  kPOSIXErrorENOLCK             = 100077L, /* No locks available */
-  kPOSIXErrorENOSYS             = 100078L, /* Function not implemented */
-  kPOSIXErrorEFTYPE             = 100079L, /* Inappropriate file type or format */
-  kPOSIXErrorEAUTH              = 100080L, /* Authentication error */
-  kPOSIXErrorENEEDAUTH          = 100081L, /* Need authenticator */
-  kPOSIXErrorEPWROFF            = 100082L, /* Device power is off */
-  kPOSIXErrorEDEVERR            = 100083L, /* Device error, e.g. paper out */
-  kPOSIXErrorEOVERFLOW          = 100084L, /* Value too large to be stored in data type */
-  kPOSIXErrorEBADEXEC           = 100085L, /* Bad executable */
-  kPOSIXErrorEBADARCH           = 100086L, /* Bad CPU type in executable */
-  kPOSIXErrorESHLIBVERS         = 100087L, /* Shared library version mismatch */
-  kPOSIXErrorEBADMACHO          = 100088L, /* Malformed Macho file */
-  kPOSIXErrorECANCELED          = 100089L, /* Operation canceled */
-  kPOSIXErrorEIDRM              = 100090L, /* Identifier removed */
-  kPOSIXErrorENOMSG             = 100091L, /* No message of desired type */
-  kPOSIXErrorEILSEQ             = 100092L, /* Illegal byte sequence */
-  kPOSIXErrorENOATTR            = 100093L, /* Attribute not found */
-  kPOSIXErrorEBADMSG            = 100094L, /* Bad message */
-  kPOSIXErrorEMULTIHOP          = 100095L, /* Reserved */
-  kPOSIXErrorENODATA            = 100096L, /* No message available on STREAM */
-  kPOSIXErrorENOLINK            = 100097L, /* Reserved */
-  kPOSIXErrorENOSR              = 100098L, /* No STREAM resources */
-  kPOSIXErrorENOSTR             = 100099L, /* Not a STREAM */
-  kPOSIXErrorEPROTO             = 100100L, /* Protocol error */
-  kPOSIXErrorETIME              = 100101L, /* STREAM ioctl timeout */
-  kPOSIXErrorEOPNOTSUPP         = 100102L /* Operation not supported on socket */
+  kPOSIXErrorBase               = 100000,
+  kPOSIXErrorEPERM              = 100001, /* Operation not permitted */
+  kPOSIXErrorENOENT             = 100002, /* No such file or directory */
+  kPOSIXErrorESRCH              = 100003, /* No such process */
+  kPOSIXErrorEINTR              = 100004, /* Interrupted system call */
+  kPOSIXErrorEIO                = 100005, /* Input/output error */
+  kPOSIXErrorENXIO              = 100006, /* Device not configured */
+  kPOSIXErrorE2BIG              = 100007, /* Argument list too long */
+  kPOSIXErrorENOEXEC            = 100008, /* Exec format error */
+  kPOSIXErrorEBADF              = 100009, /* Bad file descriptor */
+  kPOSIXErrorECHILD             = 100010, /* No child processes */
+  kPOSIXErrorEDEADLK            = 100011, /* Resource deadlock avoided */
+  kPOSIXErrorENOMEM             = 100012, /* Cannot allocate memory */
+  kPOSIXErrorEACCES             = 100013, /* Permission denied */
+  kPOSIXErrorEFAULT             = 100014, /* Bad address */
+  kPOSIXErrorENOTBLK            = 100015, /* Block device required */
+  kPOSIXErrorEBUSY              = 100016, /* Device busy */
+  kPOSIXErrorEEXIST             = 100017, /* File exists */
+  kPOSIXErrorEXDEV              = 100018, /* Cross-device link */
+  kPOSIXErrorENODEV             = 100019, /* Operation not supported by device */
+  kPOSIXErrorENOTDIR            = 100020, /* Not a directory */
+  kPOSIXErrorEISDIR             = 100021, /* Is a directory */
+  kPOSIXErrorEINVAL             = 100022, /* Invalid argument */
+  kPOSIXErrorENFILE             = 100023, /* Too many open files in system */
+  kPOSIXErrorEMFILE             = 100024, /* Too many open files */
+  kPOSIXErrorENOTTY             = 100025, /* Inappropriate ioctl for device */
+  kPOSIXErrorETXTBSY            = 100026, /* Text file busy */
+  kPOSIXErrorEFBIG              = 100027, /* File too large */
+  kPOSIXErrorENOSPC             = 100028, /* No space left on device */
+  kPOSIXErrorESPIPE             = 100029, /* Illegal seek */
+  kPOSIXErrorEROFS              = 100030, /* Read-only file system */
+  kPOSIXErrorEMLINK             = 100031, /* Too many links */
+  kPOSIXErrorEPIPE              = 100032, /* Broken pipe */
+  kPOSIXErrorEDOM               = 100033, /* Numerical argument out of domain */
+  kPOSIXErrorERANGE             = 100034, /* Result too large */
+  kPOSIXErrorEAGAIN             = 100035, /* Resource temporarily unavailable */
+  kPOSIXErrorEINPROGRESS        = 100036, /* Operation now in progress */
+  kPOSIXErrorEALREADY           = 100037, /* Operation already in progress */
+  kPOSIXErrorENOTSOCK           = 100038, /* Socket operation on non-socket */
+  kPOSIXErrorEDESTADDRREQ       = 100039, /* Destination address required */
+  kPOSIXErrorEMSGSIZE           = 100040, /* Message too long */
+  kPOSIXErrorEPROTOTYPE         = 100041, /* Protocol wrong type for socket */
+  kPOSIXErrorENOPROTOOPT        = 100042, /* Protocol not available */
+  kPOSIXErrorEPROTONOSUPPORT    = 100043, /* Protocol not supported */
+  kPOSIXErrorESOCKTNOSUPPORT    = 100044, /* Socket type not supported */
+  kPOSIXErrorENOTSUP            = 100045, /* Operation not supported */
+  kPOSIXErrorEPFNOSUPPORT       = 100046, /* Protocol family not supported */
+  kPOSIXErrorEAFNOSUPPORT       = 100047, /* Address family not supported by protocol family */
+  kPOSIXErrorEADDRINUSE         = 100048, /* Address already in use */
+  kPOSIXErrorEADDRNOTAVAIL      = 100049, /* Can't assign requested address */
+  kPOSIXErrorENETDOWN           = 100050, /* Network is down */
+  kPOSIXErrorENETUNREACH        = 100051, /* Network is unreachable */
+  kPOSIXErrorENETRESET          = 100052, /* Network dropped connection on reset */
+  kPOSIXErrorECONNABORTED       = 100053, /* Software caused connection abort */
+  kPOSIXErrorECONNRESET         = 100054, /* Connection reset by peer */
+  kPOSIXErrorENOBUFS            = 100055, /* No buffer space available */
+  kPOSIXErrorEISCONN            = 100056, /* Socket is already connected */
+  kPOSIXErrorENOTCONN           = 100057, /* Socket is not connected */
+  kPOSIXErrorESHUTDOWN          = 100058, /* Can't send after socket shutdown */
+  kPOSIXErrorETOOMANYREFS       = 100059, /* Too many references: can't splice */
+  kPOSIXErrorETIMEDOUT          = 100060, /* Operation timed out */
+  kPOSIXErrorECONNREFUSED       = 100061, /* Connection refused */
+  kPOSIXErrorELOOP              = 100062, /* Too many levels of symbolic links */
+  kPOSIXErrorENAMETOOLONG       = 100063, /* File name too long */
+  kPOSIXErrorEHOSTDOWN          = 100064, /* Host is down */
+  kPOSIXErrorEHOSTUNREACH       = 100065, /* No route to host */
+  kPOSIXErrorENOTEMPTY          = 100066, /* Directory not empty */
+  kPOSIXErrorEPROCLIM           = 100067, /* Too many processes */
+  kPOSIXErrorEUSERS             = 100068, /* Too many users */
+  kPOSIXErrorEDQUOT             = 100069, /* Disc quota exceeded */
+  kPOSIXErrorESTALE             = 100070, /* Stale NFS file handle */
+  kPOSIXErrorEREMOTE            = 100071, /* Too many levels of remote in path */
+  kPOSIXErrorEBADRPC            = 100072, /* RPC struct is bad */
+  kPOSIXErrorERPCMISMATCH       = 100073, /* RPC version wrong */
+  kPOSIXErrorEPROGUNAVAIL       = 100074, /* RPC prog. not avail */
+  kPOSIXErrorEPROGMISMATCH      = 100075, /* Program version wrong */
+  kPOSIXErrorEPROCUNAVAIL       = 100076, /* Bad procedure for program */
+  kPOSIXErrorENOLCK             = 100077, /* No locks available */
+  kPOSIXErrorENOSYS             = 100078, /* Function not implemented */
+  kPOSIXErrorEFTYPE             = 100079, /* Inappropriate file type or format */
+  kPOSIXErrorEAUTH              = 100080, /* Authentication error */
+  kPOSIXErrorENEEDAUTH          = 100081, /* Need authenticator */
+  kPOSIXErrorEPWROFF            = 100082, /* Device power is off */
+  kPOSIXErrorEDEVERR            = 100083, /* Device error, e.g. paper out */
+  kPOSIXErrorEOVERFLOW          = 100084, /* Value too large to be stored in data type */
+  kPOSIXErrorEBADEXEC           = 100085, /* Bad executable */
+  kPOSIXErrorEBADARCH           = 100086, /* Bad CPU type in executable */
+  kPOSIXErrorESHLIBVERS         = 100087, /* Shared library version mismatch */
+  kPOSIXErrorEBADMACHO          = 100088, /* Malformed Macho file */
+  kPOSIXErrorECANCELED          = 100089, /* Operation canceled */
+  kPOSIXErrorEIDRM              = 100090, /* Identifier removed */
+  kPOSIXErrorENOMSG             = 100091, /* No message of desired type */
+  kPOSIXErrorEILSEQ             = 100092, /* Illegal byte sequence */
+  kPOSIXErrorENOATTR            = 100093, /* Attribute not found */
+  kPOSIXErrorEBADMSG            = 100094, /* Bad message */
+  kPOSIXErrorEMULTIHOP          = 100095, /* Reserved */
+  kPOSIXErrorENODATA            = 100096, /* No message available on STREAM */
+  kPOSIXErrorENOLINK            = 100097, /* Reserved */
+  kPOSIXErrorENOSR              = 100098, /* No STREAM resources */
+  kPOSIXErrorENOSTR             = 100099, /* Not a STREAM */
+  kPOSIXErrorEPROTO             = 100100, /* Protocol error */
+  kPOSIXErrorETIME              = 100101, /* STREAM ioctl timeout */
+  kPOSIXErrorEOPNOTSUPP         = 100102 /* Operation not supported on socket */
 };
 
 
diff -Nru ../CarbonHeaders-18.1.orig/MacMemory.h ./MacMemory.h
--- ../CarbonHeaders-18.1.orig/MacMemory.h	1969-12-31 16:00:00.000000000 -0800
+++ ./MacMemory.h	2009-09-29 14:01:01.000000000 -0700
@@ -0,0 +1,2548 @@
+/*
+ * Copyright (c) 2007-2009 by Apple Inc.. All rights reserved.
+ *
+ * @APPLE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this
+ * file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_LICENSE_HEADER_END@
+ */
+/*
+     File:       CarbonCore/MacMemory.h
+ 
+     Contains:   Memory Manager Interfaces.
+ 
+     Version:    CarbonCore-859.2~1
+ 
+     Copyright:  © 1985-2008 by Apple Computer, Inc., all rights reserved
+ 
+     Bugs?:      For bug reports, consult the following page on
+                 the World Wide Web:
+ 
+                     http://developer.apple.com/bugreporter/
+ 
+*/
+#ifndef __MACMEMORY__
+#define __MACMEMORY__
+
+#ifndef __MACTYPES__
+#include <CarbonCore/MacTypes.h>
+#endif
+
+#ifndef __MIXEDMODE__
+#include <CarbonCore/MixedMode.h>
+#endif
+
+
+#include <string.h>
+
+#include <AvailabilityMacros.h>
+
+#if PRAGMA_ONCE
+#pragma once
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#pragma pack(push, 2)
+
+enum {
+  maxSize                       = 0x7FFFFFF0 /*the largest block possible*/
+};
+
+/*
+    If you define a macro named __MAC_OS_X_MEMORY_MANAGER_CLEAN__ with a non-zero value, then
+    some Memory Manager APIs will become inlined, minimal implementations.  See the comments
+    below for more information about this.
+*/
+#ifndef __MAC_OS_X_MEMORY_MANAGER_CLEAN__
+#define __MAC_OS_X_MEMORY_MANAGER_CLEAN__ 0
+#endif  /* !defined(__MAC_OS_X_MEMORY_MANAGER_CLEAN__) */
+
+#if !__MAC_OS_X_MEMORY_MANAGER_CLEAN__
+enum {
+  defaultPhysicalEntryCount     = 8
+};
+
+enum {
+                                        /* values returned from the GetPageState function */
+  kPageInMemory                 = 0,
+  kPageOnDisk                   = 1,
+  kNotPaged                     = 2
+};
+
+enum {
+                                        /* masks for Zone->heapType field */
+  k32BitHeap                    = 1,    /* valid in all Memory Managers */
+  kNewStyleHeap                 = 2,    /* true if new Heap Manager is present */
+  kNewDebugHeap                 = 4     /* true if new Heap Manager is running in debug mode on this heap */
+};
+
+
+#endif  /* !__MAC_OS_X_MEMORY_MANAGER_CLEAN__ */
+
+/* bits for use with HGetState/HSetState*/
+enum {
+  kHandleIsResourceBit          = 5,
+  kHandlePurgeableBit           = 6,
+  kHandleLockedBit              = 7
+};
+
+/* masks for use with HGetState/HSetState*/
+enum {
+  kHandleIsResourceMask         = 0x20,
+  kHandlePurgeableMask          = 0x40,
+  kHandleLockedMask             = 0x80
+};
+
+#if !__LP64__
+typedef CALLBACK_API( long , GrowZoneProcPtr )(Size cbNeeded);
+typedef CALLBACK_API( void , PurgeProcPtr )(Handle blockToPurge);
+typedef CALLBACK_API( void , UserFnProcPtr )(void * parameter);
+typedef STACK_UPP_TYPE(GrowZoneProcPtr)                         GrowZoneUPP;
+typedef STACK_UPP_TYPE(PurgeProcPtr)                            PurgeUPP;
+typedef STACK_UPP_TYPE(UserFnProcPtr)                           UserFnUPP;
+struct Zone {
+  Ptr                 bkLim;
+  Ptr                 purgePtr;
+  Ptr                 hFstFree;
+  long                zcbFree;
+  GrowZoneUPP         gzProc;
+  short               moreMast;
+  short               flags;
+  short               cntRel;
+  short               maxRel;
+  short               cntNRel;
+  SInt8               heapType;               /* previously "maxNRel", now holds flags (e.g. k32BitHeap)*/
+  SInt8               unused;
+  short               cntEmpty;
+  short               cntHandles;
+  long                minCBFree;
+  PurgeUPP            purgeProc;
+  Ptr                 sparePtr;
+  Ptr                 allocPtr;
+  short               heapData;
+};
+typedef struct Zone                     Zone;
+typedef Zone *                          THz;
+typedef THz *                           THzPtr;
+#if !__MAC_OS_X_MEMORY_MANAGER_CLEAN__
+struct MemoryBlock {
+  void *              address;
+  unsigned long       count;
+};
+typedef struct MemoryBlock              MemoryBlock;
+struct LogicalToPhysicalTable {
+  MemoryBlock         logical;
+  MemoryBlock         physical[8];
+};
+typedef struct LogicalToPhysicalTable   LogicalToPhysicalTable;
+
+typedef short                           PageState;
+typedef short                           StatusRegisterContents;
+enum {
+  kVolumeVirtualMemoryInfoVersion1 = 1  /* first version of VolumeVirtualMemoryInfo*/
+};
+
+struct VolumeVirtualMemoryInfo {
+  PBVersion           version;                /* Input: Version of the VolumeVirtualMemoryInfo structure*/
+  SInt16              volumeRefNum;           /* Input: volume reference number*/
+  Boolean             inUse;                  /* output: true if volume is currently used for file mapping*/
+  UInt8               _fill;
+  UInt32              vmOptions;              /* output: tells what volume can support (same as DriverGestaltVMOptionsResponse vmOptions bits in DriverGestalt)*/
+                                              /* end of kVolumeVirtualMemoryInfoVersion1 structure*/
+};
+typedef struct VolumeVirtualMemoryInfo  VolumeVirtualMemoryInfo;
+typedef VolumeVirtualMemoryInfo *       VolumeVirtualMemoryInfoPtr;
+#endif  /* !__MAC_OS_X_MEMORY_MANAGER_CLEAN__ */
+
+/*
+ *  NewGrowZoneUPP()
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   available as macro/inline
+ */
+extern GrowZoneUPP
+NewGrowZoneUPP(GrowZoneProcPtr userRoutine)                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+/*
+ *  NewPurgeUPP()
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   available as macro/inline
+ */
+extern PurgeUPP
+NewPurgeUPP(PurgeProcPtr userRoutine)                         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+/*
+ *  NewUserFnUPP()
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   available as macro/inline
+ */
+extern UserFnUPP
+NewUserFnUPP(UserFnProcPtr userRoutine)                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+/*
+ *  DisposeGrowZoneUPP()
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   available as macro/inline
+ */
+extern void
+DisposeGrowZoneUPP(GrowZoneUPP userUPP)                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+/*
+ *  DisposePurgeUPP()
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   available as macro/inline
+ */
+extern void
+DisposePurgeUPP(PurgeUPP userUPP)                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+/*
+ *  DisposeUserFnUPP()
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   available as macro/inline
+ */
+extern void
+DisposeUserFnUPP(UserFnUPP userUPP)                           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+/*
+ *  InvokeGrowZoneUPP()
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   available as macro/inline
+ */
+extern long
+InvokeGrowZoneUPP(
+  Size         cbNeeded,
+  GrowZoneUPP  userUPP)                                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+/*
+ *  InvokePurgeUPP()
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   available as macro/inline
+ */
+extern void
+InvokePurgeUPP(
+  Handle    blockToPurge,
+  PurgeUPP  userUPP)                                          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+/*
+ *  InvokeUserFnUPP()
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   available as macro/inline
+ */
+extern void
+InvokeUserFnUPP(
+  void *     parameter,
+  UserFnUPP  userUPP)                                         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+#if __MACH__
+  #ifdef __cplusplus
+    inline GrowZoneUPP                                          NewGrowZoneUPP(GrowZoneProcPtr userRoutine) { return userRoutine; }
+    inline PurgeUPP                                             NewPurgeUPP(PurgeProcPtr userRoutine) { return userRoutine; }
+    inline UserFnUPP                                            NewUserFnUPP(UserFnProcPtr userRoutine) { return userRoutine; }
+    inline void                                                 DisposeGrowZoneUPP(GrowZoneUPP) { }
+    inline void                                                 DisposePurgeUPP(PurgeUPP) { }
+    inline void                                                 DisposeUserFnUPP(UserFnUPP) { }
+    inline long                                                 InvokeGrowZoneUPP(Size cbNeeded, GrowZoneUPP userUPP) { return (*userUPP)(cbNeeded); }
+    inline void                                                 InvokePurgeUPP(Handle blockToPurge, PurgeUPP userUPP) { (*userUPP)(blockToPurge); }
+    inline void                                                 InvokeUserFnUPP(void * parameter, UserFnUPP userUPP) { (*userUPP)(parameter); }
+  #else
+    #define NewGrowZoneUPP(userRoutine)                         ((GrowZoneUPP)userRoutine)
+    #define NewPurgeUPP(userRoutine)                            ((PurgeUPP)userRoutine)
+    #define NewUserFnUPP(userRoutine)                           ((UserFnUPP)userRoutine)
+    #define DisposeGrowZoneUPP(userUPP)
+    #define DisposePurgeUPP(userUPP)
+    #define DisposeUserFnUPP(userUPP)
+    #define InvokeGrowZoneUPP(cbNeeded, userUPP)                (*userUPP)(cbNeeded)
+    #define InvokePurgeUPP(blockToPurge, userUPP)               (*userUPP)(blockToPurge)
+    #define InvokeUserFnUPP(parameter, userUPP)                 (*userUPP)(parameter)
+  #endif
+#endif
+
+#endif  /* !__LP64__ */
+
+/*
+ *  MemError()
+ *  
+ *  Summary:
+ *    Determines if an applicationÕs last direct call to a Memory
+ *    Manager function executed successfully.
+ *  
+ *  Discussion:
+ *    MemError() yields the result code produced by the last Memory
+ *    Manager function your application called directly, and resets
+ *    MemError() to return noErr in the future. MemError() is useful
+ *    during application debugging. You might also use MemError as one
+ *    part of a memory-management scheme to identify instances in which
+ *    the Memory Manager rejects overly large memory requests by
+ *    returning the error code memFullErr.
+ *    
+ *    To view the result codes that MemError() can produce, see "Memory
+ *    Manager Result Codes".
+ *    
+ *    Do not rely on MemError() as the only component of a
+ *    memory-management scheme. For example, suppose you call NewHandle
+ *    or NewPtr and receive the result code noErr, indicating that the
+ *    Memory Manager was able to allocate sufficient memory. In this
+ *    case, you have no guarantee that the allocation did not deplete
+ *    your applicationÕs memory reserves to levels so low that simple
+ *    operations might cause your application to crash. Instead of
+ *    relying on MemError(), check before making a memory request that
+ *    there is enough memory both to fulfill the request and to support
+ *    essential operations.
+ *    
+ *    On Mac OS X 10.3 and later, the value of MemError() is kept for
+ *    each thread; prior to Mac OS X 10.3.  MemError() is global to the
+ *    application.  Because of this, and other problems, the Memory
+ *    Manager APIs are not thread safe before Mac OS X 10.3.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+MemError(void)                                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  LMGetMemErr()
+ *  
+ *  Summary:
+ *    Returns the result of the last Memory Manager function, without
+ *    clearing the value like MemError() does.
+ *  
+ *  Discussion:
+ *    LMGetMemErr yields the result code produced by the last Memory
+ *    Manager function your application called directly. Unlike
+ *    MemError(), this function does not reset the stored value, so
+ *    subsequent calls to LMGetMemErr() will still return this value
+ *    until the next Memory Manager routine is called or until
+ *    MemError() is called to reset the value. LMGetMemErr is useful
+ *    during application debugging. You might also use this value as
+ *    one part of a memory-management scheme to identify instances in
+ *    which the Memory Manager rejects overly large memory requests by
+ *    returning the error code memFullErr.
+ *    
+ *    To view the result codes that MemError() can produce, see "Memory
+ *    Manager Result Codes".
+ *    
+ *    Do not rely on MemError() as the only component of a
+ *    memory-management scheme. For example, suppose you call NewHandle
+ *    or NewPtr and receive the result code noErr, indicating that the
+ *    Memory Manager was able to allocate sufficient memory. In this
+ *    case, you have no guarantee that the allocation did not deplete
+ *    your applicationÕs memory reserves to levels so low that simple
+ *    operations might cause your application to crash. Instead of
+ *    relying on MemError(), check before making a memory request that
+ *    there is enough memory both to fulfill the request and to support
+ *    essential operations.
+ *    
+ *    On Mac OS X 10.3 and later, the value of MemError() is kept for
+ *    each thread; prior to Mac OS X 10.3 there was one global value of
+ *    MemError() which all threads shared. Because of this, and other
+ *    problems, the Memory Manager APIs are not thread safe before Mac
+ *    OS X 10.3.
+ *  
+ *  Mac OS X threading:
+ *    Not thread safe
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern SInt16 
+LMGetMemErr(void)                                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  LMSetMemErr()
+ *  
+ *  Summary:
+ *    Set the value which will be returned by MemError()
+ *  
+ *  Discussion:
+ *    User code shouldn't need to call this function, which is used to
+ *    set the value which the next call to MemError() will return.
+ *  
+ *  Mac OS X threading:
+ *    Not thread safe
+ *  
+ *  Parameters:
+ *    
+ *    value:
+ *      the value which the next MemError() function call should return
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern void 
+LMSetMemErr(SInt16 value)                                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  NewHandle()
+ *  
+ *  Summary:
+ *    Allocate a relocatable memory block of a specified size.
+ *  
+ *  Discussion:
+ *    The NewHandle function attempts to allocate a new relocatable
+ *    block in the current heap zone with a logical size of logicalSize
+ *    bytes and then return a handle to the block. The new block is
+ *    unlocked and unpurgeable. If NewHandle cannot allocate a block of
+ *    the requested size, it returns NULL.  The memory block returned
+ *    likely will contain garbage, and will be unlocked and
+ *    non-purgeable.
+ *    
+ *    WARNING
+ *    
+ *    Do not try to manufacture your own handles without this function
+ *    by simply assigning the address of a variable of type Ptr to a
+ *    variable of type Handle. The resulting "fake handle" would not
+ *    reference a relocatable block and could cause a system crash.
+ *     If this function returns NIL, the error result can be determined
+ *    by calling the function MemError().
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Parameters:
+ *    
+ *    byteCount:
+ *      the size of the relocatable memory block to allocate.  If this
+ *      value is < 0, NIL will be returned. If this value is 0, a
+ *      handle to 0 byte block will be returned.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern Handle 
+NewHandle(Size byteCount)                                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  NewHandleClear()
+ *  
+ *  Summary:
+ *    Allocate a relocatable memory block of a specified size.
+ *  
+ *  Discussion:
+ *    The NewHandle function attempts to allocate a new relocatable
+ *    block in the current heap zone with a logical size of logicalSize
+ *    bytes and then return a handle to the block. The new block is
+ *    unlocked and unpurgeable. If NewHandle cannot allocate a block of
+ *    the requested size, it returns NULL.  The memory block returned
+ *    will be zeroed, and will be unlocked and non-purgeable.
+ *    
+ *    WARNING
+ *    
+ *    Do not try to manufacture your own handles without this function
+ *    by simply assigning the address of a variable of type Ptr to a
+ *    variable of type Handle. The resulting "fake handle" would not
+ *    reference a relocatable block and could cause a system crash.
+ *     If this function returns NIL, the error result can be determined
+ *    by calling the function MemError().
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Parameters:
+ *    
+ *    byteCount:
+ *      the size of the relocatable memory block to allocate.  If this
+ *      value is < 0, NIL will be returned. If this value is 0, a
+ *      handle to 0 byte block will be returned.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern Handle 
+NewHandleClear(Size byteCount)                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  RecoverHandle()
+ *  
+ *  Summary:
+ *    Returns a handle to a relocatable block pointed to by a specified
+ *    pointer.
+ *  
+ *  Discussion:
+ *    The Memory Manager does not allow you to change relocatable
+ *    blocks into nonrelocatable blocks, or vice-versa. However, if you
+ *    no longer have access to a handle but still have access to its
+ *    master pointer p, you can use the RecoverHandle function to
+ *    recreate a handle to the relocatable block referenced by
+ *    p.
+ *    
+ *    Call the function MemError() to get the result code. See "Memory
+ *    Manager Result Codes".
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Parameters:
+ *    
+ *    p:
+ *      the master pointer to a relocatable block.
+ *  
+ *  Result:
+ *    A handle to a relocatable block point to by p. If p does not
+ *    point to a valid block, this function returns NULL.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern Handle 
+RecoverHandle(Ptr p)                                          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  NewPtr()
+ *  
+ *  Summary:
+ *    Allocates a nonrelocatable block of memory of a specified size.
+ *  
+ *  Discussion:
+ *    The NewPtr function attempts to reserve space for the new block.
+ *    If it is able to reserve the requested amount of space, NewPtr
+ *    allocates the nonrelocatable block.  Otherwise, NewPtr returns
+ *    NULL and generates a memFullErr error. On Mac OS X, NewPtr will
+ *    never fail because it is unable to allocate the pointer. Certain
+ *    old versions of Mac OS X return a NULL pointer when asked to
+ *    allocate a pointer of size 0.
+ *    Call the function MemError to get the result code. See "Memory
+ *    Manager Result Codes".
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Parameters:
+ *    
+ *    byteCount:
+ *      The requested size (in bytes) of the nonrelocatable block.  If
+ *      you pass a value of zero, this function returns a valid zero
+ *      length pointer.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern Ptr 
+NewPtr(Size byteCount)                                        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  NewPtrClear()
+ *  
+ *  Summary:
+ *    Allocates a nonrelocatable block of memory of a specified size
+ *    with all its bytes set to 0.
+ *  
+ *  Discussion:
+ *    The NewPtr function attempts to reserve space for the new block.
+ *    If it is able to reserve the requested amount of space, NewPtr
+ *    allocates the nonrelocatable block.  Otherwise, NewPtr returns
+ *    NULL and generates a memFullErr error. On Mac OS X, NewPtr will
+ *    never fail because it is unable to allocate the pointer. Certain
+ *    old versions of Mac OS X return a NULL pointer when asked to
+ *    allocate a pointer of size 0.
+ *    Call the function MemError to get the result code. See "Memory
+ *    Manager Result Codes".
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Parameters:
+ *    
+ *    byteCount:
+ *      The requested size (in bytes) of the nonrelocatable block.  If
+ *      you pass a value of zero, this function returns a valid zero
+ *      length pointer.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern Ptr 
+NewPtrClear(Size byteCount)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+#if !__LP64__
+/*
+ *  MaxBlock()   *** DEPRECATED ***
+ *  
+ *  Summary:
+ *    Return the size of the largest block you could allocate in the
+ *    current heap zone after compaction.
+ *  
+ *  Discussion:
+ *    On Mac OS X, this function always returns a large value, because
+ *    virtual memory is always available to fulfill any request for
+ *    memory.  This function is deprecated on Mac OS X and later.  You
+ *    can assume that any reasonable memory allocation will succeed.
+ *  
+ *  Mac OS X threading:
+ *    Not thread safe
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern long 
+MaxBlock(void)                                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/*
+ *  StackSpace()   *** DEPRECATED ***
+ *  
+ *  Summary:
+ *    Returns the amount of space unused on the current thread's stack.
+ *  
+ *  Mac OS X threading:
+ *    Not thread safe
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern long 
+StackSpace(void)                                              AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+#endif  /* !__LP64__ */
+
+/*
+ *  NewEmptyHandle()
+ *  
+ *  Summary:
+ *    Initializes a new handle without allocating any memory for it to
+ *    control.
+ *  
+ *  Discussion:
+ *    When you want to allocate memory for the empty handle, use the
+ *    ReallocateHandle function.
+ *    Call the function MemError to get the result code. See "Memory
+ *    Manager Result Codes".
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern Handle 
+NewEmptyHandle(void)                                          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  HLock()
+ *  
+ *  Summary:
+ *    Lock a relocatable block so that it does not move in the heap
+ *  
+ *  Discussion:
+ *    The HLock procedure locks the relocatable block to which h is a
+ *    handle, preventing it from being moved within its heap zone. If
+ *    the block is already locked,HLock does nothing.
+ *    
+ *    On Mac OS X, the behaviour of the Memory Manager and of heaps in
+ *    general is different than on Mac OS 9.x and earlier. In
+ *    particular, the heap on Mac OS X is never purged or compacted. 
+ *    Therefore, an unlocked handle will never be relocated except as a
+ *    result of a direct action by something calling SetHandleSize() or
+ *    by using a function like PtrAndHand() which implicitly resizes
+ *    the handle to append data to it.  Because of this, most locking
+ *    and unlocking of handles is unnecessary on Mac OS X, and the use
+ *    of HLock() and other functions is being deprecated.  If you
+ *    define a macro named __MAC_OS_X_MEMORY_MANAGER_CLEAN__ to 1 in
+ *    your sources before you include MacMemory.h, then HLock() and
+ *    several other functions will become empty operations, removing
+ *    the overhead of a function call.
+ *    
+ *    However, some applications are relying on the behavior that
+ *    resizing a locked handle produces an error, or tracking the state
+ *    of the locked bit for a give handle via the HGetState() function.
+ *     Applications which rely on this can not use
+ *    __MAC_OS_X_MEMORY_MANAGER_CLEAN__.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Parameters:
+ *    
+ *    h:
+ *      the handle to lock.  If h is == NULL, then HLock() sets
+ *      MemError() to noErr.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern void 
+HLock(Handle h)                                               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  HLockHi()
+ *  
+ *  Summary:
+ *    Lock a relocatable handle.
+ *  
+ *  Discussion:
+ *    The HLockHi() function locks a handle in memory.  On versions of
+ *    Mac OS before Mac OS X, it would first attempt to move the handle
+ *    as high in memory as feasible.  However, on Mac OS X and later,
+ *    there is no advantage to having handles high in memory, and so
+ *    this function never moves a handle before locking it.
+ *    See the discussion about handle locking above the function
+ *    HLock().
+ *  
+ *  Mac OS X threading:
+ *    Not thread safe
+ *  
+ *  Parameters:
+ *    
+ *    h:
+ *      the handle to lock.  If h is == NULL, then HLockHi() sets
+ *      MemError() to noErr.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern void 
+HLockHi(Handle h)                                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+
+/*
+ *  HUnlock()
+ *  
+ *  Summary:
+ *    Unlock a relocatable block so that it does not move in the heap
+ *  
+ *  Discussion:
+ *    The HUnlock procedure unlocks the relocatable block to which h is
+ *    a handle, allowing it from being moved within its heap zone. If
+ *    the block is already unlocked, HUnlock does nothing.
+ *    
+ *    See the discussion about handles and locking on Mac OS X above
+ *    the HLock() function.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Parameters:
+ *    
+ *    h:
+ *      the handle to unlock.  If h is == NULL, then HUnlock() sets
+ *      MemError() to noErr.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern void 
+HUnlock(Handle h)                                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+#if !__LP64__
+/*
+ *  HPurge()   *** DEPRECATED ***
+ *  
+ *  Summary:
+ *    Mark a relocatable block so that it does can be purged if a
+ *    memory request cannot be fulfilled after compaction of the heap
+ *  
+ *  Discussion:
+ *    The HPurge procedure makes the relocatable block to which h is a
+ *    handle purgeable. If the block is already purgeable, HPurge does
+ *    nothing.
+ *    
+ *    On Mac OS X, heaps are never purged.  Therefore, the use of
+ *    HPurge() and its associated functios is deprecated. If you define
+ *    a macro __MAC_OS_X_MEMORY_MANAGER_CLEAN__ in your sources before
+ *    you include MacMemory.h, then any calls to HPurge() in your
+ *    program will essentially be removed.
+ *    
+ *    However, some applications may set the handle as purgeable, and
+ *    then later check the purgeBit for the handle via HGetState().  If
+ *    your application depends on the purge bit being set for handles,
+ *    you will not be able to take advantage of this macro.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Parameters:
+ *    
+ *    h:
+ *      the handle to mark as purgeable.  If h is == NULL, then
+ *      HPurge() just sets MemError() to noErr.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern void 
+HPurge(Handle h)                                              AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  HNoPurge()   *** DEPRECATED ***
+ *  
+ *  Summary:
+ *    Mark a relocatable block so that it can not be purged.
+ *  
+ *  Discussion:
+ *    The HNoPurge procedure makes the relocatable block to which h is
+ *    a handle unpurgeable. See the discussion about purgable handles
+ *    above the HPurge() function.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Parameters:
+ *    
+ *    h:
+ *      the handle to mark as nonpurgeable.  If h is == NULL, then
+ *      HPurge() just sets MemError() to noErr.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern void 
+HNoPurge(Handle h)                                            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+#endif  /* !__LP64__ */
+
+/*
+ *  TempNewHandle()
+ *  
+ *  Summary:
+ *    Allocate a relocatable memory block of a specified size.
+ *  
+ *  Discussion:
+ *    The TempNewHandle function attempts to allocate a new relocatable
+ *    block in the current heap zone with a logical size of logicalSize
+ *    bytes and then return a handle to the block. The new block is
+ *    unlocked and unpurgeable. If NewHandle cannot allocate a block of
+ *    the requested size, it returns NULL.  The memory block returned
+ *    likely will contain garbage.
+ *    
+ *    WARNING
+ *    
+ *    Do not try to manufacture your own handles without this function
+ *    by simply assigning the address of a variable of type Ptr to a
+ *    variable of type Handle. The resulting "fake handle" would not
+ *    reference a relocatable block and could cause a system crash.
+ *     If this function returns NIL, the error result can be determined
+ *    by calling the function MemError().
+ *    
+ *    On Mac OS X, there is no temporary memory heap, and thus no
+ *    difference between the handles returned by TempNewHandle() and
+ *    those returned by NewHandle().  The only difference between the
+ *    two is that TempNewHandle() also returns the error result of the
+ *    call in resultCode.
+ *  
+ *  Mac OS X threading:
+ *    Not thread safe
+ *  
+ *  Parameters:
+ *    
+ *    logicalSize:
+ *      the size of the relocatable memory block to allocate.  If this
+ *      value is < 0, NIL will be returned. If this value is 0, a
+ *      handle to 0 byte block will be returned.
+ *    
+ *    resultCode:
+ *      On exit, this will be set to the result of the operation.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern Handle 
+TempNewHandle(
+  Size     logicalSize,
+  OSErr *  resultCode)                                        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+#if !__LP64__
+/*
+ *  TempMaxMem()   *** DEPRECATED ***
+ *  
+ *  Summary:
+ *    Return the maximum amount of temporary memory available
+ *  
+ *  Discussion:
+ *    On Mac OS X, this function always returns a large value, because
+ *    virtual memory is always available to fulfill any request for
+ *    memory.  This function is deprecated on Mac OS X and later.  You
+ *    can assume that any reasonable memory allocation will succeed.
+ *  
+ *  Mac OS X threading:
+ *    Not thread safe
+ *  
+ *  Parameters:
+ *    
+ *    grow:
+ *      If != NULL, then this is filled in with the the value 0.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern Size 
+TempMaxMem(Size * grow)                                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  TempFreeMem()   *** DEPRECATED ***
+ *  
+ *  Summary:
+ *    Return the maximum amount of free memory in the temporary heap.
+ *  
+ *  Discussion:
+ *    On Mac OS X, there is no separate temporary memory heap.  This
+ *    function always returns a large value, because virtual memory is
+ *    always available to fulfill any request for memory.  This
+ *    function is deprecated on Mac OS X and later.  You can assume
+ *    that any reasonable memory allocation will succeed.
+ *  
+ *  Mac OS X threading:
+ *    Not thread safe
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern long 
+TempFreeMem(void)                                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  CompactMem()   *** DEPRECATED ***
+ *  
+ *  Summary:
+ *    Compact the heap by purging and moving blocks such that at least
+ *    cbNeeded bytes are available, if possible.
+ *  
+ *  Discussion:
+ *    On Mac OS X and later, blocks are never purged and memory heaps
+ *    will grow as necessary, so compaction is never necessary nor
+ *    performed.
+ *  
+ *  Mac OS X threading:
+ *    Not thread safe
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern Size 
+CompactMem(Size cbNeeded)                                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  PurgeMem()   *** DEPRECATED ***
+ *  
+ *  Summary:
+ *    Purge blocks from the heap until cbNeeded bytes are available, if
+ *    possible.
+ *  
+ *  Discussion:
+ *    On Mac OS X and later, blocks are never purged and memory heaps
+ *    will grow as necessary, so purging of a heap is never necessary
+ *    nor performed.
+ *  
+ *  Mac OS X threading:
+ *    Not thread safe
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern void 
+PurgeMem(Size cbNeeded)                                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  FreeMem()   *** DEPRECATED ***
+ *  
+ *  Summary:
+ *    Return the maximum amount of free memory in the temporary heap.
+ *  
+ *  Discussion:
+ *    On Mac OS X, this function always returns a large value, because
+ *    virtual memory is always available to fulfill any request for
+ *    memory.  This function is deprecated on Mac OS X and later.  You
+ *    can assume that any reasonable memory allocation will succeed.
+ *  
+ *  Mac OS X threading:
+ *    Not thread safe
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern long 
+FreeMem(void)                                                 AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/*
+ *  MaxMem()   *** DEPRECATED ***
+ *  
+ *  Summary:
+ *    Return the maximum amount of free memory available
+ *  
+ *  Discussion:
+ *    On Mac OS X, this function always returns a large value, because
+ *    virtual memory is always available to fulfill any request for
+ *    memory.  This function is deprecated on Mac OS X and later.  You
+ *    can assume that any reasonable memory allocation will succeed.
+ *  
+ *  Mac OS X threading:
+ *    Not thread safe
+ *  
+ *  Parameters:
+ *    
+ *    grow:
+ *      If != NULL, then this is filled in with the the value 0.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern Size 
+MaxMem(Size * grow)                                           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/*
+ *  SetGrowZone()   *** DEPRECATED ***
+ *  
+ *  Summary:
+ *    Set a function which is called when a heap is grown
+ *  
+ *  Discussion:
+ *    On Mac OS X and later, heaps never grow, and so the function set
+ *    by SetGrowZone() is never called.
+ *  
+ *  Mac OS X threading:
+ *    Not thread safe
+ *  
+ *  Parameters:
+ *    
+ *    growZone:
+ *      a upp for a function to call when a heap needs to be grown
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern void 
+SetGrowZone(GrowZoneUPP growZone)                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  GetGrowZone()   *** DEPRECATED ***
+ *  
+ *  Summary:
+ *    Get the function which is called when a heap is grown
+ *  
+ *  Discussion:
+ *    On Mac OS X and later, heaps never grow, and so this function (
+ *    set by SetGrowZone() ) is never called.
+ *  
+ *  Mac OS X threading:
+ *    Not thread safe
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.1 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern GrowZoneUPP 
+GetGrowZone(void)                                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  MoveHHi()   *** DEPRECATED ***
+ *  
+ *  Summary:
+ *    Move a handle as high in memory as possible
+ *  
+ *  Discussion:
+ *    On versions of Mac OS before Mac OS X, MoveHHi() would move the
+ *    handle as high in memory as feasible. However, on Mac OS X and
+ *    later, there is no advantage to having handles high in memory,
+ *    and so this function never moves a handle before locking it.
+ *     See the discussion about handle locking above the function
+ *    HLock().
+ *  
+ *  Mac OS X threading:
+ *    Not thread safe
+ *  
+ *  Parameters:
+ *    
+ *    h:
+ *      the handle to move
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern void 
+MoveHHi(Handle h)                                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+#endif  /* !__LP64__ */
+
+/*
+ *  DisposePtr()
+ *  
+ *  Summary:
+ *    Release memory occupied by a nonrelocatable block
+ *  
+ *  Discussion:
+ *    When you no longer need a nonrelocatable block, call the
+ *    DisposePtr function to free it for other uses.
+ *    Call the function MemError to get the result code. See "Memory
+ *    Manager Result Codes".
+ *    After a call to DisposePtr, all pointers to the released block
+ *    become invalid and should not be used again. Any subsequent use
+ *    of a pointer to the released block might cause a system error. 
+ *    You can pass the value NULL as the pointer to dispose.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Parameters:
+ *    
+ *    p:
+ *      A pointer to the nonrelocatable block you want to dispose of
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern void 
+DisposePtr(Ptr p)                                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  GetPtrSize()
+ *  
+ *  Summary:
+ *    Returns the logical size of the nonrelocatable block
+ *    corresponding to a pointer.
+ *  
+ *  Discussion:
+ *    This function returns the number of bytes used for the given
+ *    pointer.  Call the function MemError to get the result code. See
+ *    "Memory Manager Result Codes".
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Parameters:
+ *    
+ *    p:
+ *      a pointer to a nonrelocatable block.
+ *  
+ *  Result:
+ *    The logical size, in bytes, of the nonrelocatable block pointed
+ *    to by p. In case of error, the function returns 0.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern Size 
+GetPtrSize(Ptr p)                                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  SetPtrSize()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern void 
+SetPtrSize(
+  Ptr    p,
+  Size   newSize)                                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  DisposeHandle()
+ *  
+ *  Summary:
+ *    Releases memory occupied by a relocatable block.
+ *  
+ *  Discussion:
+ *    The DisposeHandle function releases the memory occupied by the
+ *    relocatable block whose handle is h. It also frees the handleÕs
+ *    master pointer for other uses.
+ *    Do not use DisposeHandle to dispose of a handle obtained from the
+ *    Resource Manager (for example, by a previous call to
+ *    GetResource), useReleaseResource instead. If, however, you have
+ *    called DetachResource on a resource handle, you should dispose of
+ *    the storage by callingDisposeHandle.
+ *    Call the function MemError to get the result code. See "Memory
+ *    Manager Result Codes".
+ *    After a call to DisposeHandle, all handles to the released block
+ *    become invalid and should not be used again. Any subsequent calls
+ *    to DisposeHandleusing an invalid handle might damage the master
+ *    pointer list.  You can pass the value NULL as the handle to
+ *    dispose.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Parameters:
+ *    
+ *    h:
+ *      A handle to a relocatable block.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern void 
+DisposeHandle(Handle h)                                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  SetHandleSize()
+ *  
+ *  Summary:
+ *    Changes the logical size of the relocatable block corresponding
+ *    to the specified handle.
+ *  
+ *  Discussion:
+ *    Change the logical size of the relocatable block corresponding to
+ *    the specified handle. SetHandleSize might need to move the
+ *    relocatable block to obtain enough space for the resized block.
+ *    Thus, for best results you should unlock a block before resizing
+ *    it.
+ *    
+ *    An attempt to increase the size of a locked block might fail,
+ *    because of blocks above and below it that are either
+ *    nonrelocatable or locked. You should be prepared for this
+ *    possibility.
+ *    
+ *    Instead of using the SetHandleSize function to set the size of a
+ *    handle to 0, you can use the EmptyHandle function.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Parameters:
+ *    
+ *    h:
+ *      a handle to a relocatable block.
+ *    
+ *    newSize:
+ *      the desired new logical size, in bytes, of the relocatable
+ *      block.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern void 
+SetHandleSize(
+  Handle   h,
+  Size     newSize)                                           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  GetHandleSize()
+ *  
+ *  Summary:
+ *    Returns the logical size of the relocatable block corresponding
+ *    to a handle.
+ *  
+ *  Discussion:
+ *    Returns the logical size of the relocatable block corresponding
+ *    to a handle.  Call the function MemError to get the result code.
+ *    See "Memory Manager Result Codes".
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Parameters:
+ *    
+ *    h:
+ *      a handle to a relocatable block.
+ *  
+ *  Result:
+ *    The logical size, in bytes, of the relocatable block whose handle
+ *    is h. In case of error, the function return 0.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern Size 
+GetHandleSize(Handle h)                                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  ReallocateHandle()
+ *  
+ *  Summary:
+ *    Allocates a new relocatable block of a specified size and sets a
+ *    handleÕs master pointer to point to the new block.
+ *  
+ *  Discussion:
+ *    Usually you use ReallocateHandle to reallocate space for a block
+ *    that you have emptied. If the handle references an existing
+ *    block, ReallocateHandle releases that block before creating a new
+ *    one.
+ *    
+ *    To reallocate space for a resource that has been purged, you
+ *    should call LoadResource, not ReallocateHandle. To resize
+ *    relocatable blocks, you should call the SetHandleSize
+ *    function.
+ *    
+ *    Call the function MemError to get the result code. See "Memory
+ *    Manager Result Codes".
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Parameters:
+ *    
+ *    h:
+ *      A handle to a relocatable block.
+ *    
+ *    byteCount:
+ *      the desired new logical size (in bytes) of the relocatable
+ *      block. The new block is unlocked and unpurgeable.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern void 
+ReallocateHandle(
+  Handle   h,
+  Size     byteCount)                                         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  EmptyHandle()
+ *  
+ *  Summary:
+ *    Purges a relocatable block and sets the corresponding handleÕs
+ *    master pointer to NULL.
+ *  
+ *  Discussion:
+ *    The EmptyHandle function purges the relocatable block whose
+ *    handle is h and sets the handleÕs master pointer to NULL. The
+ *    EmptyHandle function allows you to free memory taken by a
+ *    relocatable block without freeing the relocatable blockÕs master
+ *    pointer for other uses. The block whose handle is h must be
+ *    unlocked but need not be purgeable.
+ *    
+ *    Note that if there are multiple handles to the relocatable block,
+ *    then calling the EmptyHandle function empties them all, because
+ *    all of the handles share a common master pointer. When you later
+ *    use ReallocateHandle to reallocate space for the block, the
+ *    master pointer is updated, and all of the handles reference the
+ *    new block correctly.
+ *    
+ *    To free the memory taken up by a relocatable block and release
+ *    the blockÕs master pointer for other uses, use the DisposeHandle
+ *    function.
+ *    
+ *    Call the function MemError to get the result code. See "Memory
+ *    Manager Result Codes".
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Parameters:
+ *    
+ *    h:
+ *      a handle to a relocatable block.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern void 
+EmptyHandle(Handle h)                                         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  HSetRBit()
+ *  
+ *  Summary:
+ *    Set the "R" bit for the handle state.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern void 
+HSetRBit(Handle h)                                            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  HClrRBit()
+ *  
+ *  Summary:
+ *    Clear the "R" bit for the handle state.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern void 
+HClrRBit(Handle h)                                            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  HGetState()
+ *  
+ *  Summary:
+ *    Get the current state of the handle's locked, purgeable, and R
+ *    bits
+ *  
+ *  Discussion:
+ *    The HGetState function returns a signed byte (char) containing
+ *    the flags of the master pointer for the given handle. You can
+ *    save this byte, change the state of any of the flags using the
+ *    functions described in this section, and then restore their
+ *    original states by passing the byte to the HSetState
+ *    function.
+ *    
+ *    You can use bit-manipulation functions on the returned signed
+ *    byte to determine the value of a given attribute.
+ *    Currently the following bits are used:
+ *    kHandleIsResourceBit    - if set, handle is a resource
+ *     kHandlePurgeableBit - if set, handle is purgeable
+ *     kHandleLockedBit - if set, handle is locked
+ *    On Mac OS X and later, heaps are never purged, so the purgeable
+ *    bit is used but its setting is essentially ignored. Also, since
+ *    heaps are never compacted, and therefore the only time a handle
+ *    moves is when that handle is resized, the danger of using
+ *    defererenced handles is lower and so handles likely do not need
+ *    to be locked as often. Because of this, the state for a handle is
+ *    less useful, and HGetState() and other functions is being
+ *    deprecated.  If you define a macro named
+ *    __MAC_OS_X_MEMORY_MANAGER_CLEAN__ in your sources before you
+ *    include MacMemory.h, then HGetState() and several other functions
+ *    will become empty operations, removing the overhead of a function
+ *    call.
+ *    
+ *    However, some applications may depend on the state bits of a
+ *    handle being correct or changing as functions like HLock(), etc.,
+ *    are called.  Applications which rely on this can not use
+ *    __MAC_OS_X_MEMORY_MANAGER_CLEAN__.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Parameters:
+ *    
+ *    h:
+ *      the handle to get the state for
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern SInt8 
+HGetState(Handle h)                                           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  HSetState()
+ *  
+ *  Summary:
+ *    Set the current state of the handle's locked, purgeable, and R
+ *    bits
+ *  
+ *  Discussion:
+ *    See the discussion about handle state and Mac OS X above the
+ *    function HGetState().
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Parameters:
+ *    
+ *    h:
+ *      the handle to set the state for
+ *    
+ *    flags:
+ *      the flags to set for the handle
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern void 
+HSetState(
+  Handle   h,
+  SInt8    flags)                                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*****************************************************************************
+
+    Beginning in Mac OS X Tiger, BlockMove, BlockMoveData, BlockMoveUncached,
+    BlockMoveDataUncached, BlockZero, and BlockZeroUncached are inlined to a
+    direct call to the posix memmove or bzero functions; this allows the 
+    compiler to optimize in some cases.
+    
+    However, CarbonCore.framework still exports functions with these names,
+    both so old code which linked them there will run and to support
+    compilers which don't support inline function definitions.
+
+    To use the exported version of BlockMove, #define NO_BLOCKMOVE_INLINE
+    in your source code ( or prefix header file ) before including any headers
+    which would include MacMemory.h.
+    
+*****************************************************************************/
+
+#if ! __LP64__
+    #if ! NO_BLOCKMOVE_INLINE && ( defined(__cplusplus) || ( defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L ) )
+  static inline void BlockMove(const void *srcPtr,void *destPtr,Size byteCount) { if ( byteCount > 0 ) memmove( destPtr, srcPtr, byteCount ); }
+  #elif ! NO_BLOCKMOVE_INLINE && defined( __GCC__ ) 
+ extern __inline__ void BlockMove(const void *srcPtr,void *destPtr,Size byteCount) { if ( byteCount > 0 ) memmove( destPtr, srcPtr, byteCount ); }
+  #else
+  extern void BlockMove(const void *srcPtr,void *destPtr,Size byteCount);
+    #endif
+#endif // !__LP64__
+
+#if ! __LP64__
+    #if ! NO_BLOCKMOVE_INLINE && ( defined(__cplusplus) || ( defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L ) )
+  static inline void BlockMoveData(const void *srcPtr,void *destPtr,Size byteCount) { if ( byteCount > 0 ) memmove( destPtr, srcPtr, byteCount ); }
+  #elif ! NO_BLOCKMOVE_INLINE && defined( __GCC__ ) 
+ extern __inline__ void BlockMoveData(const void *srcPtr,void *destPtr,Size byteCount) { if ( byteCount > 0 ) memmove( destPtr, srcPtr, byteCount ); }
+  #else
+  extern void BlockMoveData(const void *srcPtr,void *destPtr,Size byteCount);
+    #endif
+#endif // !__LP64__
+
+#if ! __LP64__
+    #if ! NO_BLOCKMOVE_INLINE && ( defined(__cplusplus) || ( defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L ) )
+  static inline void BlockMoveUncached(const void *srcPtr,void *destPtr,Size byteCount) { if ( byteCount > 0 ) memmove( destPtr, srcPtr, byteCount ); }
+  #elif ! NO_BLOCKMOVE_INLINE && defined( __GCC__ ) 
+ extern __inline__ void BlockMoveUncached(const void *srcPtr,void *destPtr,Size byteCount) { if ( byteCount > 0 ) memmove( destPtr, srcPtr, byteCount ); }
+  #else
+  extern void BlockMoveUncached(const void *srcPtr,void *destPtr,Size byteCount);
+    #endif
+#endif // !__LP64__
+
+#if ! __LP64__
+    #if ! NO_BLOCKMOVE_INLINE && ( defined(__cplusplus) || ( defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L ) )
+  static inline void BlockMoveDataUncached(const void *srcPtr,void *destPtr,Size byteCount) { if ( byteCount > 0 ) memmove( destPtr, srcPtr, byteCount ); }
+  #elif ! NO_BLOCKMOVE_INLINE && defined( __GCC__ ) 
+ extern __inline__ void BlockMoveDataUncached(const void *srcPtr,void *destPtr,Size byteCount) { if ( byteCount > 0 ) memmove( destPtr, srcPtr, byteCount ); }
+  #else
+  extern void BlockMoveDataUncached(const void *srcPtr,void *destPtr,Size byteCount);
+    #endif
+#endif // !__LP64__
+
+#if ! __LP64__
+    #if ! NO_BLOCKMOVE_INLINE && ( defined(__cplusplus) || ( defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L ) )
+  static inline void BlockZero(void *destPtr,Size byteCount) { if ( byteCount > 0 ) bzero( destPtr, byteCount ); }
+   #elif ! NO_BLOCKMOVE_INLINE && defined( __GCC__ ) 
+ extern __inline__ void BlockZero(void *destPtr,Size byteCount) { if ( byteCount > 0 ) bzero( destPtr, byteCount ); }
+   #else
+  extern void BlockZero(void *destPtr,Size byteCount);
+   #endif
+#endif // !__LP64__
+
+#if ! __LP64__
+    #if ! NO_BLOCKMOVE_INLINE && ( defined(__cplusplus) || ( defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L ) )
+  static inline void BlockZeroUncached(void *destPtr,Size byteCount) { if ( byteCount > 0 ) bzero( destPtr, byteCount ); }
+   #elif ! NO_BLOCKMOVE_INLINE && defined( __GCC__ ) 
+ extern __inline__ void BlockZeroUncached(void *destPtr,Size byteCount) { if ( byteCount > 0 ) bzero( destPtr, byteCount ); }
+   #else
+  extern void BlockZeroUncached(void *destPtr,Size byteCount);
+   #endif
+#endif // !__LP64__
+/*
+ *  HandToHand()
+ *  
+ *  Summary:
+ *    Copies all of the data from one relocatable block to a new
+ *    relocatable block.
+ *  
+ *  Discussion:
+ *    The HandToHand function attempts to copy the information in the
+ *    relocatable block to which theHndl is a handle; if successful,
+ *    HandToHand sets theHndlto a handle pointing to the new
+ *    relocatable block.
+ *    
+ *    If successful in creating a new relocatable block, the HandToHand
+ *    function does not duplicate the properties of the original block.
+ *    The new block is unlocked, unpurgeable, and not a resource. Call
+ *    HLock or HPurge to adjust the properties of the new
+ *    block.
+ *    
+ *    To copy only part of a relocatable block into a new relocatable
+ *    block, use the PtrToHand function. Before calling PtrToHand, lock
+ *    and dereference the handle pointing to the relocatable block you
+ *    want to copy.
+ *    
+ *    Because HandToHand replaces its parameter with the new handle,
+ *    you should retain the original parameter value somewhere else,
+ *    otherwise you will not be able to access it.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Parameters:
+ *    
+ *    theHndl:
+ *      a handle to the relocatable block whose data HandToHand will
+ *      copy.  On return, theHndl contains a handle to a new
+ *      relocatable block whose data duplicates the original.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+HandToHand(Handle * theHndl)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PtrToXHand()
+ *  
+ *  Summary:
+ *    Copies data referenced by a pointer to an existing relocatable
+ *    block.
+ *  
+ *  Discussion:
+ *    The PtrToXHand function copies the specified number of bytes from
+ *    the location specified by srcPtr to the handle specified by
+ *    dstHndl.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Parameters:
+ *    
+ *    srcPtr:
+ *      the address of the first byte to copy.
+ *    
+ *    dstHndl:
+ *      a handle to an existing relocatable block.
+ *    
+ *    size:
+ *      the number of bytes to copy.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+PtrToXHand(
+  const void *  srcPtr,
+  Handle        dstHndl,
+  long          size)                                         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PtrToHand()
+ *  
+ *  Summary:
+ *    Copies data referenced by a pointer to a new relocatable block.
+ *  
+ *  Discussion:
+ *    If you dereference and lock a handle, the PtrToHand function can
+ *    copy its data to a new handle. However, for copying data from one
+ *    handle to another, the HandToHand function is more efficient.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Parameters:
+ *    
+ *    srcPtr:
+ *      the address of the first byte to copy.
+ *    
+ *    dstHndl:
+ *      a handle for which you have not yet allocated any memory. The
+ *      PtrToHand function allocates memory for the handle and copies
+ *      the specified number of bytes beginning at srcPtr into it. The
+ *      dstHndl parameter is an output parameter that will hold the
+ *      result. Its value on entry is ignored. If no error occurs, on
+ *      exit it points to an unlocked, non-purgeable Handle of the
+ *      requested size.
+ *    
+ *    size:
+ *      the number of bytes to copy.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+PtrToHand(
+  const void *  srcPtr,
+  Handle *      dstHndl,
+  long          size)                                         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  HandAndHand()
+ *  
+ *  Summary:
+ *    Use the HandAndHand function to concatenate two relocatable
+ *    blocks.
+ *  
+ *  Discussion:
+ *    The HandAndHand function concatenates the information from the
+ *    relocatable block to which aHndl is a handle onto the end of the
+ *    relocatable block to which bHndl is a handle. The aHndl variable
+ *    remains unchanged.
+ *    
+ *    WARNING
+ *    
+ *    The HandAndHand function dereferences the handle aHndl. You must
+ *    call the HLock procedure to lock the block before calling
+ *    HandAndHand. Afterward, you can call the HUnlock procedure to
+ *    unlock it. Alternatively, you can save the block's original state
+ *    by calling the HGetState function, lock the block by calling
+ *    HLock, and then restore the original settings by calling
+ *    HSetState.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Parameters:
+ *    
+ *    hand1:
+ *      A handle to the first relocatable block, whose contents do not
+ *      change but are concatenated to the end of the second
+ *      relocatable block.
+ *    
+ *    hand2:
+ *      A handle to the second relocatable block, whose size the Memory
+ *      Manager expands so that it can concatenate the information from
+ *      aHndl to the end of the contents of this block.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+HandAndHand(
+  Handle   hand1,
+  Handle   hand2)                                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  PtrAndHand()
+ *  
+ *  Summary:
+ *    Concatenates part or all of a memory block to the end of a
+ *    relocatable block.
+ *  
+ *  Discussion:
+ *    The PtrAndHand function takes the number of bytes specified by
+ *    the size parameter, beginning at the location specified by ptr1,
+ *    and concatenates them onto the end of the relocatable block to
+ *    which hand2 is a handle. The contents of the source block remain
+ *    unchanged.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Parameters:
+ *    
+ *    ptr1:
+ *      a pointer to the beginning of the data that the Memory Manager
+ *      is to concatenate onto the end of the relocatable block.
+ *    
+ *    hand2:
+ *      a handle to the relocatable block, whose size the Memory
+ *      Manager expands so that it can concatenate the information from
+ *      ptr1 onto the end of this block.
+ *    
+ *    size:
+ *      the number of bytes of the block referenced by ptr1 to copy.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+PtrAndHand(
+  const void *  ptr1,
+  Handle        hand2,
+  long          size)                                         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+#if !__LP64__
+/*
+ *  MoreMasters()   *** DEPRECATED ***
+ *  
+ *  Discussion:
+ *    On Mac OS X and later, master pointers do not need to be
+ *    pre-allocated.
+ *  
+ *  Mac OS X threading:
+ *    Not thread safe
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern void 
+MoreMasters(void)                                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  MoreMasterPointers()   *** DEPRECATED ***
+ *  
+ *  Discussion:
+ *    On Mac OS X and later, master pointers do not need to be
+ *    pre-allocated.
+ *  
+ *  Mac OS X threading:
+ *    Not thread safe
+ *  
+ *  Parameters:
+ *    
+ *    inCount:
+ *      the number of master pointers to preallocate
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern void 
+MoreMasterPointers(UInt32 inCount)                            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*  Temporary Memory routines renamed, but obsolete, in System 7.0 and later.  */
+/*
+ *  TempHLock()   *** DEPRECATED ***
+ *  
+ *  Discussion:
+ *    This function has been deprecated for many years; replace it with
+ *    HLock()
+ *  
+ *  Mac OS X threading:
+ *    Not thread safe
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern void 
+TempHLock(
+  Handle   h,
+  OSErr *  resultCode)                                        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  TempHUnlock()   *** DEPRECATED ***
+ *  
+ *  Discussion:
+ *    This function has been deprecated for many years; replace it with
+ *    HUnlock()
+ *  
+ *  Mac OS X threading:
+ *    Not thread safe
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern void 
+TempHUnlock(
+  Handle   h,
+  OSErr *  resultCode)                                        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  TempDisposeHandle()   *** DEPRECATED ***
+ *  
+ *  Discussion:
+ *    This function has been deprecated for many years; replace it with
+ *    DisposeHandle()
+ *  
+ *  Mac OS X threading:
+ *    Not thread safe
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.5
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern void 
+TempDisposeHandle(
+  Handle   h,
+  OSErr *  resultCode)                                        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;
+
+
+/*
+ *  TempTopMem()   *** DEPRECATED ***
+ *  
+ *  Discussion:
+ *    Mac OS X and later does not have a seperate temporary memory
+ *    heap.  This function returns NULL.
+ *  
+ *  Mac OS X threading:
+ *    Not thread safe
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern Ptr 
+TempTopMem(void)                                              AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  HoldMemory()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    Mac OS X has never supported HoldMemory.  The functions in
+ *    ./sys/mman.h may be useful for replacing usage of these
+ *    functions, although Mac OS X does not allow the same level of
+ *    control over whether pages are held in memory or resident as Mac
+ *    OS 9.x did.
+ *    If you define a macro __MAC_OS_X_MEMORY_MANAGER_CLEAN__ in your
+ *    sources before you include MacMemory.h, then any calls to
+ *    HoldMemory() in your program will essentially be removed.
+ *  
+ *  Mac OS X threading:
+ *    Not thread safe
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.1 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+HoldMemory(
+  void *          address,
+  unsigned long   count)                                      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  UnholdMemory()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    Mac OS X has never supported MakeMemoryResident.  See the comment
+ *    above UnholdMemory for more information.
+ *  
+ *  Mac OS X threading:
+ *    Not thread safe
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.1 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+UnholdMemory(
+  void *          address,
+  unsigned long   count)                                      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  MakeMemoryResident()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    Mac OS X has never supported MakeMemoryResident.  See the comment
+ *    above UnholdMemory for more information.
+ *  
+ *  Mac OS X threading:
+ *    Not thread safe
+ *  
+ *  Parameters:
+ *    
+ *    address:
+ *      the address to make resident
+ *    
+ *    count:
+ *      the count of pages to make make resident
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0.2 and later
+ *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
+ */
+extern OSErr 
+MakeMemoryResident(
+  void *          address,
+  unsigned long   count)                                      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  ReleaseMemoryData()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    Mac OS X has never supported MakeMemoryResident.  See the comment
+ *    above UnholdMemory for more information.
+ *  
+ *  Mac OS X threading:
+ *    Not thread safe
+ *  
+ *  Parameters:
+ *    
+ *    address:
+ *      the address to make release
+ *    
+ *    count:
+ *      the count of pages to make make release
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0.2 and later
+ *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
+ */
+extern OSErr 
+ReleaseMemoryData(
+  void *          address,
+  unsigned long   count)                                      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  MakeMemoryNonResident()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    Mac OS X has never supported MakeMemoryResident.  See the comment
+ *    above UnholdMemory for more information.
+ *  
+ *  Mac OS X threading:
+ *    Not thread safe
+ *  
+ *  Parameters:
+ *    
+ *    address:
+ *      the address to make non-resident
+ *    
+ *    count:
+ *      the count of pages to make make non-resident
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0.2 and later
+ *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
+ */
+extern OSErr 
+MakeMemoryNonResident(
+  void *          address,
+  unsigned long   count)                                      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  FlushMemory()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    Mac OS X has never supported MakeMemoryResident.  See the comment
+ *    above UnholdMemory for more information.
+ *  
+ *  Mac OS X threading:
+ *    Not thread safe
+ *  
+ *  Parameters:
+ *    
+ *    address:
+ *      the address to flush
+ *    
+ *    count:
+ *      the count of pages to make flush
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0.2 and later
+ *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
+ */
+extern OSErr 
+FlushMemory(
+  void *          address,
+  unsigned long   count)                                      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+
+/*
+ *  GZSaveHnd()   *** DEPRECATED ***
+ *  
+ *  Summary:
+ *    This function is deprecated on Mac OS X and always returns NULL.
+ *  
+ *  Mac OS X threading:
+ *    Not thread safe
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern Handle 
+GZSaveHnd(void)                                               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  TopMem()   *** DEPRECATED ***
+ *  
+ *  Summary:
+ *    This function is deprecated on Mac OS X and always returns NULL.
+ *  
+ *  Mac OS X threading:
+ *    Not thread safe
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern Ptr 
+TopMem(void)                                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  ReserveMem()   *** DEPRECATED ***
+ *  
+ *  Summary:
+ *    This function is deprecated on Mac OS X.
+ *  
+ *  Mac OS X threading:
+ *    Not thread safe
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern void 
+ReserveMem(Size cbNeeded)                                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  PurgeSpace()   *** DEPRECATED ***
+ *  
+ *  Summary:
+ *    This function is deprecated on Mac OS X.
+ *  
+ *  Discussion:
+ *    On Mac OS X and later, heaps are never purged and therefore
+ *    PurgeSpace will always return a large value for both the total
+ *    space available and the largest block available.  You can assume
+ *    that any reasonable memory allocation will succeed.
+ *    
+ *    If you define a macro __MAC_OS_X_MEMORY_MANAGER_CLEAN__ in your
+ *    sources before you include MacMemory.h, then any calls to
+ *    PurgeSpace() in your program will essentially be removed.
+ *  
+ *  Mac OS X threading:
+ *    Not thread safe
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern void 
+PurgeSpace(
+  long *  total,
+  long *  contig)                                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  PurgeSpaceTotal()   *** DEPRECATED ***
+ *  
+ *  Summary:
+ *    This function is deprecated on Mac OS X.
+ *  
+ *  Discussion:
+ *    On Mac OS X and later, heaps are never purged and therefore
+ *    PurgeSpaceTotal will always return a large value. You can assume
+ *    that any reasonable memory allocation will succeed.
+ *  
+ *  Mac OS X threading:
+ *    Not thread safe
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
+ */
+extern long 
+PurgeSpaceTotal(void)                                         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  PurgeSpaceContiguous()   *** DEPRECATED ***
+ *  
+ *  Summary:
+ *    This function is deprecated on Mac OS X.
+ *  
+ *  Discussion:
+ *    On Mac OS X and later, heaps are never purged and therefore
+ *    PurgeSpaceContiguous will always return a large value. You can
+ *    assume that any reasonable memory allocation will succeed.
+ *  
+ *  Mac OS X threading:
+ *    Not thread safe
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
+ */
+extern long 
+PurgeSpaceContiguous(void)                                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+
+/* Carbon routines to aid in debugging. */
+/*
+ *  CheckAllHeaps()   *** DEPRECATED ***
+ *  
+ *  Summary:
+ *    Check all known heaps for validity.  Deprecated on Mac OS X,
+ *    since there really aren't heaps.  Use IsHeapValid() if you really
+ *    want this functionality.
+ *  
+ *  Mac OS X threading:
+ *    Not thread safe
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern Boolean 
+CheckAllHeaps(void)                                           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+#endif  /* !__LP64__ */
+
+/*
+ *  IsHeapValid()
+ *  
+ *  Summary:
+ *    Check if the heap is valid.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.4
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern Boolean 
+IsHeapValid(void)                                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/* It is invalid to pass a NULL or an empty Handle to IsHandleValid */
+/*
+ *  IsHandleValid()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern Boolean 
+IsHandleValid(Handle h)                                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/* It is invalid to pass a NULL Pointer to IsPointerValid */
+/*
+ *  IsPointerValid()
+ *  
+ *  Mac OS X threading:
+ *    Thread safe since version 10.3
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern Boolean 
+IsPointerValid(Ptr p)                                         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+#if !__LP64__
+#if OLDROUTINENAMES
+#define ApplicZone() ApplicationZone()
+#define MFTempNewHandle(logicalSize, resultCode) TempNewHandle(logicalSize, resultCode)
+#define MFMaxMem(grow) TempMaxMem(grow)
+#define MFFreeMem() TempFreeMem()
+#define MFTempHLock(h, resultCode) TempHLock(h, resultCode)
+#define MFTempHUnlock(h, resultCode) TempHUnlock(h, resultCode)
+#define MFTempDisposHandle(h, resultCode) TempDisposeHandle(h, resultCode)
+#define MFTopMem() TempTopMem()
+#define ResrvMem(cbNeeded) ReserveMem(cbNeeded)
+#define DisposPtr(p) DisposePtr(p)
+#define DisposHandle(h) DisposeHandle(h)
+#define ReallocHandle(h, byteCount) ReallocateHandle(h, byteCount)
+#endif  /* OLDROUTINENAMES */
+
+#endif  /* !__LP64__ */
+
+#if !__LP64__
+/*
+ *  LMGetSysZone()   *** DEPRECATED ***
+ *  
+ *  Summary:
+ *    This function is deprecated on Mac OS X.
+ *  
+ *  Mac OS X threading:
+ *    Not thread safe
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern THz 
+LMGetSysZone(void)                                            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  LMSetSysZone()   *** DEPRECATED ***
+ *  
+ *  Summary:
+ *    This function is deprecated on Mac OS X.
+ *  
+ *  Mac OS X threading:
+ *    Not thread safe
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern void 
+LMSetSysZone(THz value)                                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  LMGetApplZone()   *** DEPRECATED ***
+ *  
+ *  Summary:
+ *    This function is deprecated on Mac OS X.
+ *  
+ *  Mac OS X threading:
+ *    Not thread safe
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern THz 
+LMGetApplZone(void)                                           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  LMSetApplZone()   *** DEPRECATED ***
+ *  
+ *  Summary:
+ *    This function is deprecated on Mac OS X.
+ *  
+ *  Mac OS X threading:
+ *    Not thread safe
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern void 
+LMSetApplZone(THz value)                                      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+
+#endif  /* !__LP64__ */
+
+#if __MAC_OS_X_MEMORY_MANAGER_CLEAN__
+
+#ifdef __cplusplus
+    inline void HLock(Handle ) { LMSetMemErr(0); }
+    inline void HLockHi(Handle ) { LMSetMemErr(0); }
+    inline void HUnlock(Handle ) { LMSetMemErr(0); }
+    inline void HSetRBit(Handle ) { LMSetMemErr(0); }
+    inline void HClrRBit(Handle ) { LMSetMemErr(0); }
+    inline SInt8 HGetState(Handle ) { LMSetMemErr(0); return 0; }
+    inline void HSetState(Handle , SInt8 ) { LMSetMemErr(0); }
+#if !__LP64__
+    inline void HPurge(Handle ) { LMSetMemErr(0); }
+    inline void HNoPurge(Handle ) { LMSetMemErr(0); }
+    inline void MoveHHi(Handle ) { LMSetMemErr(0); }
+    inline void TempHLock(Handle , OSErr *resultCode) { LMSetMemErr(0), *resultCode = 0; }
+    inline void TempHUnlock(Handle , OSErr *resultCode) { LMSetMemErr(0), *resultCode = 0; }
+
+    inline OSErr HoldMemory(void *, unsigned long ) { return noErr; }
+    inline OSErr UnholdMemory(void *, unsigned long ) { return noErr; }
+    inline OSErr MakeMemoryResident(void *, unsigned long ) { return noErr; }
+    inline OSErr ReleaseMemoryData(void *, unsigned long ) { return noErr; }
+    inline OSErr MakeMemoryNonResident(void *, unsigned long ) { return noErr; }
+    inline OSErr FlushMemory(void *, unsigned long ) { return noErr; }
+    inline void ReserveMem(Size ) { LMSetMemErr(0); }
+    inline void PurgeSpace(long *, long *) { LMSetMemErr(0); }
+    inline long PurgeSpaceTotal() { LMSetMemErr(0); }
+    inline long PurgeSpaceContiguous() { LMSetMemErr(0); }
+#endif
+
+
+#else
+    #define HLock(h) { LMSetMemErr(0); }
+    #define HLockHi(h) { LMSetMemErr(0); }
+    #define HUnlock(h) { LMSetMemErr(0); }
+    #define HSetRBit(h) { LMSetMemErr(0); }
+    #define HClrRBit(h) { LMSetMemErr(0); }
+    #define HGetState(h) ( LMSetMemErr(0), 0 )
+    #define HSetState(h, flags) { LMSetMemErr(0); }
+#if !__LP64__
+    #define HPurge(h) { LMSetMemErr(0); }
+    #define HNoPurge(h) { LMSetMemErr(0); }
+    #define MoveHHi(h) { LMSetMemErr(0); }
+    #define TempHLock(h, resultCode) { LMSetMemErr(0) ; *resultCode = 0; }
+    #define TempHUnlock(h, resultCode) { LMSetMemErr(0) ; *resultCode = 0; }
+
+    #define HoldMemory(address, count) ( address, count, noErr)
+    #define UnholdMemory(address, count) ( address, count, noErr)
+    #define MakeMemoryResident(address, count) ( address, count, noErr)
+    #define ReleaseMemoryData(address, count) ( address, count, noErr)
+    #define MakeMemoryNonResident(address, count) ( address, count, noErr)
+    #define FlushMemory(address, count) ( address, count, noErr)
+
+    #define ReserveMem(cbNeeded) { LMSetMemErr(0) }
+    #define PurgeSpace(total, contig) { LMSetMemErr(0); }
+    #define PurgeSpaceTotal() ( LMSetMemErr(0), 0 )
+    #define    PurgeSpaceContiguous()  ( LMSetMemErr(0), 0 )
+#endif
+#endif
+
+#endif  /* __MAC_OS_X_MEMORY_MANAGER_CLEAN__ */
+
+
+#pragma pack(pop)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __MACMEMORY__ */
+
diff -Nru ../CarbonHeaders-18.1.orig/MacTypes.h ./MacTypes.h
--- ../CarbonHeaders-18.1.orig/MacTypes.h	2009-09-29 13:46:25.000000000 -0700
+++ ./MacTypes.h	2009-09-29 14:01:07.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1985-2008 by Apple Inc.. All rights reserved.
+ * Copyright (c) 2007-2009 by Apple Inc.. All rights reserved.
  *
  * @APPLE_LICENSE_HEADER_START@
  * 
@@ -20,14 +20,15 @@
  * 
  * @APPLE_LICENSE_HEADER_END@
  */
- 
 /*
-     File:       MacTypes.h
+     File:       CarbonCore/MacTypes.h
  
      Contains:   Basic Macintosh data types.
  
-     Version:    CarbonCore-769~1
-  
+     Version:    CarbonCore-859.2~1
+ 
+     Copyright:  © 1985-2008 by Apple Computer, Inc., all rights reserved.
+ 
      Bugs?:      For bug reports, consult the following page on
                  the World Wide Web:
  
@@ -38,7 +39,7 @@
 #define __MACTYPES__
 
 #ifndef __CONDITIONALMACROS__
-#include <ConditionalMacros.h>
+#include <CarbonCore/ConditionalMacros.h>
 #endif
 
 #include <stdbool.h>
diff -Nru ../CarbonHeaders-18.1.orig/Makefile ./Makefile
--- ../CarbonHeaders-18.1.orig/Makefile	2009-09-29 13:46:25.000000000 -0700
+++ ./Makefile	2009-09-29 13:57:39.000000000 -0700
@@ -4,7 +4,7 @@
 CONFIG_IPHONE          = 0
 CONFIG_IPHONE_SIMULATOR= 0
 KERNEL_SYLINKS         = install_kernel_symlinks
-DO_CARBON_CORE_FILES   = 
+DO_CARBON_CORE_FILES   = install_carbon_core_headers
 
 SRCROOT ?= $(shell pwd)
 OBJROOT ?= $(SRCROOT)/obj
@@ -16,7 +16,14 @@
 		TargetConditionals.h AssertMacros.h
 
 # These files in SRCROOT get copied into /usr/include/ only for the phone builds
-CCFILES=ConditionalMacros.h Endian.h MacErrors.h MacTypes.h 
+# for open source builds, put headers in CarbonCore sub-framework
+CCFILES=Aliases.h ConditionalMacros.h DateTimeUtils.h Endian.h Files.h Finder.h MacErrors.h MacMemory.h MacTypes.h MixedMode.h OSUtils.h TextCommon.h UTCUtils.h
+CCDEST=/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/CarbonCore.framework/Versions/A/Headers
+CCLINK=/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/CarbonCore.framework/Headers
+CSDEST=/System/Library/Frameworks/CoreServices.framework/Versions/A/Headers
+CS_FRAMEWORKS=/System/Library/Frameworks/CoreServices.framework/Frameworks
+CS_HEADERS=/System/Library/Frameworks/CoreServices.framework/Headers
+
 DEST=$(INSTALL_PREFIX)/usr/include
 
 
@@ -33,10 +40,14 @@
 	done
 
 install_carbon_core_headers:
-	mkdir -p $(DSTROOT)/$(DEST)
+	mkdir -p $(DSTROOT)/$(CCDEST)
+	mkdir -p $(DSTROOT)/$(CSDEST)
+	ln -s Versions/A/Headers $(DSTROOT)/$(CCLINK)
+	ln -s Versions/A/Frameworks $(DSTROOT)/$(CS_FRAMEWORKS)
+	ln -s Versions/A/Headers $(DSTROOT)/$(CS_HEADERS)
 	for i in $(CCFILES); do \
-		cp $(SRCROOT)/$$i  $(DSTROOT)/$(DEST)/$$i; \
-		chmod 644 $(DSTROOT)/$(DEST)/$$i; \
+		cp $(SRCROOT)/$$i  $(DSTROOT)/$(CCDEST)/$$i; \
+		chmod 644 $(DSTROOT)/$(CCDEST)/$$i; \
 	done
 
 install_kernel_symlinks:
diff -Nru ../CarbonHeaders-18.1.orig/MixedMode.h ./MixedMode.h
--- ../CarbonHeaders-18.1.orig/MixedMode.h	1969-12-31 16:00:00.000000000 -0800
+++ ./MixedMode.h	2009-09-29 14:01:17.000000000 -0700
@@ -0,0 +1,558 @@
+/*
+ * Copyright (c) 2007-2009 by Apple Inc.. All rights reserved.
+ *
+ * @APPLE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this
+ * file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_LICENSE_HEADER_END@
+ */
+
+/*
+     File:       CarbonCore/MixedMode.h
+ 
+     Contains:   Mixed Mode Manager Interfaces.
+ 
+     Version:    CarbonCore-859.2~1
+ 
+     Copyright:  © 1992-2008 by Apple Computer, Inc., all rights reserved.
+ 
+     Bugs?:      For bug reports, consult the following page on
+                 the World Wide Web:
+ 
+                     http://developer.apple.com/bugreporter/
+ 
+*/
+#ifndef __MIXEDMODE__
+#define __MIXEDMODE__
+
+#ifndef __MACTYPES__
+#include <CarbonCore/MacTypes.h>
+#endif
+
+
+
+#include <AvailabilityMacros.h>
+
+#if PRAGMA_ONCE
+#pragma once
+#endif
+
+#pragma pack(push, 2)
+
+/*
+    ===========================================================================
+    
+    Notes on Mixed Mode and Mac OS X
+    
+    Mac OS X doesn't have mixed mode, nor the Mixed Mode Manager, because
+    everything running is PowerPC code.  Therefore, there is little need for
+    anything in this file unless the code still needs to run on Mac OS 9.x
+    CarbonLib, and on Mac OS X.
+
+    =========================================================================== 
+*/
+/* Mixed Mode constants */
+/* Current Routine Descriptor Version */
+enum {
+  kRoutineDescriptorVersion     = 7
+};
+
+/* MixedModeMagic Magic Cookie/Trap number */
+enum {
+  _MixedModeMagic               = 0xAAFE
+};
+
+/* MixedModeState Version for CFM68K Mixed Mode */
+enum {
+  kCurrentMixedModeStateRecord  = 1
+};
+
+/* Calling Conventions */
+typedef unsigned short                  CallingConventionType;
+enum {
+  kPascalStackBased             = 0,
+  kCStackBased                  = 1,
+  kRegisterBased                = 2,
+  kD0DispatchedPascalStackBased = 8,
+  kD1DispatchedPascalStackBased = 12,
+  kD0DispatchedCStackBased      = 9,
+  kStackDispatchedPascalStackBased = 14,
+  kThinkCStackBased             = 5
+};
+
+/* ISA Types */
+typedef SInt8                           ISAType;
+enum {
+  kM68kISA                      = 0,
+  kPowerPCISA                   = 1
+};
+
+enum {
+  kX86ISA                       = 2
+};
+
+/* RTA Types */
+typedef SInt8                           RTAType;
+enum {
+  kOld68kRTA                    = 0 << 4,
+  kPowerPCRTA                   = 0 << 4,
+  kCFM68kRTA                    = 1 << 4
+};
+
+enum {
+  kX86RTA                       = 2 << 4
+};
+
+
+#if TARGET_OS_MAC
+ #if TARGET_CPU_PPC
+     #define     GetCurrentISA()     ((ISAType) kPowerPCISA)
+        #define     GetCurrentRTA()     ((RTAType) kPowerPCRTA)
+
+   #elif TARGET_CPU_X86
+       #define     GetCurrentISA()     ((ISAType) kX86ISA)
+        #define     GetCurrentRTA()     ((RTAType) kX86RTA)
+
+   #endif
+ #define     GetCurrentArchitecture()    (GetCurrentISA() | GetCurrentRTA())
+#else
+  #define     GetCurrentArchitecture()    0
+#endif
+
+/* Constants for specifing 68k registers */
+enum {
+  kRegisterD0                   = 0,
+  kRegisterD1                   = 1,
+  kRegisterD2                   = 2,
+  kRegisterD3                   = 3,
+  kRegisterD4                   = 8,
+  kRegisterD5                   = 9,
+  kRegisterD6                   = 10,
+  kRegisterD7                   = 11,
+  kRegisterA0                   = 4,
+  kRegisterA1                   = 5,
+  kRegisterA2                   = 6,
+  kRegisterA3                   = 7,
+  kRegisterA4                   = 12,
+  kRegisterA5                   = 13,
+  kRegisterA6                   = 14,   /* A7 is the same as the PowerPC SP */
+  kCCRegisterCBit               = 16,
+  kCCRegisterVBit               = 17,
+  kCCRegisterZBit               = 18,
+  kCCRegisterNBit               = 19,
+  kCCRegisterXBit               = 20
+};
+
+typedef unsigned short                  registerSelectorType;
+/* SizeCodes we use everywhere */
+enum {
+  kNoByteCode                   = 0,
+  kOneByteCode                  = 1,
+  kTwoByteCode                  = 2,
+  kFourByteCode                 = 3
+};
+
+/* Mixed Mode Routine Records */
+typedef unsigned long                   ProcInfoType;
+/* Routine Flag Bits */
+typedef unsigned short                  RoutineFlagsType;
+enum {
+  kProcDescriptorIsAbsolute     = 0x00,
+  kProcDescriptorIsRelative     = 0x01
+};
+
+enum {
+  kFragmentIsPrepared           = 0x00,
+  kFragmentNeedsPreparing       = 0x02
+};
+
+enum {
+  kUseCurrentISA                = 0x00,
+  kUseNativeISA                 = 0x04
+};
+
+enum {
+  kPassSelector                 = 0x00,
+  kDontPassSelector             = 0x08
+};
+
+enum {
+  kRoutineIsNotDispatchedDefaultRoutine = 0x00,
+  kRoutineIsDispatchedDefaultRoutine = 0x10
+};
+
+enum {
+  kProcDescriptorIsProcPtr      = 0x00,
+  kProcDescriptorIsIndex        = 0x20
+};
+
+struct RoutineRecord {
+  ProcInfoType        procInfo;               /* calling conventions */
+  SInt8               reserved1;              /* Must be 0 */
+  ISAType             ISA;                    /* Instruction Set Architecture */
+  RoutineFlagsType    routineFlags;           /* Flags for each routine */
+  ProcPtr             procDescriptor;         /* Where is the thing weÕre calling? */
+  UInt32              reserved2;              /* Must be 0 */
+  UInt32              selector;               /* For dispatched routines, the selector */
+};
+typedef struct RoutineRecord            RoutineRecord;
+typedef RoutineRecord *                 RoutineRecordPtr;
+typedef RoutineRecordPtr *              RoutineRecordHandle;
+/* Mixed Mode Routine Descriptors */
+/* Definitions of the Routine Descriptor Flag Bits */
+typedef UInt8                           RDFlagsType;
+enum {
+  kSelectorsAreNotIndexable     = 0x00,
+  kSelectorsAreIndexable        = 0x01
+};
+
+/* Routine Descriptor Structure */
+struct RoutineDescriptor {
+  UInt16              goMixedModeTrap;        /* Our A-Trap */
+  SInt8               version;                /* Current Routine Descriptor version */
+  RDFlagsType         routineDescriptorFlags; /* Routine Descriptor Flags */
+  UInt32              reserved1;              /* Unused, must be zero */
+  UInt8               reserved2;              /* Unused, must be zero */
+  UInt8               selectorInfo;           /* If a dispatched routine, calling convention, else 0 */
+  UInt16              routineCount;           /* Number of routines in this RD */
+  RoutineRecord       routineRecords[1];      /* The individual routines */
+};
+typedef struct RoutineDescriptor        RoutineDescriptor;
+typedef RoutineDescriptor *             RoutineDescriptorPtr;
+typedef RoutineDescriptorPtr *          RoutineDescriptorHandle;
+/* 68K MixedModeStateRecord */
+struct MixedModeStateRecord {
+  UInt32              state1;
+  UInt32              state2;
+  UInt32              state3;
+  UInt32              state4;
+};
+typedef struct MixedModeStateRecord     MixedModeStateRecord;
+/*
+ *  NewRoutineDescriptor()   *** DEPRECATED ***
+ *  
+ *  Discussion:
+ *    This function is deprecated on Mac OS X and in CarbonLib because
+ *    routine descriptors existed to allow 68k code and PowerPC code to
+ *    call each other and get parameter marshalling and other OS
+ *    services.  Mac OS X is entirely PowerPC native, and does not
+ *    require the use of mixed mode.
+ *    You should remove any calls to NewRoutineDescriptor() from your
+ *    sources, and replace them with theProc parameter itself.
+ *  
+ *  Availability:
+ *    Mac OS X:         not available but deprecated in 10.4
+ *    CarbonLib:        not available
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+
+
+/*
+ *  DisposeRoutineDescriptor()   *** DEPRECATED ***
+ *  
+ *  Discussion:
+ *    DisposeRoutineDescriptor() is deprecated on Mac OS X. 
+ *    RoutineDescriptors are no longer used.
+ *    You should delete any calls to DisposeRoutineDescriptor() from
+ *    your sources.
+ *  
+ *  Availability:
+ *    Mac OS X:         not available but deprecated in 10.4
+ *    CarbonLib:        not available
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+
+
+
+   #define NewRoutineDescriptor(theProc, procInfo, isa) ((UniversalProcPtr) theProc)
+  #define DisposeRoutineDescriptor(upp)
+
+
+
+/* Mixed Mode ProcInfos */
+enum {
+                                        /* Calling Convention Offsets */
+  kCallingConventionWidth       = 4,
+  kCallingConventionPhase       = 0,
+  kCallingConventionMask        = 0x0F, /* Result Offsets */
+  kResultSizeWidth              = 2,
+  kResultSizePhase              = kCallingConventionWidth,
+  kResultSizeMask               = 0x30, /* Parameter offsets & widths */
+  kStackParameterWidth          = 2,
+  kStackParameterPhase          = (kCallingConventionWidth + kResultSizeWidth),
+  kStackParameterMask           = (int)0xFFFFFFC0, /* Register Result Location offsets & widths */
+  kRegisterResultLocationWidth  = 5,
+  kRegisterResultLocationPhase  = (kCallingConventionWidth + kResultSizeWidth), /* Register Parameter offsets & widths */
+  kRegisterParameterWidth       = 5,
+  kRegisterParameterPhase       = (kCallingConventionWidth + kResultSizeWidth + kRegisterResultLocationWidth),
+  kRegisterParameterMask        = 0x7FFFF800,
+  kRegisterParameterSizePhase   = 0,
+  kRegisterParameterSizeWidth   = 2,
+  kRegisterParameterWhichPhase  = kRegisterParameterSizeWidth,
+  kRegisterParameterWhichWidth  = 3,    /* Dispatched Stack Routine Selector offsets & widths */
+  kDispatchedSelectorSizeWidth  = 2,
+  kDispatchedSelectorSizePhase  = (kCallingConventionWidth + kResultSizeWidth), /* Dispatched Stack Routine Parameter offsets */
+  kDispatchedParameterPhase     = (kCallingConventionWidth + kResultSizeWidth + kDispatchedSelectorSizeWidth), /* Special Case offsets & widths */
+  kSpecialCaseSelectorWidth     = 6,
+  kSpecialCaseSelectorPhase     = kCallingConventionWidth,
+  kSpecialCaseSelectorMask      = 0x03F0
+};
+
+enum {
+  kSpecialCase                  = 0x000F /* (CallingConventionType) */
+};
+
+enum {
+                                        /* all of the special cases enumerated.  The selector field is 6 bits wide */
+  kSpecialCaseHighHook          = 0,
+  kSpecialCaseCaretHook         = 0,    /* same as kSpecialCaseHighHook */
+  kSpecialCaseEOLHook           = 1,
+  kSpecialCaseWidthHook         = 2,
+  kSpecialCaseTextWidthHook     = 2,    /* same as kSpecialCaseWidthHook */
+  kSpecialCaseNWidthHook        = 3,
+  kSpecialCaseDrawHook          = 4,
+  kSpecialCaseHitTestHook       = 5,
+  kSpecialCaseTEFindWord        = 6,
+  kSpecialCaseProtocolHandler   = 7,
+  kSpecialCaseSocketListener    = 8,
+  kSpecialCaseTERecalc          = 9,
+  kSpecialCaseTEDoText          = 10,
+  kSpecialCaseGNEFilterProc     = 11,
+  kSpecialCaseMBarHook          = 12
+};
+
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
+ *
+ *  Macros for building ProcInfos.  Examples:
+ *  
+ *  
+ *  uppModalFilterProcInfo = kPascalStackBased
+ *       | RESULT_SIZE(SIZE_CODE(sizeof(Boolean)))
+ *       | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(DialogRef)))
+ *       | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(EventRecord*)))
+ *       | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(short*))),
+ *
+ *  uppDeskHookProcInfo = kRegisterBased
+ *       | REGISTER_ROUTINE_PARAMETER(1, kRegisterD0, SIZE_CODE(sizeof(Boolean)))
+ *       | REGISTER_ROUTINE_PARAMETER(2, kRegisterA0, SIZE_CODE(sizeof(EventRecord*)))
+ *
+ *  uppGXSpoolResourceProcInfo = kCStackBased
+ *       | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))
+ *       | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(gxSpoolFile)))
+ *       | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(Handle)))
+ *       | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(ResType)))
+ *       | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(long)))
+ *
+ *  uppTEFindWordProcInfo = SPECIAL_CASE_PROCINFO( 6 ),
+ *
+ */
+
+
+/* * * * * * * * * * * * * * 
+ *   SIZE_CODE -     Return the size code for an object, given its size in bytes.
+ *     size - size of an object in bytes
+ */
+#define SIZE_CODE(size) \
+    (((size) == 4) ? kFourByteCode : (((size) == 2) ? kTwoByteCode : (((size) == 1) ? kOneByteCode : 0)))
+
+
+/* * * * * * * * * * * * * * 
+ *   RESULT_SIZE -   Return the result field of a ProcInfo, given the return objectÕs size.
+ *                   This is the same for all ProcInfos
+ *       sizeCode - size code
+ */
+#define RESULT_SIZE(sizeCode) \
+   ((ProcInfoType)(sizeCode) << kResultSizePhase)
+
+
+/* * * * * * * * * * * * * * 
+ *   STACK_ROUTINE_PARAMETER -   Return a parameter field of a ProcInfo, for a simple,
+ *                                non-dispatched, stack based routine.
+ *     whichParam - which parameter
+ *     sizeCode - size code
+ */
+#define STACK_ROUTINE_PARAMETER(whichParam, sizeCode) \
+   ((ProcInfoType)(sizeCode) << (kStackParameterPhase + (((whichParam) - 1) * kStackParameterWidth)))
+
+
+/* * * * * * * * * * * * * * 
+ *   DISPATCHED_STACK_ROUTINE_PARAMETER -    Return a parameter field of a ProcInfo, for 
+ *                                         a dispatched, stack based routine.  The same
+ *                                         macro is used regardless of the type of
+ *                                          dispatching.
+ *     whichParam - which parameter
+ *     sizeCode - size code
+ */
+#define DISPATCHED_STACK_ROUTINE_PARAMETER(whichParam, sizeCode) \
+    ((ProcInfoType)(sizeCode) << (kDispatchedParameterPhase + (((whichParam) - 1) * kStackParameterWidth)))
+
+
+/* * * * * * * * * * * * * * 
+ *   DISPATCHED_STACK_ROUTINE_SELECTOR_SIZE -    Return a the selector size field of a ProcInfo
+ *                                               for a dispatched, stack based routine.  The
+ *                                              same macro is used regardless of the type of
+ *                                             dispatching.
+ *     sizeCode - size code 
+ */
+#define DISPATCHED_STACK_ROUTINE_SELECTOR_SIZE(sizeCode) \
+   ((ProcInfoType)(sizeCode) << kDispatchedSelectorSizePhase)
+
+
+/* * * * * * * * * * * * * * 
+ *   REGISTER_RESULT_LOCATION -      Return the Result Location field of a ProcInfo, 
+ *                                 given the location.
+ *      whichReg - which register
+ */
+#define REGISTER_RESULT_LOCATION(whichReg) \
+ ((ProcInfoType)(whichReg) << kRegisterResultLocationPhase)
+
+
+/* * * * * * * * * * * * * * 
+ *   REGISTER_ROUTINE_PARAMETER -    Return a parameter field of a ProcInfo for a 
+ *                                    register based routine.
+ */
+#define REGISTER_ROUTINE_PARAMETER(whichParam, whichReg, sizeCode) \
+   ((((ProcInfoType)(sizeCode) << kRegisterParameterSizePhase) | ((ProcInfoType)(whichReg) << kRegisterParameterWhichPhase)) << \
+         (kRegisterParameterPhase + (((whichParam) - 1) * kRegisterParameterWidth)))
+
+
+/* * * * * * * * * * * * * * 
+ *
+ *    SPECIAL_CASE_PROCINFO -     Returns the procInfo constant for the following special cases:
+ *   
+ *     High Hook & Caret Hook -  (see I-379)
+ *            C calling conventions, Rect on stack, pointer in A3, no return value
+ *     EOL Hook - (see VI-15-26)
+ *            Register-based; inputs in D0, A3, A4; 
+ *           output is Z flag of status register
+ *      Width Hook - (see VI-15-27)
+ *          Register-based; inputs in D0, D1, A0, A3, A4; output in D1 
+ *      NWidth Hook - (see VI-15-27)
+ *         Register-based; inputs in D0, D1, D2, A0, A2, A3, A4; output in D1 
+ *      TextWidthHook - (see VI-15-28)
+ *           Register-based; inputs in D0, D1, A0, A3, A4; output in D1 
+ *      DrawHook - (see VI-15-28)
+ *            Register-based; inputs in D0, D1, A0, A3, A4; no output
+ *      HitTestHook - (See VI-15-29)
+ *         Register-based; inputs in D0, D1, D2, A0, A3, A4; outputs in D0, D1, D2
+ *      FindWord -  (see VI-15-30)
+ *           Register-based; inputs in D0, D2, A3, A4; outputs in D0, D1
+ *      ADBRoutines - (see V-371)
+ *            Register-based; inputs in A0, A1, A2, D0; no outputs
+ *     ProtocolHandler - (see II-326)
+ *           Register-based; inputs in A0, A1, A2, A3, A4, D1.w; output in Z 
+ *     SocketListener - (see II-329)
+ *            Register-based; inputs in A0, A1, A2, A3, A4, D0.b, D1.w; output in Z 
+ *       Reclac - (see I-391)
+ *         Register-based; inputs in A3, D7; outputs in D2, D3, D4
+ *      DoText - (see I-391)
+ *         Register-based; inputs in A3, D3, D4, D7; outputs in A0, D0
+ *      GNEFilterProc - (see tech note 85)
+ *           Register & Stack Based; inputs in A1, D0 & on the stack; outputs on the stack
+ *        MenuBarHook - (see I-356)
+ *            Register & Stack Based; input on the stack; output in D0
+*/
+#define SPECIAL_CASE_PROCINFO(specialCaseCode)          \
+      (kSpecialCase | ((ProcInfoType)(specialCaseCode) << 4))
+
+
+/* * * * * * * * * * * * * * * 
+ * STACK_UPP_TYPE    - used in typedefs to create ÅUPP type
+ * REGISTER_UPP_TYPE - used in typedefs to create ÅUPP type
+ * TVECTOR_UPP_TYPE  - used in typedefs to create ÅUPP type
+ *
+ *  Example:
+ *
+ *      typedef STACK_UPP_TYPE(ModalFilterProcPtr)      ModalFilterUPP;
+ *      typedef REGISTER_UPP_TYPE(IOCompletionProcPtr)  IOCompletionUPP;
+ *
+ */
+#if TARGET_OS_MAC && TARGET_RT_MAC_CFM
+ /* PowerPC and CFM68K runtime */
+   #if OPAQUE_UPP_TYPES
+       #define STACK_UPP_TYPE(name)    struct Opaque##name##*
+     #define REGISTER_UPP_TYPE(name) struct Opaque##name##*
+     #define TVECTOR_UPP_TYPE(name)  struct Opaque##name##*
+ #else
+      #define STACK_UPP_TYPE(name)    UniversalProcPtr
+       #define REGISTER_UPP_TYPE(name) UniversalProcPtr
+       #define TVECTOR_UPP_TYPE(name)  name
+   #endif
+#elif TARGET_OS_MAC && TARGET_RT_MAC_MACHO
+  /* Mac OS X runtime */
+ #define STACK_UPP_TYPE(name)    name
+   #define REGISTER_UPP_TYPE(name) name
+   #define TVECTOR_UPP_TYPE(name)  name
+#else
+ /* other runtimes */
+   #define STACK_UPP_TYPE(name)    name
+   #define REGISTER_UPP_TYPE(name) name
+   #define TVECTOR_UPP_TYPE(name)  name
+#endif
+
+
+/* * * * * * * * * * * * * * * 
+ * CALL_Å_PARAMETER_UPP  - used in CallÅProc macros
+ *
+ *  Example:
+ *
+ *      #define CallIOCompletionProc(userRoutine, paramBlock)   \
+ *                CALL_TWO_PARAMETER_UPP((userRoutine), uppIOCompletionProcInfo, (paramBlock))
+ *
+ */
+#if TARGET_OS_MAC && TARGET_RT_MAC_CFM
+    #define CALL_ZERO_PARAMETER_UPP(    upp, procInfo)      CallUniversalProc(upp, procInfo)
+    #define CALL_ONE_PARAMETER_UPP(     upp, procInfo, p1)      CallUniversalProc(upp, procInfo, (p1))
+    #define CALL_TWO_PARAMETER_UPP(     upp, procInfo, p1, p2)      CallUniversalProc(upp, procInfo, (p1), (p2))
+    #define CALL_THREE_PARAMETER_UPP(   upp, procInfo, p1, p2, p3)      CallUniversalProc(upp, procInfo, (p1), (p2), (p3))
+    #define CALL_FOUR_PARAMETER_UPP(    upp, procInfo, p1, p2, p3, p4)      CallUniversalProc(upp, procInfo, (p1), (p2), (p3), (p4))
+    #define CALL_FIVE_PARAMETER_UPP(    upp, procInfo, p1, p2, p3, p4, p5)      CallUniversalProc(upp, procInfo, (p1), (p2), (p3), (p4), (p5))
+    #define CALL_SIX_PARAMETER_UPP(     upp, procInfo, p1, p2, p3, p4, p5, p6)      CallUniversalProc(upp, procInfo, (p1), (p2), (p3), (p4), (p5), (p6))
+    #define CALL_SEVEN_PARAMETER_UPP(   upp, procInfo, p1, p2, p3, p4, p5, p6, p7)      CallUniversalProc(upp, procInfo, (p1), (p2), (p3), (p4), (p5), (p6), (p7))
+    #define CALL_EIGHT_PARAMETER_UPP(   upp, procInfo, p1, p2, p3, p4, p5, p6, p7, p8)      CallUniversalProc(upp, procInfo, (p1), (p2), (p3), (p4), (p5), (p6), (p7), (p8))
+    #define CALL_NINE_PARAMETER_UPP(    upp, procInfo, p1, p2, p3, p4, p5, p6, p7, p8, p9)      CallUniversalProc(upp, procInfo, (p1), (p2), (p3), (p4), (p5), (p6), (p7), (p8), (p9))
+    #define CALL_TEN_PARAMETER_UPP(     upp, procInfo, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10)     CallUniversalProc(upp, procInfo, (p1), (p2), (p3), (p4), (p5), (p6), (p7), (p8), (p9), (p10))
+    #define CALL_ELEVEN_PARAMETER_UPP(  upp, procInfo, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11)    CallUniversalProc(upp, procInfo, (p1), (p2), (p3), (p4), (p5), (p6), (p7), (p8), (p9), (p10), (p11))
+    #define CALL_TWELVE_PARAMETER_UPP(  upp, procInfo, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12)   CallUniversalProc(upp, procInfo, (p1), (p2), (p3), (p4), (p5), (p6), (p7), (p8), (p9), (p10), (p11), (p12))
+    #define CALL_THIRTEEN_PARAMETER_UPP(upp, procInfo, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13)  CallUniversalProc(upp, procInfo, (p1), (p2), (p3), (p4), (p5), (p6), (p7), (p8), (p9), (p10), (p11), (p12), (p13))
+#else
+    #define CALL_ZERO_PARAMETER_UPP(    upp, procInfo)      (*(upp))()
+    #define CALL_ONE_PARAMETER_UPP(     upp, procInfo, p1)      (*(upp))((p1))
+    #define CALL_TWO_PARAMETER_UPP(     upp, procInfo, p1, p2)      (*(upp))((p1), (p2))
+    #define CALL_THREE_PARAMETER_UPP(   upp, procInfo, p1, p2, p3)      (*(upp))((p1), (p2), (p3))
+    #define CALL_FOUR_PARAMETER_UPP(    upp, procInfo, p1, p2, p3, p4)      (*(upp))((p1), (p2), (p3), (p4))
+    #define CALL_FIVE_PARAMETER_UPP(    upp, procInfo, p1, p2, p3, p4, p5)      (*(upp))((p1), (p2), (p3), (p4), (p5))
+    #define CALL_SIX_PARAMETER_UPP(     upp, procInfo, p1, p2, p3, p4, p5, p6)      (*(upp))((p1), (p2), (p3), (p4), (p5), (p6))
+    #define CALL_SEVEN_PARAMETER_UPP(   upp, procInfo, p1, p2, p3, p4, p5, p6, p7)      (*(upp))((p1), (p2), (p3), (p4), (p5), (p6), (p7))
+    #define CALL_EIGHT_PARAMETER_UPP(   upp, procInfo, p1, p2, p3, p4, p5, p6, p7, p8)      (*(upp))((p1), (p2), (p3), (p4), (p5), (p6), (p7), (p8))
+    #define CALL_NINE_PARAMETER_UPP(    upp, procInfo, p1, p2, p3, p4, p5, p6, p7, p8, p9)      (*(upp))((p1), (p2), (p3), (p4), (p5), (p6), (p7), (p8), (p9))
+    #define CALL_TEN_PARAMETER_UPP(     upp, procInfo, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10)     (*(upp))((p1), (p2), (p3), (p4), (p5), (p6), (p7), (p8), (p9), (p10))
+    #define CALL_ELEVEN_PARAMETER_UPP(  upp, procInfo, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11)    (*(upp))((p1), (p2), (p3), (p4), (p5), (p6), (p7), (p8), (p9), (p10), (p11))
+    #define CALL_TWELVE_PARAMETER_UPP(  upp, procInfo, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12)   (*(upp))((p1), (p2), (p3), (p4), (p5), (p6), (p7), (p8), (p9), (p10), (p11), (p12))
+    #define CALL_THIRTEEN_PARAMETER_UPP(upp, procInfo, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13)  (*(upp))((p1), (p2), (p3), (p4), (p5), (p6), (p7), (p8), (p9), (p10), (p11), (p12), (p13))
+#endif
+
+
+
+
+
+#pragma pack(pop)
+
+
+#endif /* __MIXEDMODE__ */
+
diff -Nru ../CarbonHeaders-18.1.orig/OSUtils.h ./OSUtils.h
--- ../CarbonHeaders-18.1.orig/OSUtils.h	1969-12-31 16:00:00.000000000 -0800
+++ ./OSUtils.h	2009-09-29 14:01:24.000000000 -0700
@@ -0,0 +1,814 @@
+/*
+ * Copyright (c) 2007-2009 by Apple Inc.. All rights reserved.
+ *
+ * @APPLE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this
+ * file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_LICENSE_HEADER_END@
+ */
+/*
+     File:       CarbonCore/OSUtils.h
+ 
+     Contains:   OS Utilities Interfaces.
+ 
+     Version:    CarbonCore-859.2~1
+ 
+     Copyright:  © 1985-2008 by Apple Computer, Inc., all rights reserved
+ 
+     Bugs?:      For bug reports, consult the following page on
+                 the World Wide Web:
+ 
+                     http://developer.apple.com/bugreporter/
+ 
+*/
+#ifndef __OSUTILS__
+#define __OSUTILS__
+
+#ifndef __MACTYPES__
+#include <CarbonCore/MacTypes.h>
+#endif
+
+#ifndef __MIXEDMODE__
+#include <CarbonCore/MixedMode.h>
+#endif
+
+/*  HandToHand and other memory utilties were moved to MacMemory.h */
+#ifndef __MACMEMORY__
+#include <CarbonCore/MacMemory.h>
+#endif
+
+/*  Date and Time utilties were moved to DateTimeUtils.h */
+#ifndef __DATETIMEUTILS__
+#include <CarbonCore/DateTimeUtils.h>
+#endif
+
+#ifndef __CFSTRING__
+#include <CoreFoundation/CFString.h>
+#endif
+
+
+#include <AvailabilityMacros.h>
+
+#if PRAGMA_ONCE
+#pragma once
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#pragma pack(push, 2)
+
+enum {
+                                        /* result types for RelString Call */
+  sortsBefore                   = -1,   /*first string < second string*/
+  sortsEqual                    = 0,    /*first string = second string*/
+  sortsAfter                    = 1     /*first string > second string*/
+};
+
+enum {
+  dummyType                     = 0,
+  vType                         = 1,
+  ioQType                       = 2,
+  drvQType                      = 3,
+  evType                        = 4,
+  fsQType                       = 5,
+  sIQType                       = 6,
+  dtQType                       = 7,
+  nmType                        = 8
+};
+
+typedef SignedByte                      QTypes;
+struct QElem {
+  struct QElem *      qLink;
+  short               qType;
+  short               qData[1];
+};
+typedef struct QElem                    QElem;
+typedef QElem *                         QElemPtr;
+struct QHdr {
+  volatile short      qFlags;
+  volatile QElemPtr   qHead;
+  volatile QElemPtr   qTail;
+};
+typedef struct QHdr                     QHdr;
+typedef QHdr *                          QHdrPtr;
+/* 
+    In order for MachineLocation to be endian-safe, a new member 
+    has been added to the 'u' union in the structure. You are 
+    encouraged to use the new member instead of the old one.
+    
+    If your code looked like this:
+    
+        MachineLocation.u.dlsDelta = isDLS? 0x80: 0x00;
+    
+    you should change it to this:
+    
+        MachineLocation.u.dls.Delta = isDLS? 0x80: 0x00;
+    
+    to be endian safe. The gmtDelta remains the same; the low 24-bits
+    are used. Remember that order of assignment DOES matter:
+    
+    This will overwrite results:
+    
+        MachineLocation.u.dls.Delta = 0xAA;         // u = 0xAAGGGGGG; G=Garbage
+        MachineLocation.u.gmtDelta = 0xBBBBBB;      // u = 0x00BBBBBB;
+    
+    when in fact reversing the assignment would have preserved the values:
+
+        MachineLocation.u.gmtDelta = 0xBBBBBB;      // u = 0x00BBBBBB;  
+        MachineLocation.u.dls.Delta = 0xAA;         // u = 0xAABBBBBB;
+        
+    NOTE:   The information regarding dlsDelta in Inside Mac is INCORRECT.
+            It's always 0x80 for daylight-saving time or 0x00 for standard time.
+*/
+struct MachineLocation {
+    Fract   latitude;
+    Fract   longitude;
+    union {
+    #if TARGET_RT_BIG_ENDIAN
+        SInt8 dlsDelta;
+    #endif
+        long    gmtDelta;           /* use low 24-bits only */
+        struct {
+        #if TARGET_RT_LITTLE_ENDIAN
+            SInt8   pad[3];
+        #endif
+            SInt8   Delta;          /* signed byte; daylight savings delta */
+        } dls;
+    } u;
+};
+typedef struct MachineLocation MachineLocation;
+/*
+ *  IsMetric()
+ *  
+ *  Summary:
+ *    Verifies whether the current script system is using the metric
+ *    system or the English system of measurement.
+ *  
+ *  Discussion:
+ *    The IsMetric function examines the metricSys field of the
+ *    numeric-format resource (resource type 'itl0') to determine if
+ *    the current script is using the metric system. A value of 255 in
+ *    the metricSys field indicates that the metric system
+ *    (centimeters, kilometers, milligrams, degrees Celsius, and so on)
+ *    is being used. A value of 0 in the metricSys field indicates that
+ *    the English system of measurement (inches, miles, ounces, degrees
+ *    Fahrenheit, and so on) is used.
+ *    If you want to use units of measurement different from that of
+ *    the current script, you need to override the value of the
+ *    metricSys field in the current numeric-format resource. You can
+ *    do this by using your own version of the numeric-format resource
+ *    instead of the current script systemÕs default international
+ *    resource.
+ *    The IsMetric function is the same as the IUMetric function, which
+ *    was previously available with the International Utilities Package.
+ *  
+ *  Mac OS X threading:
+ *    Not thread safe
+ *  
+ *  Result:
+ *    TRUE if the metric system is being used; FALSE if the English
+ *    system is being used.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern Boolean 
+IsMetric(void)                                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  Delay()
+ *  
+ *  Summary:
+ *    Delays execture for the specified amount of time.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe
+ *  
+ *  Parameters:
+ *    
+ *    numTicks:
+ *      the number of ticks to delay  for
+ *    
+ *    finalTicks:
+ *      on return, if not NULL, will contain the value of TickCount()
+ *      at the end of the delay period
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern void 
+Delay(
+  unsigned long    numTicks,
+  unsigned long *  finalTicks)                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  Enqueue()
+ *  
+ *  Summary:
+ *    Atomically adds a queue element to the given queue
+ *  
+ *  Discussion:
+ *    A queue ( represented by a QHdrPtr ) is a singly linked list of
+ *    elements.  Enqueue inserts the given element into the queue in a
+ *    multi-thread safe way.  If the element is already in the queue,
+ *    or in some other queue, the data structures will be corrupted and
+ *    will likely cause a crash or infinite loop.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe
+ *  
+ *  Parameters:
+ *    
+ *    qElement:
+ *      a pointer to the element to be inserted
+ *    
+ *    qHeader:
+ *      a pointer to the queue header.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern void 
+Enqueue(
+  QElemPtr   qElement,
+  QHdrPtr    qHeader)                                         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  Dequeue()
+ *  
+ *  Summary:
+ *    Atomically removes a queue element from the given queue
+ *  
+ *  Discussion:
+ *    A queue ( represented by a QHdrPtr ) is a singly linked list of
+ *    elements.  Dequeue removes the given element from the queue in a
+ *    multi-thread safe way.  If the element is not in the queue, qErr
+ *    is returned.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe
+ *  
+ *  Parameters:
+ *    
+ *    qElement:
+ *      a pointer to the element to be removed
+ *    
+ *    qHeader:
+ *      a pointer to the queue header.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+Dequeue(
+  QElemPtr   qElement,
+  QHdrPtr    qHeader)                                         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+
+#if !__LP64__
+/*
+ *  MakeDataExecutable()
+ *  
+ *  Summary:
+ *    Notifies the system that the specified data is subject to
+ *    execution.
+ *  
+ *  Discussion:
+ *    On some computer architectures it is necessary to tell the
+ *    processor that an area of memory should be made executable.  This
+ *    function does the necessary operations ( if possible ) to make it
+ *    possible to execute code in the given address range.
+ *    MakeDataExecutable is not supported for 64-bit applications. Use
+ *    sys_icache_invalidate(3) and/or mprotect(2) as appropriate.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe
+ *  
+ *  Parameters:
+ *    
+ *    baseAddress:
+ *      the starting address to be made executable
+ *    
+ *    length:
+ *      the length of the data pointed to by the baseAddress parameter.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only]
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.5 and later
+ */
+extern void 
+MakeDataExecutable(
+  void *          baseAddress,
+  unsigned long   length)                                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+#endif  /* !__LP64__ */
+
+/*
+ *  ReadLocation()
+ *  
+ *  Summary:
+ *    Obtains information about a geographic location or time zone.
+ *  
+ *  Discussion:
+ *    The latitude and longitude are stored as Fract values, giving
+ *    accuracy to within one foot. For example, a Fract value of 1.0
+ *    equals 90 degrees Ð1.0 equals Ð90 degrees and Ð2.0 equals Ð180
+ *    degrees.
+ *    To convert these values to a degrees format, you need to convert
+ *    the Fract values first to the Fixed data type, then to the
+ *    LongInt data type. Use the Mathematical and Logical Utilities
+ *    functions Fract2Fix and Fix2Long to accomplish this task.
+ *    The DST value is a signed byte value that specifies the offset
+ *    for the hour fieldÑwhether to add one hour, subtract one hour, or
+ *    make no change at all.
+ *    The GMT value is in seconds east of GMT. For example, San
+ *    Francisco is at Ð28,800 seconds (8 hours * 3,600 seconds per
+ *    hour) east of GMT. The gmtDelta field is a 3-byte value contained
+ *    in a long word, so you must take care to get it properly.
+ *    For more information on the Fract data type and the conversion
+ *    routines Long2Fix, Fix2Fract, Fract2Fix, and Fix2Long, see
+ *    Mathematical and Logical Utilities.
+ *  
+ *  Mac OS X threading:
+ *    Not thread safe
+ *  
+ *  Parameters:
+ *    
+ *    loc:
+ *      On return, the fields of the geographic location structure
+ *      containing the geographic location and the time-zone
+ *      information.
+ *      You can get values for the latitude, longitude, daylight
+ *      savings time (DST), or Greenwich mean time (GMT). If the
+ *      geographic location record has never been set, all fields
+ *      contain 0.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern void 
+ReadLocation(MachineLocation * loc)                           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  TickCount()
+ *  
+ *  Summary:
+ *    Obtains the current number of ticks (a tick is approximately 1/60
+ *    of a second) approximately since the system last started up.
+ *  
+ *  Discussion:
+ *    The TickCount function returns an unsigned 32-bit integer that
+ *    indicates the current number of ticks since the system last
+ *    started up. You can use this value to compare the number of ticks
+ *    that have elapsed since a given event or other action occurred.
+ *    For example, you could compare the current value returned by
+ *    TickCount with the value of the when field of an event
+ *    structure.
+ *    The tick count rolls over in approximately 2 years 3 months,
+ *    which means you should not use this to time intervals which may
+ *    exceed ( or even approach ) this interval.
+ *    Do not rely on the tick count being exact; it is usually accurate
+ *    to within one tick, but this level of accuracy is not guaranteed.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe
+ *  
+ *  Result:
+ *    the tick count
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern UInt32 
+TickCount(void)                                               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  CSCopyUserName()
+ *  
+ *  Summary:
+ *    Returns a reference to the CFString that represents the user name.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe
+ *  
+ *  Parameters:
+ *    
+ *    useShortName:
+ *      A Boolean value that specifies whether to return the short name
+ *      or full name of the user.
+ *  
+ *  Result:
+ *    the requested name in a CFStringRef.  You should release this
+ *    when you are done with it.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.5 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern CFStringRef 
+CSCopyUserName(Boolean useShortName)                          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  CSCopyMachineName()
+ *  
+ *  Summary:
+ *    Returns a reference to the CFString that represents the computer
+ *    name.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe
+ *  
+ *  Result:
+ *    the name of this machine in a CFStringRef.  You should release
+ *    this when you are done with it.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.5 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern CFStringRef 
+CSCopyMachineName(void)                                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+enum {
+  useFree                       = 0,
+  useATalk                      = 1,
+  useAsync                      = 2,
+  useExtClk                     = 3,    /*Externally clocked*/
+  useMIDI                       = 4
+};
+
+enum {
+  false32b                      = 0,    /*24 bit addressing error*/
+  true32b                       = 1     /*32 bit addressing error*/
+};
+
+#if ALLOW_OBSOLETE_CARBON_OSUTILS
+struct SysParmType {
+  UInt8               valid;
+  UInt8               aTalkA;
+  UInt8               aTalkB;
+  UInt8               config;
+  short               portA;
+  short               portB;
+  long                alarm;
+  short               font;
+  short               kbdPrint;
+  short               volClik;
+  short               misc;
+};
+typedef struct SysParmType              SysParmType;
+typedef SysParmType *                   SysPPtr;
+#else
+typedef void *                          SysPPtr;
+#endif  /* ALLOW_OBSOLETE_CARBON_OSUTILS */
+
+#if TARGET_API_MAC_CARBON
+#define GetMMUMode() ((SInt8)true32b)
+#define SwapMMUMode(x) (*(SInt8*)(x) = true32b)
+#endif
+#if !__LP64__
+/*
+ *  GetSysPPtr()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    Don't use this function; it always returns NULL on Mac OS X.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern SysPPtr 
+GetSysPPtr(void)                                              AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+
+/*
+    NOTE: SysBeep() has been moved to Sound.h.  
+ We could not automatically #include Sound.h in this file
+ because Sound.h indirectly #include's OSUtils.h which
+ would make a circular include.
+ */
+#endif  /* !__LP64__ */
+
+typedef CALLBACK_API( void , DeferredTaskProcPtr )(long dtParam);
+typedef STACK_UPP_TYPE(DeferredTaskProcPtr)                     DeferredTaskUPP;
+/*
+ *  NewDeferredTaskUPP()
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   available as macro/inline
+ */
+extern DeferredTaskUPP
+NewDeferredTaskUPP(DeferredTaskProcPtr userRoutine)           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+/*
+ *  DisposeDeferredTaskUPP()
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   available as macro/inline
+ */
+extern void
+DisposeDeferredTaskUPP(DeferredTaskUPP userUPP)               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+/*
+ *  InvokeDeferredTaskUPP()
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   available as macro/inline
+ */
+extern void
+InvokeDeferredTaskUPP(
+  long             dtParam,
+  DeferredTaskUPP  userUPP)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+#if __MACH__
+  #ifdef __cplusplus
+    inline DeferredTaskUPP                                      NewDeferredTaskUPP(DeferredTaskProcPtr userRoutine) { return userRoutine; }
+    inline void                                                 DisposeDeferredTaskUPP(DeferredTaskUPP) { }
+    inline void                                                 InvokeDeferredTaskUPP(long dtParam, DeferredTaskUPP userUPP) { (*userUPP)(dtParam); }
+  #else
+    #define NewDeferredTaskUPP(userRoutine)                     ((DeferredTaskUPP)userRoutine)
+    #define DisposeDeferredTaskUPP(userUPP)
+    #define InvokeDeferredTaskUPP(dtParam, userUPP)             (*userUPP)(dtParam)
+  #endif
+#endif
+
+struct DeferredTask {
+  volatile QElemPtr   qLink;
+  short               qType;
+  volatile short      dtFlags;
+  DeferredTaskUPP     dtAddr;
+  long                dtParam;
+  long                dtReserved;
+};
+typedef struct DeferredTask             DeferredTask;
+typedef DeferredTask *                  DeferredTaskPtr;
+#if !__LP64__
+/*
+ *  DTInstall()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    The Deferred Task Manager is deprecated.  Look into restructuring
+ *    your code to use threads, or MPTasks, or some other threading
+ *    solution.
+ *  
+ *  Summary:
+ *    Adds the specified task record to the deferred-task queue.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+DTInstall(DeferredTaskPtr dtTaskPtr)                          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  DTUninstall()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    The Deferred Task Manager is deprecated.  Look into restructuring
+ *    your code to use threads, or MPTasks, or some other threading
+ *    solution.
+ *  
+ *  Summary:
+ *    Adds the specified task record to the deferred-task queue.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        not available
+ *    Non-Carbon CFM:   not available
+ */
+extern OSErr 
+DTUninstall(DeferredTaskPtr dtTaskPtr)                        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  SetCurrentA5()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    You no longer need to use SetCurrentA5() on Mac OS X.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern long 
+SetCurrentA5(void)                                            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  SetA5()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    You no longer need to use SetA5() on Mac OS X.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern long 
+SetA5(long newA5)                                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  InitUtil()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    It is not necessary to call InitUtil on Mac OS X.  You should
+ *    remove all calls to this from your code.
+ *  
+ *  Mac OS X threading:
+ *    Thread safe
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.3
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+InitUtil(void)                                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3;
+
+
+/*
+ *  WriteParam()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    This function no longer does anything on Mac OS X; you should
+ *    remove all calls to it from your code.
+ *  
+ *  Mac OS X threading:
+ *    Not thread safe
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern OSErr 
+WriteParam(void)                                              AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  WriteLocation()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    WriteLocation can not be used to set the geographic information
+ *    on Mac OS X.  You should remove all calls to this function from
+ *    your code.
+ *  
+ *  Mac OS X threading:
+ *    Not thread safe
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.0
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
+ */
+extern void 
+WriteLocation(const MachineLocation * loc)                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED;
+
+
+#endif  /* !__LP64__ */
+
+#if OLDROUTINENAMES
+#define IUMetric() IsMetric()
+#endif  /* OLDROUTINENAMES */
+
+#if ALLOW_OBSOLETE_CARBON_OSUTILS
+/*
+    NOTE: SysEnvirons is obsolete.  You should be using Gestalt.
+*/
+/* Environs Equates */
+enum {
+  curSysEnvVers                 = 2     /*Updated to equal latest SysEnvirons version*/
+};
+
+struct SysEnvRec {
+  short               environsVersion;
+  short               machineType;
+  short               systemVersion;
+  short               processor;
+  Boolean             hasFPU;
+  Boolean             hasColorQD;
+  short               keyBoardType;
+  short               atDrvrVersNum;
+  short               sysVRefNum;
+};
+typedef struct SysEnvRec                SysEnvRec;
+enum {
+                                        /* Machine Types */
+  envMac                        = -1,
+  envXL                         = -2,
+  envMachUnknown                = 0,
+  env512KE                      = 1,
+  envMacPlus                    = 2,
+  envSE                         = 3,
+  envMacII                      = 4,
+  envMacIIx                     = 5,
+  envMacIIcx                    = 6,
+  envSE30                       = 7,
+  envPortable                   = 8,
+  envMacIIci                    = 9,
+  envMacIIfx                    = 11
+};
+
+enum {
+                                        /* CPU types */
+  envCPUUnknown                 = 0,
+  env68000                      = 1,
+  env68010                      = 2,
+  env68020                      = 3,
+  env68030                      = 4,
+  env68040                      = 5
+};
+
+enum {
+                                        /* Keyboard types */
+  envUnknownKbd                 = 0,
+  envMacKbd                     = 1,
+  envMacAndPad                  = 2,
+  envMacPlusKbd                 = 3,
+  envAExtendKbd                 = 4,
+  envStandADBKbd                = 5,
+  envPrtblADBKbd                = 6,
+  envPrtblISOKbd                = 7,
+  envStdISOADBKbd               = 8,
+  envExtISOADBKbd               = 9
+};
+
+#endif  /* ALLOW_OBSOLETE_CARBON_OSUTILS */
+
+
+
+
+#pragma pack(pop)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __OSUTILS__ */
+
diff -Nru ../CarbonHeaders-18.1.orig/TextCommon.h ./TextCommon.h
--- ../CarbonHeaders-18.1.orig/TextCommon.h	1969-12-31 16:00:00.000000000 -0800
+++ ./TextCommon.h	2009-09-29 14:01:30.000000000 -0700
@@ -0,0 +1,1165 @@
+/*
+ * Copyright (c) 2007-2009 by Apple Inc.. All rights reserved.
+ *
+ * @APPLE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this
+ * file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_LICENSE_HEADER_END@
+ */
+
+/*
+     File:       CarbonCore/TextCommon.h
+ 
+     Contains:   TextEncoding-related types and constants, and prototypes for related functions
+ 
+     Version:    CarbonCore-859.2~1
+ 
+     Copyright:  © 1995-2008 Apple Inc. All rights reserved.
+ 
+     Bugs?:      For bug reports, consult the following page on
+                 the World Wide Web:
+ 
+                     http://developer.apple.com/bugreporter/
+ 
+*/
+#ifndef __TEXTCOMMON__
+#define __TEXTCOMMON__
+
+#ifndef __MACTYPES__
+#include <CarbonCore/MacTypes.h>
+#endif
+
+
+
+#include <AvailabilityMacros.h>
+
+#if PRAGMA_ONCE
+#pragma once
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#pragma pack(push, 2)
+
+
+/*
+ *  Generic Text Alignment Constants
+ *  
+ *  Summary:
+ *    These constants are implemented to supplant the old TextEdit
+ *    Manager constants ( teFlushDefault, teCenter teFlushRight,
+ *    teFlushLeft ) These constants are used outside the context of the
+ *    legacy TextEdit Manager Framework. Use these as you would use the
+ *    old TextEdit.h constants to specify how text should be justified
+ *    (word aligned.) The new constants use the same values as the the
+ *    old TextEdit ones, for backwards compatibility.
+ */
+enum {
+
+  /*
+   * Flush according to the line direction
+   */
+  kTextFlushDefault             = 0,
+
+  /*
+   * Center justify (word alignment)
+   */
+  kTextCenter                   = 1,
+
+  /*
+   * Flush right
+   */
+  kTextFlushRight               = -1,
+
+  /*
+   * Flush left
+   */
+  kTextFlushLeft                = -2
+};
+
+/* TextEncodingBase type & values */
+/* (values 0-32 correspond to the Script Codes defined in Inside Macintosh: Text pages 6-52 and 6-53 */
+typedef UInt32                          TextEncodingBase;
+enum {
+                                        /* Mac OS encodings*/
+  kTextEncodingMacRoman         = 0,
+  kTextEncodingMacJapanese      = 1,
+  kTextEncodingMacChineseTrad   = 2,
+  kTextEncodingMacKorean        = 3,
+  kTextEncodingMacArabic        = 4,
+  kTextEncodingMacHebrew        = 5,
+  kTextEncodingMacGreek         = 6,
+  kTextEncodingMacCyrillic      = 7,
+  kTextEncodingMacDevanagari    = 9,
+  kTextEncodingMacGurmukhi      = 10,
+  kTextEncodingMacGujarati      = 11,
+  kTextEncodingMacOriya         = 12,
+  kTextEncodingMacBengali       = 13,
+  kTextEncodingMacTamil         = 14,
+  kTextEncodingMacTelugu        = 15,
+  kTextEncodingMacKannada       = 16,
+  kTextEncodingMacMalayalam     = 17,
+  kTextEncodingMacSinhalese     = 18,
+  kTextEncodingMacBurmese       = 19,
+  kTextEncodingMacKhmer         = 20,
+  kTextEncodingMacThai          = 21,
+  kTextEncodingMacLaotian       = 22,
+  kTextEncodingMacGeorgian      = 23,
+  kTextEncodingMacArmenian      = 24,
+  kTextEncodingMacChineseSimp   = 25,
+  kTextEncodingMacTibetan       = 26,
+  kTextEncodingMacMongolian     = 27,
+  kTextEncodingMacEthiopic      = 28,
+  kTextEncodingMacCentralEurRoman = 29,
+  kTextEncodingMacVietnamese    = 30,
+  kTextEncodingMacExtArabic     = 31,   /* The following use script code 0, smRoman*/
+  kTextEncodingMacSymbol        = 33,
+  kTextEncodingMacDingbats      = 34,
+  kTextEncodingMacTurkish       = 35,
+  kTextEncodingMacCroatian      = 36,
+  kTextEncodingMacIcelandic     = 37,
+  kTextEncodingMacRomanian      = 38,
+  kTextEncodingMacCeltic        = 39,
+  kTextEncodingMacGaelic        = 40,
+  kTextEncodingMacKeyboardGlyphs = 41
+};
+
+/* The following are older names for backward compatibility*/
+enum {
+  kTextEncodingMacTradChinese   = kTextEncodingMacChineseTrad,
+  kTextEncodingMacRSymbol       = 8,
+  kTextEncodingMacSimpChinese   = kTextEncodingMacChineseSimp,
+  kTextEncodingMacGeez          = kTextEncodingMacEthiopic,
+  kTextEncodingMacEastEurRoman  = kTextEncodingMacCentralEurRoman,
+  kTextEncodingMacUninterp      = 32
+};
+
+
+/*
+   Beginning in Mac OS 8.5, the following meta-value is used to indicate Unicode in some parts
+   of the Mac OS which previously only expected a Mac OS script code. In some of these places,
+   only 7 bits are available to indicate encoding (script code), so kTextEncodingUnicodeDefault
+   cannot be used. For example, kTextEncodingMacUnicode can be used to indicate Unicode in the
+   7-bit script code field of a Unicode input method's ComponentDescription.componentFlags field;
+   it can also be used to indicate Unicode in the 16-bit script code field of an AppleEvent's
+   typeIntlWritingCode text tag.
+*/
+enum {
+  kTextEncodingMacUnicode       = 0x7E  /* Meta-value, Unicode as a Mac encoding*/
+};
+
+/* Variant Mac OS encodings that use script codes other than 0*/
+enum {
+                                        /* The following use script code 4, smArabic*/
+  kTextEncodingMacFarsi         = 0x8C, /* Like MacArabic but uses Farsi digits*/
+                                        /* The following use script code 7, smCyrillic*/
+  kTextEncodingMacUkrainian     = 0x98, /* Meta-value in TEC 1.5 & later; maps to kTextEncodingMacCyrillic variant    */
+                                        /* The following use script code 28, smEthiopic*/
+  kTextEncodingMacInuit         = 0xEC, /* The following use script code 32, smUnimplemented*/
+  kTextEncodingMacVT100         = 0xFC  /* VT100/102 font from Comm Toolbox: Latin-1 repertoire + box drawing etc*/
+};
+
+/* Special Mac OS encodings*/
+enum {
+  kTextEncodingMacHFS           = 0xFF  /* Meta-value, should never appear in a table.*/
+};
+
+/* Unicode & ISO UCS encodings begin at 0x100*/
+enum {
+  kTextEncodingUnicodeDefault   = 0x0100, /* Meta-value, should never appear in a table.*/
+  kTextEncodingUnicodeV1_1      = 0x0101,
+  kTextEncodingISO10646_1993    = 0x0101, /* Code points identical to Unicode 1.1*/
+  kTextEncodingUnicodeV2_0      = 0x0103, /* New location for Korean Hangul*/
+  kTextEncodingUnicodeV2_1      = 0x0103, /* We treat both Unicode 2.0 and Unicode 2.1 as 2.1*/
+  kTextEncodingUnicodeV3_0      = 0x0104,
+  kTextEncodingUnicodeV3_1      = 0x0105, /* Adds characters requiring surrogate pairs in UTF-16*/
+  kTextEncodingUnicodeV3_2      = 0x0106,
+  kTextEncodingUnicodeV4_0      = 0x0108,
+  kTextEncodingUnicodeV5_0      = 0x010A,
+  kTextEncodingUnicodeV5_1      = 0x010B
+};
+
+/* ISO 8-bit and 7-bit encodings begin at 0x200*/
+enum {
+  kTextEncodingISOLatin1        = 0x0201, /* ISO 8859-1, Western European*/
+  kTextEncodingISOLatin2        = 0x0202, /* ISO 8859-2, Central European*/
+  kTextEncodingISOLatin3        = 0x0203, /* ISO 8859-3, South European (Maltese...)*/
+  kTextEncodingISOLatin4        = 0x0204, /* ISO 8859-4, North European & some Baltic*/
+  kTextEncodingISOLatinCyrillic = 0x0205, /* ISO 8859-5*/
+  kTextEncodingISOLatinArabic   = 0x0206, /* ISO 8859-6, = ASMO 708, =DOS CP 708*/
+  kTextEncodingISOLatinGreek    = 0x0207, /* ISO 8859-7*/
+  kTextEncodingISOLatinHebrew   = 0x0208, /* ISO 8859-8*/
+  kTextEncodingISOLatin5        = 0x0209, /* ISO 8859-9, Turkish*/
+  kTextEncodingISOLatin6        = 0x020A, /* ISO 8859-10, Nordic                    */
+  kTextEncodingISOLatin7        = 0x020D, /* ISO 8859-13, Baltic Rim                   */
+  kTextEncodingISOLatin8        = 0x020E, /* ISO 8859-14, Celtic                    */
+  kTextEncodingISOLatin9        = 0x020F, /* ISO 8859-15, 8859-1 changed for EURO & CP1252 letters  */
+  kTextEncodingISOLatin10       = 0x0210 /* ISO 8859-16, Romanian*/
+};
+
+/* MS-DOS & Windows encodings begin at 0x400*/
+enum {
+  kTextEncodingDOSLatinUS       = 0x0400, /* code page 437*/
+  kTextEncodingDOSGreek         = 0x0405, /* code page 737 (formerly code page 437G)*/
+  kTextEncodingDOSBalticRim     = 0x0406, /* code page 775*/
+  kTextEncodingDOSLatin1        = 0x0410, /* code page 850, "Multilingual"*/
+  kTextEncodingDOSGreek1        = 0x0411, /* code page 851*/
+  kTextEncodingDOSLatin2        = 0x0412, /* code page 852, Slavic*/
+  kTextEncodingDOSCyrillic      = 0x0413, /* code page 855, IBM Cyrillic*/
+  kTextEncodingDOSTurkish       = 0x0414, /* code page 857, IBM Turkish*/
+  kTextEncodingDOSPortuguese    = 0x0415, /* code page 860*/
+  kTextEncodingDOSIcelandic     = 0x0416, /* code page 861*/
+  kTextEncodingDOSHebrew        = 0x0417, /* code page 862*/
+  kTextEncodingDOSCanadianFrench = 0x0418, /* code page 863*/
+  kTextEncodingDOSArabic        = 0x0419, /* code page 864*/
+  kTextEncodingDOSNordic        = 0x041A, /* code page 865*/
+  kTextEncodingDOSRussian       = 0x041B, /* code page 866*/
+  kTextEncodingDOSGreek2        = 0x041C, /* code page 869, IBM Modern Greek*/
+  kTextEncodingDOSThai          = 0x041D, /* code page 874, also for Windows*/
+  kTextEncodingDOSJapanese      = 0x0420, /* code page 932, also for Windows; Shift-JIS with additions*/
+  kTextEncodingDOSChineseSimplif = 0x0421, /* code page 936, also for Windows; was EUC-CN, now GBK (EUC-CN extended)*/
+  kTextEncodingDOSKorean        = 0x0422, /* code page 949, also for Windows; Unified Hangul Code (EUC-KR extended)*/
+  kTextEncodingDOSChineseTrad   = 0x0423, /* code page 950, also for Windows; Big-5*/
+  kTextEncodingWindowsLatin1    = 0x0500, /* code page 1252*/
+  kTextEncodingWindowsANSI      = 0x0500, /* code page 1252 (alternate name)*/
+  kTextEncodingWindowsLatin2    = 0x0501, /* code page 1250, Central Europe*/
+  kTextEncodingWindowsCyrillic  = 0x0502, /* code page 1251, Slavic Cyrillic*/
+  kTextEncodingWindowsGreek     = 0x0503, /* code page 1253*/
+  kTextEncodingWindowsLatin5    = 0x0504, /* code page 1254, Turkish*/
+  kTextEncodingWindowsHebrew    = 0x0505, /* code page 1255*/
+  kTextEncodingWindowsArabic    = 0x0506, /* code page 1256*/
+  kTextEncodingWindowsBalticRim = 0x0507, /* code page 1257*/
+  kTextEncodingWindowsVietnamese = 0x0508, /* code page 1258*/
+  kTextEncodingWindowsKoreanJohab = 0x0510 /* code page 1361, for Windows NT*/
+};
+
+/* Various national standards begin at 0x600*/
+enum {
+  kTextEncodingUS_ASCII         = 0x0600,
+  kTextEncodingANSEL            = 0x0601, /* ANSEL (ANSI Z39.47) for library use*/
+  kTextEncodingJIS_X0201_76     = 0x0620, /* JIS Roman and 1-byte katakana (halfwidth)*/
+  kTextEncodingJIS_X0208_83     = 0x0621,
+  kTextEncodingJIS_X0208_90     = 0x0622,
+  kTextEncodingJIS_X0212_90     = 0x0623,
+  kTextEncodingJIS_C6226_78     = 0x0624,
+  kTextEncodingShiftJIS_X0213   = 0x0628, /* Shift-JIS format encoding of JIS X0213 planes 1 and 2*/
+  kTextEncodingJIS_X0213_MenKuTen = 0x0629, /* JIS X0213 in plane-row-column notation (3 bytes)*/
+  kTextEncodingGB_2312_80       = 0x0630,
+  kTextEncodingGBK_95           = 0x0631, /* annex to GB 13000-93; for Windows 95; EUC-CN extended*/
+  kTextEncodingGB_18030_2000    = 0x0632,
+  kTextEncodingKSC_5601_87      = 0x0640, /* same as KSC 5601-92 without Johab annex*/
+  kTextEncodingKSC_5601_92_Johab = 0x0641, /* KSC 5601-92 Johab annex*/
+  kTextEncodingCNS_11643_92_P1  = 0x0651, /* CNS 11643-1992 plane 1*/
+  kTextEncodingCNS_11643_92_P2  = 0x0652, /* CNS 11643-1992 plane 2*/
+  kTextEncodingCNS_11643_92_P3  = 0x0653 /* CNS 11643-1992 plane 3 (was plane 14 in 1986 version)*/
+};
+
+/* ISO 2022 collections begin at 0x800*/
+enum {
+  kTextEncodingISO_2022_JP      = 0x0820, /* RFC 1468*/
+  kTextEncodingISO_2022_JP_2    = 0x0821, /* RFC 1554*/
+  kTextEncodingISO_2022_JP_1    = 0x0822, /* RFC 2237*/
+  kTextEncodingISO_2022_JP_3    = 0x0823, /* JIS X0213*/
+  kTextEncodingISO_2022_CN      = 0x0830, /* RFC 1922*/
+  kTextEncodingISO_2022_CN_EXT  = 0x0831, /* RFC 1922*/
+  kTextEncodingISO_2022_KR      = 0x0840 /* RFC 1557*/
+};
+
+/* EUC collections begin at 0x900*/
+enum {
+  kTextEncodingEUC_JP           = 0x0920, /* ISO 646, 1-byte katakana, JIS 208, JIS 212*/
+  kTextEncodingEUC_CN           = 0x0930, /* ISO 646, GB 2312-80*/
+  kTextEncodingEUC_TW           = 0x0931, /* ISO 646, CNS 11643-1992 Planes 1-16*/
+  kTextEncodingEUC_KR           = 0x0940 /* RFC 1557: ISO 646, KS C 5601-1987*/
+};
+
+/* Misc standards begin at 0xA00*/
+enum {
+  kTextEncodingShiftJIS         = 0x0A01, /* plain Shift-JIS*/
+  kTextEncodingKOI8_R           = 0x0A02, /* RFC 1489, Russian internet standard*/
+  kTextEncodingBig5             = 0x0A03, /* Big-5 (has variants)*/
+  kTextEncodingMacRomanLatin1   = 0x0A04, /* Mac OS Roman permuted to align with ISO Latin-1*/
+  kTextEncodingHZ_GB_2312       = 0x0A05, /* HZ (RFC 1842, for Chinese mail & news)*/
+  kTextEncodingBig5_HKSCS_1999  = 0x0A06, /* Big-5 with Hong Kong special char set supplement*/
+  kTextEncodingVISCII           = 0x0A07, /* RFC 1456, Vietnamese*/
+  kTextEncodingKOI8_U           = 0x0A08, /* RFC 2319, Ukrainian*/
+  kTextEncodingBig5_E           = 0x0A09 /* Taiwan Big-5E standard*/
+};
+
+/* Other platform encodings*/
+enum {
+  kTextEncodingNextStepLatin    = 0x0B01, /* NextStep Latin encoding*/
+  kTextEncodingNextStepJapanese = 0x0B02 /* NextStep Japanese encoding (variant of EUC-JP)*/
+};
+
+/* EBCDIC & IBM host encodings begin at 0xC00*/
+enum {
+  kTextEncodingEBCDIC_LatinCore = 0x0C01, /* Common base subset of EBCDIC Latin encodings*/
+  kTextEncodingEBCDIC_CP037     = 0x0C02 /* code page 037, extended EBCDIC (Latin-1 set) for US,Canada...*/
+};
+
+/* Special values*/
+enum {
+  kTextEncodingMultiRun         = 0x0FFF, /* Multi-encoding text with external run info*/
+  kTextEncodingUnknown          = 0xFFFF /* Unknown or unspecified                  */
+};
+
+/* The following are older names for backward compatibility*/
+enum {
+  kTextEncodingEBCDIC_US        = 0x0C01
+};
+
+
+/* TextEncodingVariant type & values */
+typedef UInt32                          TextEncodingVariant;
+/* Default TextEncodingVariant, for any TextEncodingBase*/
+enum {
+  kTextEncodingDefaultVariant   = 0
+};
+
+/* Variants of kTextEncodingMacRoman                                                        */
+enum {
+  kMacRomanDefaultVariant       = 0,    /* meta value, maps to 1 or 2 depending on System */
+  kMacRomanCurrencySignVariant  = 1,    /* Mac OS version < 8.5, 0xDB is CURRENCY SIGN*/
+  kMacRomanEuroSignVariant      = 2     /* Mac OS version >= 8.5, 0xDB is EURO SIGN      */
+};
+
+/* Variants of kTextEncodingMacCyrillic (for TEC 1.5 and later)                             */
+enum {
+  kMacCyrillicDefaultVariant    = 0,    /* meta value, maps to 1, 2, or 3 depending on System*/
+  kMacCyrillicCurrSignStdVariant = 1,   /* Mac OS < 9.0 (RU,BG), 0xFF = CURRENCY SIGN, 0xA2/0xB6 = CENT / PARTIAL DIFF.*/
+  kMacCyrillicCurrSignUkrVariant = 2,   /* Mac OS < 9.0 (UA,LangKit), 0xFF = CURRENCY SIGN, 0xA2/0xB6 = GHE WITH UPTURN*/
+  kMacCyrillicEuroSignVariant   = 3     /* Mac OS >= 9.0, 0xFF is EURO SIGN, 0xA2/0xB6 = GHE WITH UPTURN*/
+};
+
+/* Variants of kTextEncodingMacIcelandic                                                    */
+enum {
+  kMacIcelandicStdDefaultVariant = 0,   /* meta value, maps to 2 or 4 depending on System */
+  kMacIcelandicTTDefaultVariant = 1,    /* meta value, maps to 3 or 5 depending on System */
+                                        /* The following are for Mac OS version < 8.5, 0xDB is CURRENCY SIGN             */
+  kMacIcelandicStdCurrSignVariant = 2,  /* 0xBB/0xBC are fem./masc. ordinal indicators*/
+  kMacIcelandicTTCurrSignVariant = 3,   /* 0xBB/0xBC are fi/fl ligatures*/
+                                        /* The following are for Mac OS version >= 8.5, 0xDB is EURO SIGN                  */
+  kMacIcelandicStdEuroSignVariant = 4,  /* 0xBB/0xBC are fem./masc. ordinal indicators*/
+  kMacIcelandicTTEuroSignVariant = 5    /* 0xBB/0xBC are fi/fl ligatures*/
+};
+
+/* Variants of kTextEncodingMacCroatian                                                     */
+enum {
+  kMacCroatianDefaultVariant    = 0,    /* meta value, maps to 1 or 2 depending on System */
+  kMacCroatianCurrencySignVariant = 1,  /* Mac OS version < 8.5, 0xDB is CURRENCY SIGN       */
+  kMacCroatianEuroSignVariant   = 2     /* Mac OS version >= 8.5, 0xDB is EURO SIGN      */
+};
+
+
+/* Variants of kTextEncodingMacRomanian                                                     */
+enum {
+  kMacRomanianDefaultVariant    = 0,    /* meta value, maps to 1 or 2 depending on System */
+  kMacRomanianCurrencySignVariant = 1,  /* Mac OS version < 8.5, 0xDB is CURRENCY SIGN       */
+  kMacRomanianEuroSignVariant   = 2     /* Mac OS version >= 8.5, 0xDB is EURO SIGN      */
+};
+
+
+/* Variants of kTextEncodingMacJapanese*/
+enum {
+  kMacJapaneseStandardVariant   = 0,
+  kMacJapaneseStdNoVerticalsVariant = 1,
+  kMacJapaneseBasicVariant      = 2,
+  kMacJapanesePostScriptScrnVariant = 3,
+  kMacJapanesePostScriptPrintVariant = 4,
+  kMacJapaneseVertAtKuPlusTenVariant = 5
+};
+
+/* Variants of kTextEncodingMacArabic*/
+enum {
+  kMacArabicStandardVariant     = 0,    /* 0xC0 is 8-spoke asterisk, 0x2A & 0xAA are asterisk (e.g. Cairo)*/
+  kMacArabicTrueTypeVariant     = 1,    /* 0xC0 is asterisk, 0x2A & 0xAA are multiply signs (e.g. Baghdad)*/
+  kMacArabicThuluthVariant      = 2,    /* 0xC0 is Arabic five-point star, 0x2A & 0xAA are multiply signs*/
+  kMacArabicAlBayanVariant      = 3     /* 8-spoke asterisk, multiply sign, Koranic ligatures & parens*/
+};
+
+/* Variants of kTextEncodingMacFarsi*/
+enum {
+  kMacFarsiStandardVariant      = 0,    /* 0xC0 is 8-spoke asterisk, 0x2A & 0xAA are asterisk (e.g. Tehran)*/
+  kMacFarsiTrueTypeVariant      = 1     /* asterisk, multiply signs, Koranic ligatures, geometric shapes*/
+};
+
+/* Variants of kTextEncodingMacHebrew*/
+enum {
+  kMacHebrewStandardVariant     = 0,
+  kMacHebrewFigureSpaceVariant  = 1
+};
+
+/* Variants of kTextEncodingMacGreek*/
+enum {
+  kMacGreekDefaultVariant       = 0,    /* meta value, maps to 1 or 2 depending on System*/
+  kMacGreekNoEuroSignVariant    = 1,    /* Mac OS version < 9.2.2, 0x9C is SOFT HYPHEN, 0xFF is undefined*/
+  kMacGreekEuroSignVariant      = 2     /* Mac OS version >= 9.2.2, 0x9C is EURO SIGN, 0xFF is SOFT HYPHEN*/
+};
+
+/* Variants of kTextEncodingMacVT100                                                        */
+enum {
+  kMacVT100DefaultVariant       = 0,    /* meta value, maps to 1 or 2 depending on System */
+  kMacVT100CurrencySignVariant  = 1,    /* Mac OS version < 8.5, 0xDB is CURRENCY SIGN       */
+  kMacVT100EuroSignVariant      = 2     /* Mac OS version >= 8.5, 0xDB is EURO SIGN      */
+};
+
+/* Variants of Unicode & ISO 10646 encodings*/
+enum {
+  kUnicodeNoSubset              = 0,
+  kUnicodeNormalizationFormD    = 5,    /* canonical decomposition (NFD); excludes composed chars*/
+  kUnicodeNormalizationFormC    = 3,    /* canonical composition (NFC); uses the composed chars as of Unicode 3.1*/
+  kUnicodeHFSPlusDecompVariant  = 8,    /* decomposition for HFS+; doesn't decompose in 2000-2FFF, F900-FAFF, 2F800-2FAFF*/
+  kUnicodeHFSPlusCompVariant    = 9     /* composition based on HFS+ decomposition*/
+};
+
+/* Variants of kTextEncodingISOLatin1*/
+enum {
+  kISOLatin1StandardVariant     = 0,
+  kISOLatin1MusicCDVariant      = 1
+};
+
+/*
+   Variants of kTextEncodingISOLatinArabic, kTextEncodingISOLatinHebrew.
+   Per RFC 1556 and ECMA TR/53, there are three ways of handling bidirectional text
+   in the ISO character sets 8859-6 (Arabic) and 8859-8 (Hebrew).
+   1. Implicit or Logical order is "a presentation method in which the direction is
+   determined by an algorithm according to the type of characters and their position
+   relative to the adjacent characters and according to their primary direction." This
+   is the method normally used for Unicode and for the Mac OS and Windows Arabic and
+   Hebrew encodings.
+   2. Visual order assumes the text is already ordered such that it can be displayed
+   in a left-to-right display direction with no further directional processing. This
+   is equivalent to treating all characters as having strong left-right directionality.
+   This is the default assumed for internet Hebrew text encoded in ISO 8859-8, unless
+   the charset label suffix specifically indicates implicit (-i) or explicit (-e)
+   ordering.
+   3. Explicit order is "a presentation method in which the direction is explicitly
+   defined by using control sequences which are interleaved within the text and are
+   used for direction determination."
+*/
+enum {
+  kISOLatinArabicImplicitOrderVariant = 0,
+  kISOLatinArabicVisualOrderVariant = 1,
+  kISOLatinArabicExplicitOrderVariant = 2
+};
+
+enum {
+  kISOLatinHebrewImplicitOrderVariant = 0,
+  kISOLatinHebrewVisualOrderVariant = 1,
+  kISOLatinHebrewExplicitOrderVariant = 2
+};
+
+/* Variants of kTextEncodingWindowsLatin1*/
+enum {
+  kWindowsLatin1StandardVariant = 0,
+  kWindowsLatin1PalmVariant     = 1     /* PalmSource variant of cp1252*/
+};
+
+/* Variants of kTextEncodingDOSJapanese*/
+enum {
+  kDOSJapaneseStandardVariant   = 0,
+  kDOSJapanesePalmVariant       = 1     /* PalmSource variant of cp932*/
+};
+
+/*
+   Variants of EUC_CN
+   The DOSVariant is like kTextEncodingDOSChineseSimplif, but with the
+   basic EUC_CN part mapped as per kTextEncodingEUC_CN.
+*/
+enum {
+  kEUC_CN_BasicVariant          = 0,
+  kEUC_CN_DOSVariant            = 1
+};
+
+/*
+   Variants of EUC_KR
+   The DOSVariant is like kTextEncodingDOSKorean, but with the
+   basic EUC_KR part mapped as per kTextEncodingEUC_KR.
+*/
+enum {
+  kEUC_KR_BasicVariant          = 0,
+  kEUC_KR_DOSVariant            = 1
+};
+
+/*
+   Variants of ShiftJIS
+   The DOSVariant is like kTextEncodingDOSJapanese, but with the
+   basic ShiftJIS part mapped as per kTextEncodingShiftJIS.
+*/
+enum {
+  kShiftJIS_BasicVariant        = 0,
+  kShiftJIS_DOSVariant          = 1,
+  kShiftJIS_MusicCDVariant      = 2     /* MusicShiftJIS, per RIS-506 (RIAJ)*/
+};
+
+/*
+   Variants of Big-5 encoding
+   The DOSVariant is like kTextEncodingDOSChineseTrad, but with the
+   basic Big5 part mapped as per kTextEncodingBig5.
+*/
+enum {
+  kBig5_BasicVariant            = 0,
+  kBig5_StandardVariant         = 1,    /* 0xC6A1-0xC7FC: kana, Cyrillic, enclosed numerics*/
+  kBig5_ETenVariant             = 2,    /* adds kana, Cyrillic, radicals, etc with hi bytes C6-C8,F9*/
+  kBig5_DOSVariant              = 3
+};
+
+/* Variants of MacRomanLatin1                                                               */
+enum {
+  kMacRomanLatin1DefaultVariant = 0,    /* meta value, maps to others depending on System*/
+  kMacRomanLatin1StandardVariant = 2,   /* permuted MacRoman, EuroSignVariant*/
+  kMacRomanLatin1TurkishVariant = 6,    /* permuted MacTurkish*/
+  kMacRomanLatin1CroatianVariant = 8,   /* permuted MacCroatian, EuroSignVariant*/
+  kMacRomanLatin1IcelandicVariant = 11, /* permuted MacIcelandic, StdEuroSignVariant*/
+  kMacRomanLatin1RomanianVariant = 14   /* permuted MacRomanian, EuroSignVariant*/
+};
+
+/* Unicode variants not yet supported (and not fully defined)*/
+enum {
+  kUnicodeNoCompatibilityVariant = 1,
+  kUnicodeNoCorporateVariant    = 4
+};
+
+/* The following are older names for backward compatibility*/
+enum {
+  kMacRomanStandardVariant      = 0,
+  kMacIcelandicStandardVariant  = 0,
+  kMacIcelandicTrueTypeVariant  = 1,
+  kJapaneseStandardVariant      = 0,
+  kJapaneseStdNoVerticalsVariant = 1,
+  kJapaneseBasicVariant         = 2,
+  kJapanesePostScriptScrnVariant = 3,
+  kJapanesePostScriptPrintVariant = 4,
+  kJapaneseVertAtKuPlusTenVariant = 5,
+  kTextEncodingShiftJIS_X0213_00 = 0x0628, /* Shift-JIS format encoding of JIS X0213 planes 1 and 2*/
+                                        /* kJapaneseStdNoOneByteKanaVariant = 6,  // replaced by kJapaneseNoOneByteKanaOption*/
+                                        /* kJapaneseBasicNoOneByteKanaVariant = 7,    // replaced by kJapaneseNoOneByteKanaOption    */
+  kHebrewStandardVariant        = 0,
+  kHebrewFigureSpaceVariant     = 1,    /* Old Unicode variants. Variant 2 (kUnicodeCanonicalDecompVariant, kUnicodeMaxDecomposedVariant) is ambiguous and means*/
+                                        /* different things in different contexts. When normalizing (using ConvertFromUnicodeToText to convert from arbitrary*/
+                                        /* Unicode to a normalized form), Unicode variant 2 means the same thing as kUnicodeNormalizationFormD (i.e. NFD).*/
+                                        /* However, when converting between Unicode and traditional Mac OS encodings, Unicode variant 2 means the same thing as*/
+                                        /* kUnicodeHFSPlusDecompVariant (i.e. the special HFS decomposition which excludes some character ranges from normalization).*/
+                                        /* For clarity, please use the less ambiguous constants: kUnicodeNormalizationFormD = 5, kUnicodeHFSPlusDecompVariant = 8.*/
+                                        /* */
+  kUnicodeCanonicalDecompVariant = 2,   /* use kUnicodeNormalizationFormD or kUnicodeHFSPlusDecompVariant*/
+  kUnicodeMaxDecomposedVariant  = 2,    /* use kUnicodeNormalizationFormD or kUnicodeHFSPlusDecompVariant*/
+  kUnicodeCanonicalCompVariant  = 3,    /* replaced by kUnicodeNormalizationFormC*/
+  kUnicodeNoComposedVariant     = 3     /* this really meant NoComposing; replaced by kUnicodeNormalizationFormC*/
+};
+
+/* TextEncodingFormat type & values */
+typedef UInt32                          TextEncodingFormat;
+enum {
+                                        /* Default TextEncodingFormat for any TextEncodingBase*/
+  kTextEncodingDefaultFormat    = 0,    /* Formats for Unicode & ISO 10646*/
+  kUnicodeUTF16Format           = 0,    /* UTF16 form (16-bit units), native or external byte order (see below)*/
+  kUnicodeUTF7Format            = 1,    /* UTF7 form*/
+  kUnicodeUTF8Format            = 2,    /* UTF8 form*/
+  kUnicodeUTF32Format           = 3,    /* UTF32 form (32-bit units), native or external byte order (see below)*/
+  kUnicodeUTF16BEFormat         = 4,    /* UTF16 form, explicit big-endian byte order, no BOM*/
+  kUnicodeUTF16LEFormat         = 5,    /* UTF16 form, explicit little-endian byte order, no BOM*/
+  kUnicodeUTF32BEFormat         = 6,    /* UTF32 form, explicit big-endian byte order, no BOM*/
+  kUnicodeUTF32LEFormat         = 7,    /* UTF32 form, explicit little-endian byte order, no BOM*/
+  kUnicodeSCSUFormat            = 8,    /* Std. Compression Scheme for Unicode, Unicode Tech Std. #6*/
+                                        /* Note for kUnicodeUTF16Format and kUnicodeUTF32Format:*/
+                                        /* - An array of UTF16Char (UniChar) or UTF32Char is normally understood to use "internal" or*/
+                                        /* platform-native byte ordering for kUnicodeUTF16Format and kUnicodeUTF32Format; the array MAY*/
+                                        /* begin with byte-order mark (BOM), but the BOM should match the internal ordering.*/
+                                        /* - If an array of bytes (such as char *) that can be in various encodings is specified to be*/
+                                        /* in Unicode with kUnicodeUTF16Format or kUnicodeUTF32Format (not explicitly BE or LE), then it*/
+                                        /* is assumed to use "external" byte ordering, which means: If there is a BOM at the beginning*/
+                                        /* of text, the BOM specifies the byte ordering, otherwise big-endian is assumed.*/
+                                        /* Synonyms for some Unicode formats*/
+  kUnicode16BitFormat           = 0,
+  kUnicode32BitFormat           = 3
+};
+
+/* TextEncoding type */
+typedef UInt32                          TextEncoding;
+/* name part selector for GetTextEncodingName*/
+typedef UInt32                          TextEncodingNameSelector;
+enum {
+  kTextEncodingFullName         = 0,
+  kTextEncodingBaseName         = 1,
+  kTextEncodingVariantName      = 2,
+  kTextEncodingFormatName       = 3
+};
+
+/* Types used in conversion */
+struct TextEncodingRun {
+  ByteOffset          offset;
+  TextEncoding        textEncoding;
+};
+typedef struct TextEncodingRun          TextEncodingRun;
+typedef TextEncodingRun *               TextEncodingRunPtr;
+typedef const TextEncodingRun *         ConstTextEncodingRunPtr;
+struct ScriptCodeRun {
+  ByteOffset          offset;
+  ScriptCode          script;
+};
+typedef struct ScriptCodeRun            ScriptCodeRun;
+typedef ScriptCodeRun *                 ScriptCodeRunPtr;
+typedef const ScriptCodeRun *           ConstScriptCodeRunPtr;
+typedef UInt8 *                         TextPtr;
+typedef const UInt8 *                   ConstTextPtr;
+/* Basic types for Unicode characters and strings:*/
+typedef UniChar *                       UniCharArrayPtr;
+typedef const UniChar *                 ConstUniCharArrayPtr;
+/*
+   UniCharArrayHandle is a handle type to correspond to UniCharArrayPtr,
+   i.e. a handle to an array of UniChars (UInt16s).
+*/
+typedef UniCharArrayPtr *               UniCharArrayHandle;
+/*
+   UniCharArrayOffset is used to indicate an edge offset in an array
+   of UniChars (UInt16s).  
+*/
+typedef unsigned long                   UniCharArrayOffset;
+/* enums for TextEncoding Conversion routines*/
+enum {
+  kTextScriptDontCare           = -128,
+  kTextLanguageDontCare         = -128,
+  kTextRegionDontCare           = -128
+};
+
+/* struct for TECGetInfo*/
+
+struct TECInfo {
+  UInt16              format;                 /* format code for this struct*/
+  UInt16              tecVersion;             /* TEC version in BCD, e.g. 0x0121 for 1.2.1*/
+  UInt32              tecTextConverterFeatures; /* bitmask indicating TEC features/fixes*/
+  UInt32              tecUnicodeConverterFeatures; /* bitmask indicating UnicodeConverter features/fixes*/
+  UInt32              tecTextCommonFeatures;  /* bitmask indicating TextCommon features/fixes*/
+  Str31               tecTextEncodingsFolderName; /* localized name of Text Encodings folder (pascal string)*/
+  Str31               tecExtensionFileName;   /* localized name of TEC extension (pascal string)*/
+  UInt16              tecLowestTEFileVersion; /* Lowest version (BCD) of all files in Text Encodings folder*/
+  UInt16              tecHighestTEFileVersion; /* Highest version (BCD) of all files in Text Encodings folder*/
+};
+typedef struct TECInfo                  TECInfo;
+typedef TECInfo *                       TECInfoPtr;
+typedef TECInfoPtr *                    TECInfoHandle;
+/* Value for TECInfo format code*/
+enum {
+  kTECInfoCurrentFormat         = 2     /* any future formats will just add fields at the end*/
+};
+
+/*
+   Defined feature/fix bits for tecUnicodeConverterFeatures field
+   Bit:                             Meaning if set:
+   ----                             ---------------
+   kTECKeepInfoFixBit               Unicode Converter no longer ignores other control flags if
+                                    kUnicodeKeepInfoBit is set. Bug fix in TEC Manager 1.2.1.
+   kTECFallbackTextLengthFixBit     Unicode Converter honors the *srcConvLen and *destConvLen
+                                    returned by caller-supplied fallback handler for any status it
+                                    returns except for kTECUnmappableElementErr (previously it only
+                                    honored these values if noErr was returned). Bug fix in TEC
+                                    Manager 1.2.1.
+   kTECTextRunBitClearFixBit        ConvertFromUnicodeToTextRun & ConvertFromUnicodeToScriptCodeRun
+                                    function correctly if the kUnicodeTextRunBit is set (previously
+                                    their determination of best target encoding was incorrect). Bug
+                                    fix in TEC Manager 1.3.
+   kTECTextToUnicodeScanFixBit      ConvertFromTextToUnicode uses an improved scanner and maintains
+                                    some resulting state information, which it uses for mapping.
+                                    This has several effects:
+                                    - Improved mapping of 0x30-0x39 digits in Mac OS Arabic, fewer
+                                      direction overrides when mapping Mac OS Arabic & Hebrew, and
+                                      improved mapping of certain characters in Indic encodings.
+                                    - Malformed input produces kTextMalformedInputErr.
+                                    - ConvertFromTextToUnicode accepts and uses the control flags
+                                      kUnicodeKeepInfoMask and kUnicodeStringUnterminatedMask.
+                                    Bug fix and enhancement in TEC Manager 1.3.
+   kTECAddForceASCIIChangesBit      Define new control flag bits kUnicodeForceASCIIRangeBit and
+                                    kUnicodeNoHalfwidthCharsBit for use with
+                                    ConvertFromTextToUnicode, ConvertFromUnicodeToText, etc.
+                                    Enhancement in TEC Manager 1.4.
+   kTECPreferredEncodingFixBit      CreateUnicodeToTextRunInfo and related functions fix a problem
+                                    that occurred when a preferred encoding was specified that did
+                                    not match the System script; the preferred script was not
+                                    actually placed first in the ordered list of encodings to use.
+                                    Bug fix in TEC Manager 1.4.
+   kTECAddTextRunHeuristicsBit      Define new control flag bit kUnicodeTextRunHeuristicsBit for
+                                    use with ConvertFromUnicodeToTextRun.
+   kTECAddFallbackInterruptBit      Define new option kUnicodeFallbackInterruptSafeMask for use
+                                    with SetFallbackUnicodeToText. If a client fallback handler is
+                                    installed without specifying this bit, ConvertFromUnicodeToText
+                                    will HLock the tables it uses (in case the fallback handler
+                                    moves memory); otherwise, it won't.
+*/
+
+enum {
+  kTECKeepInfoFixBit            = 0,
+  kTECFallbackTextLengthFixBit  = 1,
+  kTECTextRunBitClearFixBit     = 2,
+  kTECTextToUnicodeScanFixBit   = 3,
+  kTECAddForceASCIIChangesBit   = 4,
+  kTECPreferredEncodingFixBit   = 5,
+  kTECAddTextRunHeuristicsBit   = 6,
+  kTECAddFallbackInterruptBit   = 7
+};
+
+enum {
+  kTECKeepInfoFixMask           = 1L << kTECKeepInfoFixBit,
+  kTECFallbackTextLengthFixMask = 1L << kTECFallbackTextLengthFixBit,
+  kTECTextRunBitClearFixMask    = 1L << kTECTextRunBitClearFixBit,
+  kTECTextToUnicodeScanFixMask  = 1L << kTECTextToUnicodeScanFixBit,
+  kTECAddForceASCIIChangesMask  = 1L << kTECAddForceASCIIChangesBit,
+  kTECPreferredEncodingFixMask  = 1L << kTECPreferredEncodingFixBit,
+  kTECAddTextRunHeuristicsMask  = 1L << kTECAddTextRunHeuristicsBit,
+  kTECAddFallbackInterruptMask  = 1L << kTECAddFallbackInterruptBit
+};
+
+/*
+   -------------------------------------------------------------------------------------------------
+   CONSTANTS for common and special Unicode code values
+   -------------------------------------------------------------------------------------------------
+*/
+
+enum {
+  kUnicodeByteOrderMark         = 0xFEFF,
+  kUnicodeObjectReplacement     = 0xFFFC, /* placeholder for non-text object*/
+  kUnicodeReplacementChar       = 0xFFFD, /* Unicode replacement for unconvertable input char*/
+  kUnicodeSwappedByteOrderMark  = 0xFFFE, /* not a Unicode char; byte-swapped version of FEFF*/
+  kUnicodeNotAChar              = 0xFFFF /* not a Unicode char; may be used as a terminator*/
+};
+
+
+/*
+   -------------------------------------------------------------------------------------------------
+   CONSTANTS & DATA STRUCTURES for Unicode Properties
+   -------------------------------------------------------------------------------------------------
+*/
+
+typedef SInt32                          UCCharPropertyType;
+enum {
+  kUCCharPropTypeGenlCategory   = 1,    /* requests enumeration value*/
+  kUCCharPropTypeCombiningClass = 2,    /* requests numeric value 0..255*/
+  kUCCharPropTypeBidiCategory   = 3,    /* requests enumeration value*/
+  kUCCharPropTypeDecimalDigitValue = 4  /* requests numeric value 0..9 for decimal digit chars (get err for others)*/
+};
+
+typedef UInt32                          UCCharPropertyValue;
+/* General Category enumeration values (requested by kUCCharPropTypeGenlCategory)*/
+enum {
+                                        /* Normative categories:*/
+  kUCGenlCatOtherNotAssigned    = 0,    /* Cn Other, Not Assigned*/
+  kUCGenlCatOtherControl        = 1,    /* Cc Other, Control*/
+  kUCGenlCatOtherFormat         = 2,    /* Cf Other, Format*/
+  kUCGenlCatOtherSurrogate      = 3,    /* Cs Other, Surrogate*/
+  kUCGenlCatOtherPrivateUse     = 4,    /* Co Other, Private Use*/
+  kUCGenlCatMarkNonSpacing      = 5,    /* Mn Mark, Non-Spacing*/
+  kUCGenlCatMarkSpacingCombining = 6,   /* Mc Mark, Spacing Combining*/
+  kUCGenlCatMarkEnclosing       = 7,    /* Me Mark, Enclosing*/
+  kUCGenlCatNumberDecimalDigit  = 8,    /* Nd Number, Decimal Digit*/
+  kUCGenlCatNumberLetter        = 9,    /* Nl Number, Letter*/
+  kUCGenlCatNumberOther         = 10,   /* No Number, Other*/
+  kUCGenlCatSeparatorSpace      = 11,   /* Zs Separator, Space*/
+  kUCGenlCatSeparatorLine       = 12,   /* Zl Separator, Line*/
+  kUCGenlCatSeparatorParagraph  = 13,   /* Zp Separator, Paragraph*/
+  kUCGenlCatLetterUppercase     = 14,   /* Lu Letter, Uppercase*/
+  kUCGenlCatLetterLowercase     = 15,   /* Ll Letter, Lowercase*/
+  kUCGenlCatLetterTitlecase     = 16,   /* Lt Letter, Titlecase*/
+                                        /* Informative categories:*/
+  kUCGenlCatLetterModifier      = 17,   /* Lm Letter, Modifier*/
+  kUCGenlCatLetterOther         = 18,   /* Lo Letter, Other*/
+  kUCGenlCatPunctConnector      = 20,   /* Pc Punctuation, Connector*/
+  kUCGenlCatPunctDash           = 21,   /* Pd Punctuation, Dash*/
+  kUCGenlCatPunctOpen           = 22,   /* Ps Punctuation, Open*/
+  kUCGenlCatPunctClose          = 23,   /* Pe Punctuation, Close*/
+  kUCGenlCatPunctInitialQuote   = 24,   /* Pi Punctuation, Initial quote*/
+  kUCGenlCatPunctFinalQuote     = 25,   /* Pf Punctuation, Final quote*/
+  kUCGenlCatPunctOther          = 26,   /* Po Punctuation, Other*/
+  kUCGenlCatSymbolMath          = 28,   /* Sm Symbol, Math*/
+  kUCGenlCatSymbolCurrency      = 29,   /* Sc Symbol, Currency*/
+  kUCGenlCatSymbolModifier      = 30,   /* Sk Symbol, Modifier*/
+  kUCGenlCatSymbolOther         = 31    /* So Symbol, Other*/
+};
+
+/* Bidirectional Category enumeration values (requested by kUCCharPropTypeBidiCategory)*/
+enum {
+  kUCBidiCatNotApplicable       = 0,    /* for now use this for unassigned*/
+                                        /* Strong types:*/
+  kUCBidiCatLeftRight           = 1,    /* L  Left-to-Right*/
+  kUCBidiCatRightLeft           = 2,    /* R  Right-to-Left*/
+                                        /* Weak types:*/
+  kUCBidiCatEuroNumber          = 3,    /* EN European Number*/
+  kUCBidiCatEuroNumberSeparator = 4,    /* ES European Number Separator*/
+  kUCBidiCatEuroNumberTerminator = 5,   /* ET European Number Terminator*/
+  kUCBidiCatArabicNumber        = 6,    /* AN Arabic Number*/
+  kUCBidiCatCommonNumberSeparator = 7,  /* CS Common Number Separator*/
+                                        /* Separators:*/
+  kUCBidiCatBlockSeparator      = 8,    /* B  Paragraph Separator (was Block Separator)*/
+  kUCBidiCatSegmentSeparator    = 9,    /* S  Segment Separator*/
+                                        /* Neutrals:*/
+  kUCBidiCatWhitespace          = 10,   /* WS Whitespace*/
+  kUCBidiCatOtherNeutral        = 11,   /* ON Other Neutrals (unassigned codes could use this)*/
+                                        /* New categories for Unicode 3.0*/
+  kUCBidiCatRightLeftArabic     = 12,   /* AL Right-to-Left Arabic (was Arabic Letter)*/
+  kUCBidiCatLeftRightEmbedding  = 13,   /* LRE    Left-to-Right Embedding*/
+  kUCBidiCatRightLeftEmbedding  = 14,   /* RLE    Right-to-Left Embedding*/
+  kUCBidiCatLeftRightOverride   = 15,   /* LRO    Left-to-Right Override*/
+  kUCBidiCatRightLeftOverride   = 16,   /* RLO    Right-to-Left Override*/
+  kUCBidiCatPopDirectionalFormat = 17,  /* PDF    Pop Directional Format*/
+  kUCBidiCatNonSpacingMark      = 18,   /* NSM    Non-Spacing Mark*/
+  kUCBidiCatBoundaryNeutral     = 19    /* BN Boundary Neutral*/
+};
+
+
+/*
+   -------------------------------------------------------------------------------------------------
+   Prototypes for TextEncoding functions
+   -------------------------------------------------------------------------------------------------
+*/
+
+
+/*
+ *  CreateTextEncoding()
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in TextCommon 1.1 and later
+ */
+extern TextEncoding 
+CreateTextEncoding(
+  TextEncodingBase      encodingBase,
+  TextEncodingVariant   encodingVariant,
+  TextEncodingFormat    encodingFormat)                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  GetTextEncodingBase()
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in TextCommon 1.1 and later
+ */
+extern TextEncodingBase 
+GetTextEncodingBase(TextEncoding encoding)                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  GetTextEncodingVariant()
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in TextCommon 1.1 and later
+ */
+extern TextEncodingVariant 
+GetTextEncodingVariant(TextEncoding encoding)                 AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  GetTextEncodingFormat()
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in TextCommon 1.1 and later
+ */
+extern TextEncodingFormat 
+GetTextEncodingFormat(TextEncoding encoding)                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  ResolveDefaultTextEncoding()
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in TextCommon 1.1 and later
+ */
+extern TextEncoding 
+ResolveDefaultTextEncoding(TextEncoding encoding)             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  GetTextEncodingName()
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in TextCommon 1.1 and later
+ */
+extern OSStatus 
+GetTextEncodingName(
+  TextEncoding               iEncoding,
+  TextEncodingNameSelector   iNamePartSelector,
+  RegionCode                 iPreferredRegion,
+  TextEncoding               iPreferredEncoding,
+  ByteCount                  iOutputBufLen,
+  ByteCount *                oNameLength,
+  RegionCode *               oActualRegion,            /* can be NULL */
+  TextEncoding *             oActualEncoding,          /* can be NULL */
+  TextPtr                    oEncodingName)                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  TECGetInfo()
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in TextCommon 1.2.1 and later
+ */
+extern OSStatus 
+TECGetInfo(TECInfoHandle * tecInfo)                           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+
+/*
+ *  UpgradeScriptInfoToTextEncoding()
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in TextCommon 1.1 and later
+ */
+extern OSStatus 
+UpgradeScriptInfoToTextEncoding(
+  ScriptCode         iTextScriptID,
+  LangCode           iTextLanguageID,
+  RegionCode         iRegionID,
+  ConstStr255Param   iTextFontname,
+  TextEncoding *     oEncoding)                               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  RevertTextEncodingToScriptInfo()
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in TextCommon 1.1 and later
+ */
+extern OSStatus 
+RevertTextEncodingToScriptInfo(
+  TextEncoding   iEncoding,
+  ScriptCode *   oTextScriptID,
+  LangCode *     oTextLanguageID,       /* can be NULL */
+  Str255         oTextFontname)         /* can be NULL */     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  GetTextEncodingFromScriptInfo()
+ *  
+ *  Summary:
+ *    Converts any combination of a Mac OS script code, a language
+ *    code, and a region code to a text encoding.
+ *  
+ *  Discussion:
+ *    This function is almost identical to
+ *    UpgradeScriptInfoToTextEncoding except it doesn't take a font
+ *    name and it is available in CoreServices.
+ *  
+ *  Parameters:
+ *    
+ *    iTextScriptID:
+ *      A valid Script Manager script code. The Mac OS Script Manager
+ *      defines constants for script codes using this format: smXxx. To
+ *      designate the system script, specify the meta-value of
+ *      smSystemScript. To indicate that you do not want to provide a
+ *      script code for this parameter, specify the constant
+ *      kTextScriptDontCare.
+ *    
+ *    iTextLanguageID:
+ *      A valid Script Manager language code. The Mac OS Script Manager
+ *      defines constants for language codes using this format:
+ *      langXxx. To indicate that you do not want to provide a language
+ *      code for this parameter, specify the constant
+ *      kTextLanguageDontCare.
+ *    
+ *    iTextRegionID:
+ *      A valid Script Manager region code. The Mac OS Script Manager
+ *      defines constants for region codes using this format: verXxx.
+ *      To indicate that you do not want to provide a region code for
+ *      this parameter, specify the constant kTextRegionDontCare.
+ *    
+ *    oEncoding:
+ *      A pointer to a value of type TextEncoding. On return, this
+ *      value holds the text encoding specification that the function
+ *      created from the other values you provided.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.2 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.2 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus 
+GetTextEncodingFromScriptInfo(
+  ScriptCode      iTextScriptID,
+  LangCode        iTextLanguageID,
+  RegionCode      iTextRegionID,
+  TextEncoding *  oEncoding)                                  AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;
+
+
+/*
+ *  GetScriptInfoFromTextEncoding()
+ *  
+ *  Summary:
+ *    Converts the given Mac OS text encoding specification to the
+ *    corresponding script code and, if possible, language code.
+ *  
+ *  Discussion:
+ *    This function is almost identical to
+ *    RevertTextEncodingToScriptInfo except it doesn't return a font
+ *    name and it is available in CoreServices.
+ *  
+ *  Parameters:
+ *    
+ *    iEncoding:
+ *      The text encoding specification to be converted.
+ *    
+ *    oTextScriptID:
+ *      A pointer to a value of type ScriptCode. On return, a Mac OS
+ *      script code that corresponds to the text encoding specification
+ *      you identified in the iEncoding parameter. If you do not pass a
+ *      pointer for this parameter, the function returns a paramErr
+ *      result code.
+ *    
+ *    oTextLanguageID:
+ *      A pointer to a value of type LangCode. On input, if you do not
+ *      want the function to return the language code, specify NULL as
+ *      the value of this parameter. On return, the appropriate
+ *      language code, if the language can be unambiguously derived
+ *      from the text encoding specification, for example, Japanese,
+ *      and you did not set the parameter to NULL. If you do not
+ *      specify NULL on input and the language is ambiguousÑthat is,
+ *      the function cannot accurately derive it from the text encoding
+ *      specificationÑthe function returns a value of
+ *      kTextLanguageDontCare.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.2 and later in CoreServices.framework
+ *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.2 and later
+ *    Non-Carbon CFM:   not available
+ */
+extern OSStatus 
+GetScriptInfoFromTextEncoding(
+  TextEncoding   iEncoding,
+  ScriptCode *   oTextScriptID,
+  LangCode *     oTextLanguageID)       /* can be NULL */     AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;
+
+
+
+/*
+ *  NearestMacTextEncodings()
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in TextCommon 1.5 and later
+ */
+extern OSStatus 
+NearestMacTextEncodings(
+  TextEncoding    generalEncoding,
+  TextEncoding *  bestMacEncoding,
+  TextEncoding *  alternateMacEncoding)                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+/*
+ *  UCGetCharProperty()
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework
+ *    CarbonLib:        in CarbonLib 1.0 and later
+ *    Non-Carbon CFM:   in TextCommon 1.5 and later
+ */
+extern OSStatus 
+UCGetCharProperty(
+  const UniChar *        charPtr,
+  UniCharCount           textLength,
+  UCCharPropertyType     propType,
+  UCCharPropertyValue *  propValue)                           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
+
+
+
+/*
+   -------------------------------------------------------------------------------------------------
+   Surrogate pair utilities
+   -------------------------------------------------------------------------------------------------
+*/
+
+
+
+#if !defined(UC_INLINE)
+    #if defined(__GNUC__)
+ #define UC_INLINE static __inline__
+    #elif defined(__MWERKS__) || defined(__cplusplus)
+  #define UC_INLINE static inline
+    #endif
+#endif
+
+// surrogate ranges
+enum {
+  kUCHighSurrogateRangeStart  = 0xD800,
+  kUCHighSurrogateRangeEnd    = 0xDBFF,
+  kUCLowSurrogateRangeStart   = 0xDC00,
+  kUCLowSurrogateRangeEnd     = 0xDFFF
+};
+
+
+/*!
+   @function UCIsSurrogateHighCharacter
+   Reports whether or not the character is a high surrogate.
+  @param character  The character to be checked.
+ @result true, if character is a high surrogate, otherwise false.
+*/
+UC_INLINE Boolean UCIsSurrogateHighCharacter( UniChar character ) {
+    /* return ( ( character >= kUCHighSurrogateRangeStart ) && (character <= kUCHighSurrogateRangeEnd ) ? true : false ); */
+   return ( ( character & 0xFC00 ) == kUCHighSurrogateRangeStart );
+}
+
+/*!
+    @function UCIsSurrogateLowCharacter
+    Reports whether or not the character is a low surrogate.
+   @param character  The character to be checked.
+ @result true, if character is a low surrogate, otherwise false.
+*/
+UC_INLINE Boolean UCIsSurrogateLowCharacter( UniChar character ) {
+  /* return ( ( character >= kUCLowSurrogateRangeStart ) && ( character <= kUCLowSurrogateRangeEnd ) ? true : false ); */
+    return ( ( character & 0xFC00 ) == kUCLowSurrogateRangeStart );
+}
+
+/*!
+ @function UCGetUnicodeScalarValueForSurrogatePair
+  Returns the UTF-32 value corresponding to the surrogate pair passed in.
+    @param surrogateHigh  The high surrogate character.  If this parameter
+         is not a valid high surrogate character, the behavior is undefined.
+    @param surrogateLow  The low surrogate character.  If this parameter
+           is not a valid low surrogate character, the behavior is undefined.
+ @result The UTF-32 value for the surrogate pair.
+*/
+UC_INLINE UnicodeScalarValue UCGetUnicodeScalarValueForSurrogatePair( UniChar surrogateHigh, UniChar surrogateLow ) {
+  return ( ( surrogateHigh - kUCHighSurrogateRangeStart ) << 10 ) + ( surrogateLow - kUCLowSurrogateRangeStart ) + 0x0010000;
+}
+
+
+
+#pragma pack(pop)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __TEXTCOMMON__ */
+
diff -Nru ../CarbonHeaders-18.1.orig/UTCUtils.h ./UTCUtils.h
--- ../CarbonHeaders-18.1.orig/UTCUtils.h	1969-12-31 16:00:00.000000000 -0800
+++ ./UTCUtils.h	2009-09-29 14:01:35.000000000 -0700
@@ -0,0 +1,278 @@
+/*
+ * Copyright (c) 2007-2009 by Apple Inc.. All rights reserved.
+ *
+ * @APPLE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this
+ * file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_LICENSE_HEADER_END@
+ */
+/*
+     File:       CarbonCore/UTCUtils.h
+ 
+     Contains:   Interface for UTC to Local Time conversion and 64 Bit Clock routines
+ 
+     Version:    CarbonCore-859.2~1
+ 
+     Copyright:  © 1999-2008 by Apple Inc., all rights reserved.
+ 
+     Bugs?:      For bug reports, consult the following page on
+                 the World Wide Web:
+ 
+                     http://developer.apple.com/bugreporter/
+ 
+*/
+#ifndef __UTCUTILS__
+#define __UTCUTILS__
+
+#ifndef __MACTYPES__
+#include <CarbonCore/MacTypes.h>
+#endif
+
+#ifndef __MACERRORS__
+#include <CarbonCore/MacErrors.h>
+#endif
+
+
+
+#include <AvailabilityMacros.h>
+
+#if PRAGMA_ONCE
+#pragma once
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#pragma pack(push, 2)
+
+/* Options for Set & Get DateTime Routines */
+enum {
+  kUTCDefaultOptions            = 0
+};
+
+/* 64 Bit Clock Typedefs */
+struct UTCDateTime {
+  UInt16              highSeconds;
+  UInt32              lowSeconds;
+  UInt16              fraction;
+};
+typedef struct UTCDateTime              UTCDateTime;
+typedef UTCDateTime *                   UTCDateTimePtr;
+typedef UTCDateTimePtr *                UTCDateTimeHandle;
+struct LocalDateTime {
+  UInt16              highSeconds;
+  UInt32              lowSeconds;
+  UInt16              fraction;
+};
+typedef struct LocalDateTime            LocalDateTime;
+typedef LocalDateTime *                 LocalDateTimePtr;
+typedef LocalDateTimePtr *              LocalDateTimeHandle;
+/* Classic 32 bit clock conversion routines */
+#if !__LP64__
+/*
+ *  ConvertLocalTimeToUTC()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    use
+ *    UCConvertUTCDateTimeToCFAbsoluteTime/CFTimeZoneGetSecondsFromGMT
+ *    instead.
+ *  
+ *  Discussion:
+ *    This function is no longer recommended. Please use
+ *    UCConvertUTCDateTimeToCFAbsoluteTime and
+ *    CFTimeZoneGetSecondsFromGMT instead.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0.2 and later
+ *    Non-Carbon CFM:   in UTCUtils 1.0 and later
+ */
+extern OSStatus 
+ConvertLocalTimeToUTC(
+  UInt32    localSeconds,
+  UInt32 *  utcSeconds)                                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  ConvertUTCToLocalTime()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    use
+ *    UCConvertUTCDateTimeToCFAbsoluteTime/CFTimeZoneGetSecondsFromGMT
+ *    instead.
+ *  
+ *  Discussion:
+ *    This function is no longer recommended. Please use
+ *    UCConvertUTCDateTimeToCFAbsoluteTime and
+ *    CFTimeZoneGetSecondsFromGMT instead.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0.2 and later
+ *    Non-Carbon CFM:   in UTCUtils 1.0 and later
+ */
+extern OSStatus 
+ConvertUTCToLocalTime(
+  UInt32    utcSeconds,
+  UInt32 *  localSeconds)                                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* 64 bit clock conversion routines */
+/*
+ *  ConvertUTCToLocalDateTime()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    use
+ *    UCConvertUTCDateTimeToCFAbsoluteTime/CFTimeZoneGetSecondsFromGMT
+ *    instead.
+ *  
+ *  Discussion:
+ *    This function is no longer recommended. Please use
+ *    UCConvertUTCDateTimeToCFAbsoluteTime and
+ *    CFTimeZoneGetSecondsFromGMT instead.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0.2 and later
+ *    Non-Carbon CFM:   in UTCUtils 1.0 and later
+ */
+extern OSStatus 
+ConvertUTCToLocalDateTime(
+  const UTCDateTime *  utcDateTime,
+  LocalDateTime *      localDateTime)                         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  ConvertLocalToUTCDateTime()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    use
+ *    UCConvertUTCDateTimeToCFAbsoluteTime/CFTimeZoneGetSecondsFromGMT
+ *    instead.
+ *  
+ *  Discussion:
+ *    This function is no longer recommended. Please use
+ *    UCConvertUTCDateTimeToCFAbsoluteTime and
+ *    CFTimeZoneGetSecondsFromGMT instead.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0.2 and later
+ *    Non-Carbon CFM:   in UTCUtils 1.0 and later
+ */
+extern OSStatus 
+ConvertLocalToUTCDateTime(
+  const LocalDateTime *  localDateTime,
+  UTCDateTime *          utcDateTime)                         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/* Getter and Setter Clock routines using 64 Bit values */
+/*
+ *  GetUTCDateTime()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    use CFAbsoluteTimeGetCurrent instead.
+ *  
+ *  Discussion:
+ *    This function is no longer recommended. Please use
+ *    CFAbsoluteTimeGetCurrent instead.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0.2 and later
+ *    Non-Carbon CFM:   in UTCUtils 1.0 and later
+ */
+extern OSStatus 
+GetUTCDateTime(
+  UTCDateTime *  utcDateTime,
+  OptionBits     options)                                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  SetUTCDateTime()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    use settimeofday (2) instead.
+ *  
+ *  Discussion:
+ *    This function is no longer recommended. Setting the time requires
+ *    root privileges. If you must, use settimeofday (2)
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0.2 and later
+ *    Non-Carbon CFM:   in UTCUtils 1.0 and later
+ */
+extern OSStatus 
+SetUTCDateTime(
+  const UTCDateTime *  utcDateTime,
+  OptionBits           options)                               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  GetLocalDateTime()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    use CFAbsoluteTimeGetCurrent/CFTimeZoneGetSecondsFromGMT instead.
+ *  
+ *  Discussion:
+ *    This function is no longer recommended. Please use
+ *    CFAbsoluteTimeGetCurrent and CFTimeZoneGetSecondsFromGMT instead.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0.2 and later
+ *    Non-Carbon CFM:   in UTCUtils 1.0 and later
+ */
+extern OSStatus 
+GetLocalDateTime(
+  LocalDateTime *  localDateTime,
+  OptionBits       options)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+/*
+ *  SetLocalDateTime()   *** DEPRECATED ***
+ *  
+ *  Deprecated:
+ *    it without replacement
+ *  
+ *  Discussion:
+ *    This function is no longer recommended. There is no replacement.
+ *  
+ *  Availability:
+ *    Mac OS X:         in version 10.0 and later in CoreServices.framework [32-bit only] but deprecated in 10.4
+ *    CarbonLib:        in CarbonLib 1.0.2 and later
+ *    Non-Carbon CFM:   in UTCUtils 1.0 and later
+ */
+extern OSStatus 
+SetLocalDateTime(
+  const LocalDateTime *  localDateTime,
+  OptionBits             options)                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;
+
+
+#endif  /* !__LP64__ */
+
+
+#pragma pack(pop)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __UTCUTILS__ */
+
